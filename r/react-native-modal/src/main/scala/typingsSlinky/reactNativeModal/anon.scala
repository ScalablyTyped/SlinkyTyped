package typingsSlinky.reactNativeModal

import org.scalablytyped.runtime.StringDictionary
import typingsSlinky.propTypes.mod.ReactElementLike
import typingsSlinky.propTypes.mod.ReactNodeArray
import typingsSlinky.propTypes.mod.ReactNodeLike
import typingsSlinky.propTypes.mod.Requireable
import typingsSlinky.propTypes.mod.Validator
import typingsSlinky.reactNativeModal.reactNativeModalStrings.absolute
import typingsSlinky.reactNativeModal.reactNativeModalStrings.center
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object anon {
  
  @js.native
  trait AnimationIn extends StObject {
    
    var animationIn: Requireable[String | js.Object] = js.native
    
    var animationInTiming: Requireable[Double] = js.native
    
    var animationOut: Requireable[String | js.Object] = js.native
    
    var animationOutTiming: Requireable[Double] = js.native
    
    var avoidKeyboard: Requireable[Boolean] = js.native
    
    var backdropColor: Requireable[String] = js.native
    
    var backdropOpacity: Requireable[Double] = js.native
    
    var backdropTransitionInTiming: Requireable[Double] = js.native
    
    var backdropTransitionOutTiming: Requireable[Double] = js.native
    
    var children: Validator[String | Double | Boolean | js.Object | ReactElementLike | ReactNodeArray] = js.native
    
    var coverScreen: Requireable[Boolean] = js.native
    
    var customBackdrop: Requireable[ReactNodeLike] = js.native
    
    var deviceHeight: Requireable[Double] = js.native
    
    var deviceWidth: Requireable[Double] = js.native
    
    var hasBackdrop: Requireable[Boolean] = js.native
    
    var hideModalContentWhileAnimating: Requireable[Boolean] = js.native
    
    var isVisible: Validator[Boolean] = js.native
    
    var onBackButtonPress: Requireable[js.Function1[/* repeated */ _, _]] = js.native
    
    var onBackdropPress: Requireable[js.Function1[/* repeated */ _, _]] = js.native
    
    var onModalHide: Requireable[js.Function1[/* repeated */ _, _]] = js.native
    
    var onModalShow: Requireable[js.Function1[/* repeated */ _, _]] = js.native
    
    var onModalWillHide: Requireable[js.Function1[/* repeated */ _, _]] = js.native
    
    var onModalWillShow: Requireable[js.Function1[/* repeated */ _, _]] = js.native
    
    var onSwipeCancel: Requireable[js.Function1[/* repeated */ _, _]] = js.native
    
    var onSwipeComplete: Requireable[js.Function1[/* repeated */ _, _]] = js.native
    
    var onSwipeMove: Requireable[js.Function1[/* repeated */ _, _]] = js.native
    
    var onSwipeStart: Requireable[js.Function1[/* repeated */ _, _]] = js.native
    
    var propagateSwipe: Requireable[Boolean] = js.native
    
    var scrollHorizontal: Requireable[Boolean] = js.native
    
    var scrollOffset: Requireable[Double] = js.native
    
    var scrollOffsetMax: Requireable[Double] = js.native
    
    var scrollTo: Requireable[js.Function1[/* repeated */ _, _]] = js.native
    
    var style: Requireable[_] = js.native
    
    var supportedOrientations: Requireable[js.Array[js.UndefOr[String | Null]]] = js.native
    
    var swipeDirection: Requireable[String | (js.Array[js.UndefOr[String | Null]])] = js.native
    
    var swipeThreshold: Requireable[Double] = js.native
    
    var useNativeDriver: Requireable[Boolean] = js.native
  }
  object AnimationIn {
    
    @scala.inline
    def apply(
      animationIn: Requireable[String | js.Object],
      animationInTiming: Requireable[Double],
      animationOut: Requireable[String | js.Object],
      animationOutTiming: Requireable[Double],
      avoidKeyboard: Requireable[Boolean],
      backdropColor: Requireable[String],
      backdropOpacity: Requireable[Double],
      backdropTransitionInTiming: Requireable[Double],
      backdropTransitionOutTiming: Requireable[Double],
      children: Validator[String | Double | Boolean | js.Object | ReactElementLike | ReactNodeArray],
      coverScreen: Requireable[Boolean],
      customBackdrop: Requireable[ReactNodeLike],
      deviceHeight: Requireable[Double],
      deviceWidth: Requireable[Double],
      hasBackdrop: Requireable[Boolean],
      hideModalContentWhileAnimating: Requireable[Boolean],
      isVisible: Validator[Boolean],
      onBackButtonPress: Requireable[js.Function1[/* repeated */ _, _]],
      onBackdropPress: Requireable[js.Function1[/* repeated */ _, _]],
      onModalHide: Requireable[js.Function1[/* repeated */ _, _]],
      onModalShow: Requireable[js.Function1[/* repeated */ _, _]],
      onModalWillHide: Requireable[js.Function1[/* repeated */ _, _]],
      onModalWillShow: Requireable[js.Function1[/* repeated */ _, _]],
      onSwipeCancel: Requireable[js.Function1[/* repeated */ _, _]],
      onSwipeComplete: Requireable[js.Function1[/* repeated */ _, _]],
      onSwipeMove: Requireable[js.Function1[/* repeated */ _, _]],
      onSwipeStart: Requireable[js.Function1[/* repeated */ _, _]],
      propagateSwipe: Requireable[Boolean],
      scrollHorizontal: Requireable[Boolean],
      scrollOffset: Requireable[Double],
      scrollOffsetMax: Requireable[Double],
      scrollTo: Requireable[js.Function1[/* repeated */ _, _]],
      style: Requireable[_],
      supportedOrientations: Requireable[js.Array[js.UndefOr[String | Null]]],
      swipeDirection: Requireable[String | (js.Array[js.UndefOr[String | Null]])],
      swipeThreshold: Requireable[Double],
      useNativeDriver: Requireable[Boolean]
    ): AnimationIn = {
      val __obj = js.Dynamic.literal(animationIn = animationIn.asInstanceOf[js.Any], animationInTiming = animationInTiming.asInstanceOf[js.Any], animationOut = animationOut.asInstanceOf[js.Any], animationOutTiming = animationOutTiming.asInstanceOf[js.Any], avoidKeyboard = avoidKeyboard.asInstanceOf[js.Any], backdropColor = backdropColor.asInstanceOf[js.Any], backdropOpacity = backdropOpacity.asInstanceOf[js.Any], backdropTransitionInTiming = backdropTransitionInTiming.asInstanceOf[js.Any], backdropTransitionOutTiming = backdropTransitionOutTiming.asInstanceOf[js.Any], children = children.asInstanceOf[js.Any], coverScreen = coverScreen.asInstanceOf[js.Any], customBackdrop = customBackdrop.asInstanceOf[js.Any], deviceHeight = deviceHeight.asInstanceOf[js.Any], deviceWidth = deviceWidth.asInstanceOf[js.Any], hasBackdrop = hasBackdrop.asInstanceOf[js.Any], hideModalContentWhileAnimating = hideModalContentWhileAnimating.asInstanceOf[js.Any], isVisible = isVisible.asInstanceOf[js.Any], onBackButtonPress = onBackButtonPress.asInstanceOf[js.Any], onBackdropPress = onBackdropPress.asInstanceOf[js.Any], onModalHide = onModalHide.asInstanceOf[js.Any], onModalShow = onModalShow.asInstanceOf[js.Any], onModalWillHide = onModalWillHide.asInstanceOf[js.Any], onModalWillShow = onModalWillShow.asInstanceOf[js.Any], onSwipeCancel = onSwipeCancel.asInstanceOf[js.Any], onSwipeComplete = onSwipeComplete.asInstanceOf[js.Any], onSwipeMove = onSwipeMove.asInstanceOf[js.Any], onSwipeStart = onSwipeStart.asInstanceOf[js.Any], propagateSwipe = propagateSwipe.asInstanceOf[js.Any], scrollHorizontal = scrollHorizontal.asInstanceOf[js.Any], scrollOffset = scrollOffset.asInstanceOf[js.Any], scrollOffsetMax = scrollOffsetMax.asInstanceOf[js.Any], scrollTo = scrollTo.asInstanceOf[js.Any], style = style.asInstanceOf[js.Any], supportedOrientations = supportedOrientations.asInstanceOf[js.Any], swipeDirection = swipeDirection.asInstanceOf[js.Any], swipeThreshold = swipeThreshold.asInstanceOf[js.Any], useNativeDriver = useNativeDriver.asInstanceOf[js.Any])
      __obj.asInstanceOf[AnimationIn]
    }
    
    @scala.inline
    implicit class AnimationInMutableBuilder[Self <: AnimationIn] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setAnimationIn(value: Requireable[String | js.Object]): Self = StObject.set(x, "animationIn", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAnimationInTiming(value: Requireable[Double]): Self = StObject.set(x, "animationInTiming", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAnimationOut(value: Requireable[String | js.Object]): Self = StObject.set(x, "animationOut", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAnimationOutTiming(value: Requireable[Double]): Self = StObject.set(x, "animationOutTiming", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAvoidKeyboard(value: Requireable[Boolean]): Self = StObject.set(x, "avoidKeyboard", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBackdropColor(value: Requireable[String]): Self = StObject.set(x, "backdropColor", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBackdropOpacity(value: Requireable[Double]): Self = StObject.set(x, "backdropOpacity", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBackdropTransitionInTiming(value: Requireable[Double]): Self = StObject.set(x, "backdropTransitionInTiming", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBackdropTransitionOutTiming(value: Requireable[Double]): Self = StObject.set(x, "backdropTransitionOutTiming", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setChildren(value: Validator[String | Double | Boolean | js.Object | ReactElementLike | ReactNodeArray]): Self = StObject.set(x, "children", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCoverScreen(value: Requireable[Boolean]): Self = StObject.set(x, "coverScreen", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCustomBackdrop(value: Requireable[ReactNodeLike]): Self = StObject.set(x, "customBackdrop", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeviceHeight(value: Requireable[Double]): Self = StObject.set(x, "deviceHeight", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeviceWidth(value: Requireable[Double]): Self = StObject.set(x, "deviceWidth", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setHasBackdrop(value: Requireable[Boolean]): Self = StObject.set(x, "hasBackdrop", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setHideModalContentWhileAnimating(value: Requireable[Boolean]): Self = StObject.set(x, "hideModalContentWhileAnimating", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setIsVisible(value: Validator[Boolean]): Self = StObject.set(x, "isVisible", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOnBackButtonPress(value: Requireable[js.Function1[/* repeated */ _, _]]): Self = StObject.set(x, "onBackButtonPress", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOnBackdropPress(value: Requireable[js.Function1[/* repeated */ _, _]]): Self = StObject.set(x, "onBackdropPress", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOnModalHide(value: Requireable[js.Function1[/* repeated */ _, _]]): Self = StObject.set(x, "onModalHide", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOnModalShow(value: Requireable[js.Function1[/* repeated */ _, _]]): Self = StObject.set(x, "onModalShow", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOnModalWillHide(value: Requireable[js.Function1[/* repeated */ _, _]]): Self = StObject.set(x, "onModalWillHide", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOnModalWillShow(value: Requireable[js.Function1[/* repeated */ _, _]]): Self = StObject.set(x, "onModalWillShow", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOnSwipeCancel(value: Requireable[js.Function1[/* repeated */ _, _]]): Self = StObject.set(x, "onSwipeCancel", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOnSwipeComplete(value: Requireable[js.Function1[/* repeated */ _, _]]): Self = StObject.set(x, "onSwipeComplete", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOnSwipeMove(value: Requireable[js.Function1[/* repeated */ _, _]]): Self = StObject.set(x, "onSwipeMove", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOnSwipeStart(value: Requireable[js.Function1[/* repeated */ _, _]]): Self = StObject.set(x, "onSwipeStart", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPropagateSwipe(value: Requireable[Boolean]): Self = StObject.set(x, "propagateSwipe", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setScrollHorizontal(value: Requireable[Boolean]): Self = StObject.set(x, "scrollHorizontal", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setScrollOffset(value: Requireable[Double]): Self = StObject.set(x, "scrollOffset", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setScrollOffsetMax(value: Requireable[Double]): Self = StObject.set(x, "scrollOffsetMax", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setScrollTo(value: Requireable[js.Function1[/* repeated */ _, _]]): Self = StObject.set(x, "scrollTo", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setStyle(value: Requireable[_]): Self = StObject.set(x, "style", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSupportedOrientations(value: Requireable[js.Array[js.UndefOr[String | Null]]]): Self = StObject.set(x, "supportedOrientations", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSwipeDirection(value: Requireable[String | (js.Array[js.UndefOr[String | Null]])]): Self = StObject.set(x, "swipeDirection", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSwipeThreshold(value: Requireable[Double]): Self = StObject.set(x, "swipeThreshold", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUseNativeDriver(value: Requireable[Boolean]): Self = StObject.set(x, "useNativeDriver", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait AnimationInTiming extends StObject {
    
    var animationIn: String = js.native
    
    var animationInTiming: Double = js.native
    
    var animationOut: String = js.native
    
    var animationOutTiming: Double = js.native
    
    var avoidKeyboard: Boolean = js.native
    
    var backdropColor: String = js.native
    
    var backdropOpacity: Double = js.native
    
    var backdropTransitionInTiming: Double = js.native
    
    var backdropTransitionOutTiming: Double = js.native
    
    var coverScreen: Boolean = js.native
    
    var customBackdrop: Null = js.native
    
    var deviceHeight: Null = js.native
    
    var deviceWidth: Null = js.native
    
    var hasBackdrop: Boolean = js.native
    
    var hideModalContentWhileAnimating: Boolean = js.native
    
    var isVisible: Boolean = js.native
    
    def onBackButtonPress(): Null = js.native
    
    def onBackdropPress(): Null = js.native
    
    def onModalHide(): Null = js.native
    
    def onModalShow(): Null = js.native
    
    def onModalWillHide(): Null = js.native
    
    def onModalWillShow(): Null = js.native
    
    var propagateSwipe: Boolean = js.native
    
    var scrollHorizontal: Boolean = js.native
    
    var scrollOffset: Double = js.native
    
    var scrollOffsetMax: Double = js.native
    
    var scrollTo: Null = js.native
    
    var supportedOrientations: js.Array[String] = js.native
    
    var swipeThreshold: Double = js.native
    
    var useNativeDriver: Boolean = js.native
  }
  object AnimationInTiming {
    
    @scala.inline
    def apply(
      animationIn: String,
      animationInTiming: Double,
      animationOut: String,
      animationOutTiming: Double,
      avoidKeyboard: Boolean,
      backdropColor: String,
      backdropOpacity: Double,
      backdropTransitionInTiming: Double,
      backdropTransitionOutTiming: Double,
      coverScreen: Boolean,
      customBackdrop: Null,
      deviceHeight: Null,
      deviceWidth: Null,
      hasBackdrop: Boolean,
      hideModalContentWhileAnimating: Boolean,
      isVisible: Boolean,
      onBackButtonPress: () => Null,
      onBackdropPress: () => Null,
      onModalHide: () => Null,
      onModalShow: () => Null,
      onModalWillHide: () => Null,
      onModalWillShow: () => Null,
      propagateSwipe: Boolean,
      scrollHorizontal: Boolean,
      scrollOffset: Double,
      scrollOffsetMax: Double,
      scrollTo: Null,
      supportedOrientations: js.Array[String],
      swipeThreshold: Double,
      useNativeDriver: Boolean
    ): AnimationInTiming = {
      val __obj = js.Dynamic.literal(animationIn = animationIn.asInstanceOf[js.Any], animationInTiming = animationInTiming.asInstanceOf[js.Any], animationOut = animationOut.asInstanceOf[js.Any], animationOutTiming = animationOutTiming.asInstanceOf[js.Any], avoidKeyboard = avoidKeyboard.asInstanceOf[js.Any], backdropColor = backdropColor.asInstanceOf[js.Any], backdropOpacity = backdropOpacity.asInstanceOf[js.Any], backdropTransitionInTiming = backdropTransitionInTiming.asInstanceOf[js.Any], backdropTransitionOutTiming = backdropTransitionOutTiming.asInstanceOf[js.Any], coverScreen = coverScreen.asInstanceOf[js.Any], customBackdrop = customBackdrop.asInstanceOf[js.Any], deviceHeight = deviceHeight.asInstanceOf[js.Any], deviceWidth = deviceWidth.asInstanceOf[js.Any], hasBackdrop = hasBackdrop.asInstanceOf[js.Any], hideModalContentWhileAnimating = hideModalContentWhileAnimating.asInstanceOf[js.Any], isVisible = isVisible.asInstanceOf[js.Any], onBackButtonPress = js.Any.fromFunction0(onBackButtonPress), onBackdropPress = js.Any.fromFunction0(onBackdropPress), onModalHide = js.Any.fromFunction0(onModalHide), onModalShow = js.Any.fromFunction0(onModalShow), onModalWillHide = js.Any.fromFunction0(onModalWillHide), onModalWillShow = js.Any.fromFunction0(onModalWillShow), propagateSwipe = propagateSwipe.asInstanceOf[js.Any], scrollHorizontal = scrollHorizontal.asInstanceOf[js.Any], scrollOffset = scrollOffset.asInstanceOf[js.Any], scrollOffsetMax = scrollOffsetMax.asInstanceOf[js.Any], scrollTo = scrollTo.asInstanceOf[js.Any], supportedOrientations = supportedOrientations.asInstanceOf[js.Any], swipeThreshold = swipeThreshold.asInstanceOf[js.Any], useNativeDriver = useNativeDriver.asInstanceOf[js.Any])
      __obj.asInstanceOf[AnimationInTiming]
    }
    
    @scala.inline
    implicit class AnimationInTimingMutableBuilder[Self <: AnimationInTiming] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setAnimationIn(value: String): Self = StObject.set(x, "animationIn", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAnimationInTiming(value: Double): Self = StObject.set(x, "animationInTiming", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAnimationOut(value: String): Self = StObject.set(x, "animationOut", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAnimationOutTiming(value: Double): Self = StObject.set(x, "animationOutTiming", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAvoidKeyboard(value: Boolean): Self = StObject.set(x, "avoidKeyboard", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBackdropColor(value: String): Self = StObject.set(x, "backdropColor", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBackdropOpacity(value: Double): Self = StObject.set(x, "backdropOpacity", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBackdropTransitionInTiming(value: Double): Self = StObject.set(x, "backdropTransitionInTiming", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBackdropTransitionOutTiming(value: Double): Self = StObject.set(x, "backdropTransitionOutTiming", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCoverScreen(value: Boolean): Self = StObject.set(x, "coverScreen", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCustomBackdrop(value: Null): Self = StObject.set(x, "customBackdrop", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeviceHeight(value: Null): Self = StObject.set(x, "deviceHeight", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeviceWidth(value: Null): Self = StObject.set(x, "deviceWidth", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setHasBackdrop(value: Boolean): Self = StObject.set(x, "hasBackdrop", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setHideModalContentWhileAnimating(value: Boolean): Self = StObject.set(x, "hideModalContentWhileAnimating", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setIsVisible(value: Boolean): Self = StObject.set(x, "isVisible", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOnBackButtonPress(value: () => Null): Self = StObject.set(x, "onBackButtonPress", js.Any.fromFunction0(value))
      
      @scala.inline
      def setOnBackdropPress(value: () => Null): Self = StObject.set(x, "onBackdropPress", js.Any.fromFunction0(value))
      
      @scala.inline
      def setOnModalHide(value: () => Null): Self = StObject.set(x, "onModalHide", js.Any.fromFunction0(value))
      
      @scala.inline
      def setOnModalShow(value: () => Null): Self = StObject.set(x, "onModalShow", js.Any.fromFunction0(value))
      
      @scala.inline
      def setOnModalWillHide(value: () => Null): Self = StObject.set(x, "onModalWillHide", js.Any.fromFunction0(value))
      
      @scala.inline
      def setOnModalWillShow(value: () => Null): Self = StObject.set(x, "onModalWillShow", js.Any.fromFunction0(value))
      
      @scala.inline
      def setPropagateSwipe(value: Boolean): Self = StObject.set(x, "propagateSwipe", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setScrollHorizontal(value: Boolean): Self = StObject.set(x, "scrollHorizontal", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setScrollOffset(value: Double): Self = StObject.set(x, "scrollOffset", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setScrollOffsetMax(value: Double): Self = StObject.set(x, "scrollOffsetMax", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setScrollTo(value: Null): Self = StObject.set(x, "scrollTo", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSupportedOrientations(value: js.Array[String]): Self = StObject.set(x, "supportedOrientations", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSupportedOrientationsVarargs(value: String*): Self = StObject.set(x, "supportedOrientations", js.Array(value :_*))
      
      @scala.inline
      def setSwipeThreshold(value: Double): Self = StObject.set(x, "swipeThreshold", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUseNativeDriver(value: Boolean): Self = StObject.set(x, "useNativeDriver", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait AnimationOut extends StObject {
    
    var animationIn: /* import warning: LimitUnionLength.leaveTypeRef Was union type with length 63 */ js.Any = js.native
    
    var animationOut: /* import warning: LimitUnionLength.leaveTypeRef Was union type with length 63 */ js.Any = js.native
  }
  object AnimationOut {
    
    @scala.inline
    def apply(
      animationIn: /* import warning: LimitUnionLength.leaveTypeRef Was union type with length 63 */ js.Any,
      animationOut: /* import warning: LimitUnionLength.leaveTypeRef Was union type with length 63 */ js.Any
    ): AnimationOut = {
      val __obj = js.Dynamic.literal(animationIn = animationIn.asInstanceOf[js.Any], animationOut = animationOut.asInstanceOf[js.Any])
      __obj.asInstanceOf[AnimationOut]
    }
    
    @scala.inline
    implicit class AnimationOutMutableBuilder[Self <: AnimationOut] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setAnimationIn(value: /* import warning: LimitUnionLength.leaveTypeRef Was union type with length 63 */ js.Any): Self = StObject.set(x, "animationIn", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAnimationOut(value: /* import warning: LimitUnionLength.leaveTypeRef Was union type with length 63 */ js.Any): Self = StObject.set(x, "animationOut", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait BackgroundColor extends StObject {
    
    var backgroundColor: String = js.native
    
    var bottom: Double = js.native
    
    var left: Double = js.native
    
    var opacity: Double = js.native
    
    var position: absolute = js.native
    
    var right: Double = js.native
    
    var top: Double = js.native
  }
  object BackgroundColor {
    
    @scala.inline
    def apply(
      backgroundColor: String,
      bottom: Double,
      left: Double,
      opacity: Double,
      position: absolute,
      right: Double,
      top: Double
    ): BackgroundColor = {
      val __obj = js.Dynamic.literal(backgroundColor = backgroundColor.asInstanceOf[js.Any], bottom = bottom.asInstanceOf[js.Any], left = left.asInstanceOf[js.Any], opacity = opacity.asInstanceOf[js.Any], position = position.asInstanceOf[js.Any], right = right.asInstanceOf[js.Any], top = top.asInstanceOf[js.Any])
      __obj.asInstanceOf[BackgroundColor]
    }
    
    @scala.inline
    implicit class BackgroundColorMutableBuilder[Self <: BackgroundColor] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setBackgroundColor(value: String): Self = StObject.set(x, "backgroundColor", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBottom(value: Double): Self = StObject.set(x, "bottom", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLeft(value: Double): Self = StObject.set(x, "left", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOpacity(value: Double): Self = StObject.set(x, "opacity", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPosition(value: absolute): Self = StObject.set(x, "position", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setRight(value: Double): Self = StObject.set(x, "right", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTop(value: Double): Self = StObject.set(x, "top", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait Flex extends StObject {
    
    var flex: Double = js.native
    
    var justifyContent: center = js.native
  }
  object Flex {
    
    @scala.inline
    def apply(flex: Double, justifyContent: center): Flex = {
      val __obj = js.Dynamic.literal(flex = flex.asInstanceOf[js.Any], justifyContent = justifyContent.asInstanceOf[js.Any])
      __obj.asInstanceOf[Flex]
    }
    
    @scala.inline
    implicit class FlexMutableBuilder[Self <: Flex] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setFlex(value: Double): Self = StObject.set(x, "flex", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJustifyContent(value: center): Self = StObject.set(x, "justifyContent", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait From extends StObject {
    
    var from: StringDictionary[Double] = js.native
    
    var to: StringDictionary[Double] = js.native
  }
  object From {
    
    @scala.inline
    def apply(from: StringDictionary[Double], to: StringDictionary[Double]): From = {
      val __obj = js.Dynamic.literal(from = from.asInstanceOf[js.Any], to = to.asInstanceOf[js.Any])
      __obj.asInstanceOf[From]
    }
    
    @scala.inline
    implicit class FromMutableBuilder[Self <: From] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setFrom(value: StringDictionary[Double]): Self = StObject.set(x, "from", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTo(value: StringDictionary[Double]): Self = StObject.set(x, "to", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait IsVisible extends StObject {
    
    var isVisible: Boolean = js.native
    
    var showContent: Boolean = js.native
  }
  object IsVisible {
    
    @scala.inline
    def apply(isVisible: Boolean, showContent: Boolean): IsVisible = {
      val __obj = js.Dynamic.literal(isVisible = isVisible.asInstanceOf[js.Any], showContent = showContent.asInstanceOf[js.Any])
      __obj.asInstanceOf[IsVisible]
    }
    
    @scala.inline
    implicit class IsVisibleMutableBuilder[Self <: IsVisible] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setIsVisible(value: Boolean): Self = StObject.set(x, "isVisible", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setShowContent(value: Boolean): Self = StObject.set(x, "showContent", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait Opacity extends StObject {
    
    var backgroundColor: String = js.native
    
    var opacity: Double = js.native
    
    var zIndex: Double = js.native
  }
  object Opacity {
    
    @scala.inline
    def apply(backgroundColor: String, opacity: Double, zIndex: Double): Opacity = {
      val __obj = js.Dynamic.literal(backgroundColor = backgroundColor.asInstanceOf[js.Any], opacity = opacity.asInstanceOf[js.Any], zIndex = zIndex.asInstanceOf[js.Any])
      __obj.asInstanceOf[Opacity]
    }
    
    @scala.inline
    implicit class OpacityMutableBuilder[Self <: Opacity] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setBackgroundColor(value: String): Self = StObject.set(x, "backgroundColor", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOpacity(value: Double): Self = StObject.set(x, "opacity", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setZIndex(value: Double): Self = StObject.set(x, "zIndex", value.asInstanceOf[js.Any])
    }
  }
}
