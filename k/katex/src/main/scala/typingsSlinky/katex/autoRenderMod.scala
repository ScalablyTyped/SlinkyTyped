package typingsSlinky.katex

import org.scalajs.dom.raw.HTMLElement
import typingsSlinky.katex.mod.KatexOptions
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object autoRenderMod {
  
  /**
    * Auto-render TeX expressions in HTML element
    * @param elem HTML element to auto-render
    * @param options Render options
    */
  @JSImport("katex/dist/contrib/auto-render", JSImport.Default)
  @js.native
  def default(elem: HTMLElement): Unit = js.native
  @JSImport("katex/dist/contrib/auto-render", JSImport.Default)
  @js.native
  def default(elem: HTMLElement, options: RenderMathInElementOptions): Unit = js.native
  
  type RenderMathInElementOptions = KatexOptions with RenderMathInElementSpecificOptions
  
  @js.native
  trait RenderMathInElementSpecificOptions extends StObject {
    
    /**
      * A list of delimiters to look for math
      *
      * @default [
      *   {left: "$$", right: "$$", display: true},
      *   {left: "\\(", right: "\\)", display: false},
      *   {left: "\\[", right: "\\]", display: true}
      * ]
      */
    var delimiters: js.UndefOr[js.Array[RenderMathInElementSpecificOptionsDelimiters]] = js.native
    
    /**
      * A callback method returning a message and an error stack in case of an critical error during rendering
      * @param msg Message generated by KaTeX
      * @param err Caught error
      *
      * @default console.error
      */
    var errorCallback: js.UndefOr[js.Function2[/* msg */ String, /* err */ js.Error, Unit]] = js.native
    
    /**
      * A list of DOM node class names to ignore when recursing through
      *
      * @default []
      */
    var ignoredClasses: js.UndefOr[js.Array[String]] = js.native
    
    /**
      * A list of DOM node types to ignore when recursing through
      *
      * @default ["script", "noscript", "style", "textarea", "pre", "code"]
      */
    var ignoredTags: js.UndefOr[
        js.Array[
          /* import warning: LimitUnionLength.leaveTypeRef Was union type with length 119 */ js.Any
        ]
      ] = js.native
  }
  object RenderMathInElementSpecificOptions {
    
    @scala.inline
    def apply(): RenderMathInElementSpecificOptions = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[RenderMathInElementSpecificOptions]
    }
    
    @scala.inline
    implicit class RenderMathInElementSpecificOptionsMutableBuilder[Self <: RenderMathInElementSpecificOptions] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setDelimiters(value: js.Array[RenderMathInElementSpecificOptionsDelimiters]): Self = StObject.set(x, "delimiters", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDelimitersUndefined: Self = StObject.set(x, "delimiters", js.undefined)
      
      @scala.inline
      def setDelimitersVarargs(value: RenderMathInElementSpecificOptionsDelimiters*): Self = StObject.set(x, "delimiters", js.Array(value :_*))
      
      @scala.inline
      def setErrorCallback(value: (/* msg */ String, /* err */ js.Error) => Unit): Self = StObject.set(x, "errorCallback", js.Any.fromFunction2(value))
      
      @scala.inline
      def setErrorCallbackUndefined: Self = StObject.set(x, "errorCallback", js.undefined)
      
      @scala.inline
      def setIgnoredClasses(value: js.Array[String]): Self = StObject.set(x, "ignoredClasses", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setIgnoredClassesUndefined: Self = StObject.set(x, "ignoredClasses", js.undefined)
      
      @scala.inline
      def setIgnoredClassesVarargs(value: String*): Self = StObject.set(x, "ignoredClasses", js.Array(value :_*))
      
      @scala.inline
      def setIgnoredTags(
        value: js.Array[
              /* import warning: LimitUnionLength.leaveTypeRef Was union type with length 119 */ js.Any
            ]
      ): Self = StObject.set(x, "ignoredTags", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setIgnoredTagsUndefined: Self = StObject.set(x, "ignoredTags", js.undefined)
      
      @scala.inline
      def setIgnoredTagsVarargs(
        value: (/* import warning: LimitUnionLength.leaveTypeRef Was union type with length 119 */ js.Any)*
      ): Self = StObject.set(x, "ignoredTags", js.Array(value :_*))
    }
  }
  
  @js.native
  trait RenderMathInElementSpecificOptionsDelimiters extends StObject {
    
    /**
      * A boolean of whether the math in the expression should be rendered in display mode or not
      */
    var display: Boolean = js.native
    
    /**
      * A string which starts the math expression (i.e. the left delimiter)
      */
    var left: String = js.native
    
    /**
      * A string which ends the math expression (i.e. the right delimiter)
      */
    var right: String = js.native
  }
  object RenderMathInElementSpecificOptionsDelimiters {
    
    @scala.inline
    def apply(display: Boolean, left: String, right: String): RenderMathInElementSpecificOptionsDelimiters = {
      val __obj = js.Dynamic.literal(display = display.asInstanceOf[js.Any], left = left.asInstanceOf[js.Any], right = right.asInstanceOf[js.Any])
      __obj.asInstanceOf[RenderMathInElementSpecificOptionsDelimiters]
    }
    
    @scala.inline
    implicit class RenderMathInElementSpecificOptionsDelimitersMutableBuilder[Self <: RenderMathInElementSpecificOptionsDelimiters] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setDisplay(value: Boolean): Self = StObject.set(x, "display", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLeft(value: String): Self = StObject.set(x, "left", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setRight(value: String): Self = StObject.set(x, "right", value.asInstanceOf[js.Any])
    }
  }
}
