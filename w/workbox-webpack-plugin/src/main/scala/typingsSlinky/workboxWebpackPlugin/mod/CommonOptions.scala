package typingsSlinky.workboxWebpackPlugin.mod

import org.scalablytyped.runtime.StringDictionary
import typingsSlinky.workboxWebpackPlugin.anon.Integrity
import typingsSlinky.workboxWebpackPlugin.anon.Manifest
import typingsSlinky.workboxWebpackPlugin.workboxWebpackPluginStrings.production
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

@js.native
trait CommonOptions extends js.Object {
  
  /**
    * A list of entries to be precached, in addition to any entries that are generated as part of the build configuration.
    */
  var additionalManifestEntries: js.UndefOr[js.Array[Integrity | String]] = js.native
  
  /**
    * By default, Workbox will precache assets regardless of which chunk the asset is part of.
    *
    * If you would like to override this behavior via a whitelist, specify one or more chunk names. Only assets belonging to those chunks will be precached;
    * any assets belonging to another chunk or without a chunk association will be skipped.
    *
    * @default []
    * @example chunks: ['chunk-name-1', 'chunk-name-2']
    */
  var chunks: js.UndefOr[js.Array[String]] = js.native
  
  /**
    * Assets that match this regex will be assumed to be uniquely versioned via their URL, and exempted from the normal HTTP cache-busting that's done when populating the precache.
    *
    * While not required, it's recommended that if your existing build process already inserts a `[hash]` value into each filename, you provide a RegExp that will detect those values,
    * as it will reduce the amount of bandwidth consumed when precaching.
    *
    * @default null
    * @example dontCacheBustUrlsMatching: /\.\w{8}\./
    */
  var dontCacheBustUrlsMatching: js.UndefOr[js.RegExp | Null] = js.native
  
  /**
    * This allows you to specifically omit assets matching any of the provided criteria from being included in the precache manifest. It provides a filename-based approach to filtering.
    *
    * This filtering takes place after any chunk-based filtering is applied.
    *
    * @default [/\.map$/, /^manifest.*\.js(?:on)?$/]
    * @example exclude: [/\.jpg$/, /\.png$/]
    */
  var exclude: js.UndefOr[js.Array[String | js.RegExp]] = js.native
  
  /**
    * By default, Workbox will precache all assets generated by the webpack compilation, regardless of which chunk the asset is part of.
    *
    * If you would like to override this behavior via a blacklist, specify one or more chunk names. Any assets belonging to those chunks will be skipped.
    *
    * @default []
    * @example excludeChunks: ['chunk-name-1', 'chunk-name-2']
    */
  var excludeChunks: js.UndefOr[js.Array[String]] = js.native
  
  /**
    * The base directory you wish to match `globPatterns` against, relative to the current working directory.
    *
    * If you do set this, make sure to also configure `globPatterns`.
    *
    * @default undefined
    * @example globDirectory: '.'
    */
  var globDirectory: js.UndefOr[String] = js.native
  
  /**
    * Determines whether or not symlinks are followed when generating the precache manifest.
    *
    * For more information, see the definition of `follow` in the `glob` [documentation](https://github.com/isaacs/node-glob#options).
    *
    * @default true
    * @example globFollow: false
    */
  var globFollow: js.UndefOr[Boolean] = js.native
  
  /**
    * A set of patterns matching files to always exclude when generating the precache manifest.
    *
    * For more information, see the definition of `ignore` in the `glob` [documentation](https://github.com/isaacs/node-glob#options).
    *
    * @default ['node_modules/ **\/ *']
    * @example globIgnores: ['**\/ignored.html']
    */
  var globIgnores: js.UndefOr[js.Array[String]] = js.native
  
  /**
    * Files matching against any of these patterns will be included in the precache manifest.
    *
    * For more information, see the [glob primer](https://github.com/isaacs/node-glob#glob-primer).
    *
    * Note: Setting `globPatterns` is often unnecessary when using the `workbox-webpack-plugin`, which will automatically precache files that are part of the webpack build pipeline by default.
    * When using the webpack plugin, only set it when you need to cache
    * [non-webpack assets](https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin#cache_additional_non-webpack_assets).
    *
    * @default []
    * @example globPatterns: ['dist/ *.{js,png,html,css}']
    */
  var globPatterns: js.UndefOr[js.Array[String]] = js.native
  
  /**
    * If `true`, an error reading a directory when generating a precache manifest will cause the build to fail. If `false`, the problematic directory will be skipped.
    *
    * For more information, see the definition of `strict` in the `glob` [documentation](https://github.com/isaacs/node-glob#options).
    *
    * @default true
    * @example globStrict: false
    */
  var globStrict: js.UndefOr[Boolean] = js.native
  
  /**
    * One or more names of webpack chunks.
    * The content of those chunks will be included in the generated service worker, via a call to importScripts()
    */
  var importScriptsViaChunks: js.UndefOr[js.Array[String]] = js.native
  
  /**
    * Workbox creates assets as part of your webpack build process: a precache manifest file, and potentially a local copy of the Workbox libraries (if `importWorkboxFrom` is set to `'local'`).
    *
    * These assets will, by default, be created at the root of your webpack build directory, i.e. `output.path`. You can set the `importsDirectory` option if you want these assets to be created in
    * a subdirectory of `output.path` instead of at the top-level.
    *
    * Note: This option does not effect where the main service worker JavaScript file is created. That is determined by the `swDest` option.
    *
    * @default ''
    * @example importsDirectory: 'wb-assets'
    */
  var importsDirectory: js.UndefOr[String] = js.native
  
  /**
    * This allows you to only include assets matching any of the provided criteria when creating the precache manifest. It provides a filename-based approach to filtering.
    *
    * This filtering takes place after any chunk-based filtering is applied.
    *
    * In keeping with [webpack convention](https://webpack.js.org/configuration/module/#condition), the option `test` can be used as an alias/alternative to `include`.
    *
    * @default []
    * @example include: [/\.html$/, /\.js$/]
    * @alias test
    */
  var include: js.UndefOr[js.Array[String | js.RegExp]] = js.native
  
  /**
    * One or more [`ManifestTransform`](https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-build#.ManifestTransform)
    * functions, which will be applied sequentially against the generated manifest.
    *
    * If `modifyUrlPrefix` or `dontCacheBustUrlsMatching` are also specified, their corresponding transformations will be applied first.
    */
  var manifestTransforms: js.UndefOr[
    (js.Array[js.Function1[/* originalManifest */ js.Array[ManifestEntry], Manifest]]) | Null
  ] = js.native
  
  /**
    * This value can be used to determine the maximum size of files that will be precached. This prevents you from inadvertantly precaching very large files that might have
    * accidentally matched one of your patterns.
    *
    * @default 2097152
    * @example maximumFileSizeToCacheInBytes: 4 * 1024 * 1024
    */
  var maximumFileSizeToCacheInBytes: js.UndefOr[Double] = js.native
  
  /**
    * If set to 'production', then an optimized service worker bundle that excludes debugging info will be produced.
    * If not explicitly configured here, the mode value configured in the current webpack compilation will be used
    */
  var mode: js.UndefOr[production | String] = js.native
  
  /**
    * A mapping of prefixes that, if present in an entry in the precache manifest, will be replaced with the corresponding value.
    *
    * This can be used to, for example, remove or add a path prefix from a manifest entry if your web hosting setup doesn't match your local filesystem setup.
    *
    * As an alternative with more flexibility, you can use the `manifestTransforms` option and provide a function that modifies the entries in the manifest using whatever logic you provide.
    *
    * @default null
    * @example modifyUrlPrefix: { '/dist': '' }
    */
  var modifyUrlPrefix: js.UndefOr[StringDictionary[String] | Null] = js.native
  
  /**
    * Workbox automatically creates a JavaScript file that contains information about URLs that need to be precached. By default, this file is called `precache-manifest.[manifestHash].js`,
    * where `[manifestHash]` is automatically replaced by a unique value that identifies the contents of the file.
    *
    * `precacheManifestFilename` can be used to override this default filename. You must include the string `[manifestHash]` somewhere as part of the filename.
    *
    * If you'd like to change the output directory to which the precache manifest is written, you can configure the `importsDirectory` option.
    *
    * @default 'precache-manifest.[manifestHash].js'
    * @example precacheManifestFilename: 'wb-manifest.[manifestHash].js'
    */
  var precacheManifestFilename: js.UndefOr[String] = js.native
  
  /**
    * The path and filename of the service worker file that will be created by the build process, relative to the webpack output directory.
    *
    * @default 'service-worker.js'
    * @example swDest: 'custom-sw-name.js'
    */
  var swDest: js.UndefOr[String] = js.native
  
  /**
    * If a URL is rendered generated based on some server-side logic, its contents may depend on multiple files or on some other unique string value.
    *
    * If used with an array of strings, they will be interpreted as glob patterns, and the contents of any files matching the patterns will be used to uniquely version the URL.
    *
    * If used with a single string, it will be interpreted as unique versioning information that you've generated out of band for a given URL.
    *
    * @default null
    */
  var templatedUrls: js.UndefOr[(StringDictionary[String | js.Array[String]]) | Null] = js.native
  
  var test: js.UndefOr[js.Array[String | js.RegExp]] = js.native
}
object CommonOptions {
  
  @scala.inline
  def apply(): CommonOptions = {
    val __obj = js.Dynamic.literal()
    __obj.asInstanceOf[CommonOptions]
  }
  
  @scala.inline
  implicit class CommonOptionsOps[Self <: CommonOptions] (val x: Self) extends AnyVal {
    
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    
    @scala.inline
    def set(key: String, value: js.Any): Self = {
      x.asInstanceOf[js.Dynamic].updateDynamic(key)(value)
      x
    }
    
    @scala.inline
    def setAdditionalManifestEntriesVarargs(value: (Integrity | String)*): Self = this.set("additionalManifestEntries", js.Array(value :_*))
    
    @scala.inline
    def setAdditionalManifestEntries(value: js.Array[Integrity | String]): Self = this.set("additionalManifestEntries", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteAdditionalManifestEntries: Self = this.set("additionalManifestEntries", js.undefined)
    
    @scala.inline
    def setChunksVarargs(value: String*): Self = this.set("chunks", js.Array(value :_*))
    
    @scala.inline
    def setChunks(value: js.Array[String]): Self = this.set("chunks", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteChunks: Self = this.set("chunks", js.undefined)
    
    @scala.inline
    def setDontCacheBustUrlsMatching(value: js.RegExp): Self = this.set("dontCacheBustUrlsMatching", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteDontCacheBustUrlsMatching: Self = this.set("dontCacheBustUrlsMatching", js.undefined)
    
    @scala.inline
    def setDontCacheBustUrlsMatchingNull: Self = this.set("dontCacheBustUrlsMatching", null)
    
    @scala.inline
    def setExcludeVarargs(value: (String | js.RegExp)*): Self = this.set("exclude", js.Array(value :_*))
    
    @scala.inline
    def setExclude(value: js.Array[String | js.RegExp]): Self = this.set("exclude", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteExclude: Self = this.set("exclude", js.undefined)
    
    @scala.inline
    def setExcludeChunksVarargs(value: String*): Self = this.set("excludeChunks", js.Array(value :_*))
    
    @scala.inline
    def setExcludeChunks(value: js.Array[String]): Self = this.set("excludeChunks", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteExcludeChunks: Self = this.set("excludeChunks", js.undefined)
    
    @scala.inline
    def setGlobDirectory(value: String): Self = this.set("globDirectory", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteGlobDirectory: Self = this.set("globDirectory", js.undefined)
    
    @scala.inline
    def setGlobFollow(value: Boolean): Self = this.set("globFollow", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteGlobFollow: Self = this.set("globFollow", js.undefined)
    
    @scala.inline
    def setGlobIgnoresVarargs(value: String*): Self = this.set("globIgnores", js.Array(value :_*))
    
    @scala.inline
    def setGlobIgnores(value: js.Array[String]): Self = this.set("globIgnores", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteGlobIgnores: Self = this.set("globIgnores", js.undefined)
    
    @scala.inline
    def setGlobPatternsVarargs(value: String*): Self = this.set("globPatterns", js.Array(value :_*))
    
    @scala.inline
    def setGlobPatterns(value: js.Array[String]): Self = this.set("globPatterns", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteGlobPatterns: Self = this.set("globPatterns", js.undefined)
    
    @scala.inline
    def setGlobStrict(value: Boolean): Self = this.set("globStrict", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteGlobStrict: Self = this.set("globStrict", js.undefined)
    
    @scala.inline
    def setImportScriptsViaChunksVarargs(value: String*): Self = this.set("importScriptsViaChunks", js.Array(value :_*))
    
    @scala.inline
    def setImportScriptsViaChunks(value: js.Array[String]): Self = this.set("importScriptsViaChunks", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteImportScriptsViaChunks: Self = this.set("importScriptsViaChunks", js.undefined)
    
    @scala.inline
    def setImportsDirectory(value: String): Self = this.set("importsDirectory", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteImportsDirectory: Self = this.set("importsDirectory", js.undefined)
    
    @scala.inline
    def setIncludeVarargs(value: (String | js.RegExp)*): Self = this.set("include", js.Array(value :_*))
    
    @scala.inline
    def setInclude(value: js.Array[String | js.RegExp]): Self = this.set("include", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteInclude: Self = this.set("include", js.undefined)
    
    @scala.inline
    def setManifestTransformsVarargs(value: (js.Function1[/* originalManifest */ js.Array[ManifestEntry], Manifest])*): Self = this.set("manifestTransforms", js.Array(value :_*))
    
    @scala.inline
    def setManifestTransforms(value: js.Array[js.Function1[/* originalManifest */ js.Array[ManifestEntry], Manifest]]): Self = this.set("manifestTransforms", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteManifestTransforms: Self = this.set("manifestTransforms", js.undefined)
    
    @scala.inline
    def setManifestTransformsNull: Self = this.set("manifestTransforms", null)
    
    @scala.inline
    def setMaximumFileSizeToCacheInBytes(value: Double): Self = this.set("maximumFileSizeToCacheInBytes", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteMaximumFileSizeToCacheInBytes: Self = this.set("maximumFileSizeToCacheInBytes", js.undefined)
    
    @scala.inline
    def setMode(value: production | String): Self = this.set("mode", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteMode: Self = this.set("mode", js.undefined)
    
    @scala.inline
    def setModifyUrlPrefix(value: StringDictionary[String]): Self = this.set("modifyUrlPrefix", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteModifyUrlPrefix: Self = this.set("modifyUrlPrefix", js.undefined)
    
    @scala.inline
    def setModifyUrlPrefixNull: Self = this.set("modifyUrlPrefix", null)
    
    @scala.inline
    def setPrecacheManifestFilename(value: String): Self = this.set("precacheManifestFilename", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deletePrecacheManifestFilename: Self = this.set("precacheManifestFilename", js.undefined)
    
    @scala.inline
    def setSwDest(value: String): Self = this.set("swDest", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteSwDest: Self = this.set("swDest", js.undefined)
    
    @scala.inline
    def setTemplatedUrls(value: StringDictionary[String | js.Array[String]]): Self = this.set("templatedUrls", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteTemplatedUrls: Self = this.set("templatedUrls", js.undefined)
    
    @scala.inline
    def setTemplatedUrlsNull: Self = this.set("templatedUrls", null)
    
    @scala.inline
    def setTestVarargs(value: (String | js.RegExp)*): Self = this.set("test", js.Array(value :_*))
    
    @scala.inline
    def setTest(value: js.Array[String | js.RegExp]): Self = this.set("test", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteTest: Self = this.set("test", js.undefined)
  }
}
