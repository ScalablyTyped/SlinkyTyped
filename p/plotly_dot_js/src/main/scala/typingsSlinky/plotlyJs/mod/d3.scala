package typingsSlinky.plotlyJs.mod

import org.scalablytyped.runtime.Instantiable0
import org.scalablytyped.runtime.Instantiable1
import org.scalablytyped.runtime.NumberDictionary
import org.scalablytyped.runtime.StringDictionary
import org.scalablytyped.runtime.TopLevel
import org.scalajs.dom.experimental.RequestInit
import org.scalajs.dom.raw.Blob
import org.scalajs.dom.raw.CanvasRenderingContext2D
import org.scalajs.dom.raw.Document
import org.scalajs.dom.raw.Element
import org.scalajs.dom.raw.HTMLAnchorElement
import org.scalajs.dom.raw.HTMLAreaElement
import org.scalajs.dom.raw.HTMLAudioElement
import org.scalajs.dom.raw.HTMLBRElement
import org.scalajs.dom.raw.HTMLBaseElement
import org.scalajs.dom.raw.HTMLBodyElement
import org.scalajs.dom.raw.HTMLButtonElement
import org.scalajs.dom.raw.HTMLCanvasElement
import org.scalajs.dom.raw.HTMLDListElement
import org.scalajs.dom.raw.HTMLDataListElement
import org.scalajs.dom.raw.HTMLDivElement
import org.scalajs.dom.raw.HTMLElement
import org.scalajs.dom.raw.HTMLEmbedElement
import org.scalajs.dom.raw.HTMLFieldSetElement
import org.scalajs.dom.raw.HTMLFormElement
import org.scalajs.dom.raw.HTMLHRElement
import org.scalajs.dom.raw.HTMLHeadElement
import org.scalajs.dom.raw.HTMLHeadingElement
import org.scalajs.dom.raw.HTMLHtmlElement
import org.scalajs.dom.raw.HTMLIFrameElement
import org.scalajs.dom.raw.HTMLImageElement
import org.scalajs.dom.raw.HTMLInputElement
import org.scalajs.dom.raw.HTMLLIElement
import org.scalajs.dom.raw.HTMLLabelElement
import org.scalajs.dom.raw.HTMLLegendElement
import org.scalajs.dom.raw.HTMLLinkElement
import org.scalajs.dom.raw.HTMLMapElement
import org.scalajs.dom.raw.HTMLMenuElement
import org.scalajs.dom.raw.HTMLMetaElement
import org.scalajs.dom.raw.HTMLModElement
import org.scalajs.dom.raw.HTMLOListElement
import org.scalajs.dom.raw.HTMLObjectElement
import org.scalajs.dom.raw.HTMLOptGroupElement
import org.scalajs.dom.raw.HTMLOptionElement
import org.scalajs.dom.raw.HTMLParagraphElement
import org.scalajs.dom.raw.HTMLParamElement
import org.scalajs.dom.raw.HTMLPreElement
import org.scalajs.dom.raw.HTMLProgressElement
import org.scalajs.dom.raw.HTMLQuoteElement
import org.scalajs.dom.raw.HTMLScriptElement
import org.scalajs.dom.raw.HTMLSelectElement
import org.scalajs.dom.raw.HTMLSourceElement
import org.scalajs.dom.raw.HTMLSpanElement
import org.scalajs.dom.raw.HTMLStyleElement
import org.scalajs.dom.raw.HTMLTableCaptionElement
import org.scalajs.dom.raw.HTMLTableColElement
import org.scalajs.dom.raw.HTMLTableElement
import org.scalajs.dom.raw.HTMLTableRowElement
import org.scalajs.dom.raw.HTMLTableSectionElement
import org.scalajs.dom.raw.HTMLTextAreaElement
import org.scalajs.dom.raw.HTMLTitleElement
import org.scalajs.dom.raw.HTMLTrackElement
import org.scalajs.dom.raw.HTMLUListElement
import org.scalajs.dom.raw.HTMLVideoElement
import org.scalajs.dom.raw.Node
import org.scalajs.dom.raw.NodeListOf
import org.scalajs.dom.raw.SVGCircleElement
import org.scalajs.dom.raw.SVGClipPathElement
import org.scalajs.dom.raw.SVGDefsElement
import org.scalajs.dom.raw.SVGDescElement
import org.scalajs.dom.raw.SVGEllipseElement
import org.scalajs.dom.raw.SVGFEBlendElement
import org.scalajs.dom.raw.SVGFEColorMatrixElement
import org.scalajs.dom.raw.SVGFEComponentTransferElement
import org.scalajs.dom.raw.SVGFECompositeElement
import org.scalajs.dom.raw.SVGFEConvolveMatrixElement
import org.scalajs.dom.raw.SVGFEDiffuseLightingElement
import org.scalajs.dom.raw.SVGFEDisplacementMapElement
import org.scalajs.dom.raw.SVGFEDistantLightElement
import org.scalajs.dom.raw.SVGFEFloodElement
import org.scalajs.dom.raw.SVGFEFuncAElement
import org.scalajs.dom.raw.SVGFEFuncBElement
import org.scalajs.dom.raw.SVGFEFuncGElement
import org.scalajs.dom.raw.SVGFEFuncRElement
import org.scalajs.dom.raw.SVGFEGaussianBlurElement
import org.scalajs.dom.raw.SVGFEImageElement
import org.scalajs.dom.raw.SVGFEMergeElement
import org.scalajs.dom.raw.SVGFEMergeNodeElement
import org.scalajs.dom.raw.SVGFEMorphologyElement
import org.scalajs.dom.raw.SVGFEOffsetElement
import org.scalajs.dom.raw.SVGFEPointLightElement
import org.scalajs.dom.raw.SVGFESpecularLightingElement
import org.scalajs.dom.raw.SVGFESpotLightElement
import org.scalajs.dom.raw.SVGFETileElement
import org.scalajs.dom.raw.SVGFETurbulenceElement
import org.scalajs.dom.raw.SVGFilterElement
import org.scalajs.dom.raw.SVGGElement
import org.scalajs.dom.raw.SVGImageElement
import org.scalajs.dom.raw.SVGLineElement
import org.scalajs.dom.raw.SVGLinearGradientElement
import org.scalajs.dom.raw.SVGMarkerElement
import org.scalajs.dom.raw.SVGMaskElement
import org.scalajs.dom.raw.SVGMetadataElement
import org.scalajs.dom.raw.SVGPathElement
import org.scalajs.dom.raw.SVGPatternElement
import org.scalajs.dom.raw.SVGPolygonElement
import org.scalajs.dom.raw.SVGPolylineElement
import org.scalajs.dom.raw.SVGRadialGradientElement
import org.scalajs.dom.raw.SVGRectElement
import org.scalajs.dom.raw.SVGSVGElement
import org.scalajs.dom.raw.SVGStopElement
import org.scalajs.dom.raw.SVGSwitchElement
import org.scalajs.dom.raw.SVGSymbolElement
import org.scalajs.dom.raw.SVGTSpanElement
import org.scalajs.dom.raw.SVGTextElement
import org.scalajs.dom.raw.SVGTextPathElement
import org.scalajs.dom.raw.SVGUseElement
import org.scalajs.dom.raw.SVGViewElement
import org.scalajs.dom.raw.Window
import typingsSlinky.d3Array.anon.FnCall
import typingsSlinky.d3Array.mod.Bisector_
import typingsSlinky.d3Array.mod.HistogramGeneratorDate
import typingsSlinky.d3Array.mod.HistogramGeneratorNumber
import typingsSlinky.d3Array.mod.Numeric
import typingsSlinky.d3Array.mod.Primitive
import typingsSlinky.d3Axis.mod.AxisDomain
import typingsSlinky.d3Axis.mod.AxisScale
import typingsSlinky.d3Brush.mod.BrushBehavior
import typingsSlinky.d3Brush.mod.BrushSelection_
import typingsSlinky.d3Chord.mod.ChordLayout
import typingsSlinky.d3Chord.mod.RibbonGenerator
import typingsSlinky.d3Chord.mod.RibbonSubgroup
import typingsSlinky.d3Chord.mod.Ribbon_
import typingsSlinky.d3Color.mod.ColorCommonInstance
import typingsSlinky.d3Color.mod.ColorFactory
import typingsSlinky.d3Color.mod.ColorSpaceObject
import typingsSlinky.d3Color.mod.CubehelixColor
import typingsSlinky.d3Color.mod.CubehelixColorFactory
import typingsSlinky.d3Color.mod.HCLColor
import typingsSlinky.d3Color.mod.HCLColorFactory
import typingsSlinky.d3Color.mod.HSLColor
import typingsSlinky.d3Color.mod.HSLColorFactory
import typingsSlinky.d3Color.mod.LabColor
import typingsSlinky.d3Color.mod.LabColorFactory
import typingsSlinky.d3Color.mod.RGBColor
import typingsSlinky.d3Color.mod.RGBColorFactory
import typingsSlinky.d3Contour.mod.ContourDensity_
import typingsSlinky.d3Contour.mod.Contours_
import typingsSlinky.d3Dispatch.mod.Dispatch_
import typingsSlinky.d3Drag.mod.DragBehavior
import typingsSlinky.d3Drag.mod.SubjectPosition
import typingsSlinky.d3Dsv.mod.DSV
import typingsSlinky.d3Dsv.mod.DSVParsedArray
import typingsSlinky.d3Dsv.mod.DSVRowArray
import typingsSlinky.d3Dsv.mod.DSVRowString
import typingsSlinky.d3Ease.mod.BackEasingFactory
import typingsSlinky.d3Ease.mod.ElasticEasingFactory
import typingsSlinky.d3Ease.mod.PolynomialEasingFactory
import typingsSlinky.d3Fetch.anon.PartialHTMLImageElement
import typingsSlinky.d3Force.mod.ForceCenter_
import typingsSlinky.d3Force.mod.ForceCollide_
import typingsSlinky.d3Force.mod.ForceLink_
import typingsSlinky.d3Force.mod.ForceManyBody_
import typingsSlinky.d3Force.mod.ForceRadial_
import typingsSlinky.d3Force.mod.ForceX_
import typingsSlinky.d3Force.mod.ForceY_
import typingsSlinky.d3Force.mod.Simulation
import typingsSlinky.d3Force.mod.SimulationLinkDatum
import typingsSlinky.d3Force.mod.SimulationNodeDatum
import typingsSlinky.d3Format.anon.ValueOf
import typingsSlinky.d3Format.mod.FormatLocaleDefinition
import typingsSlinky.d3Format.mod.FormatLocaleObject
import typingsSlinky.d3Format.mod.FormatSpecifierObject
import typingsSlinky.d3Format.mod.FormatSpecifier_
import typingsSlinky.d3Geo.anon.`0`
import typingsSlinky.d3Geo.mod.ExtendedFeature
import typingsSlinky.d3Geo.mod.ExtendedFeatureCollection
import typingsSlinky.d3Geo.mod.ExtendedGeometryCollection
import typingsSlinky.d3Geo.mod.GeoCircleGenerator
import typingsSlinky.d3Geo.mod.GeoConicProjection
import typingsSlinky.d3Geo.mod.GeoContext
import typingsSlinky.d3Geo.mod.GeoGeometryObjects
import typingsSlinky.d3Geo.mod.GeoGraticuleGenerator
import typingsSlinky.d3Geo.mod.GeoIdentityTransform
import typingsSlinky.d3Geo.mod.GeoPath_
import typingsSlinky.d3Geo.mod.GeoPermissibleObjects
import typingsSlinky.d3Geo.mod.GeoProjection_
import typingsSlinky.d3Geo.mod.GeoRawProjection
import typingsSlinky.d3Geo.mod.GeoRotation_
import typingsSlinky.d3Geo.mod.GeoStreamWrapper
import typingsSlinky.d3Geo.mod.GeoStream_
import typingsSlinky.d3Geo.mod.GeoTransformPrototype
import typingsSlinky.d3Hierarchy.mod.ClusterLayout
import typingsSlinky.d3Hierarchy.mod.HierarchyNode
import typingsSlinky.d3Hierarchy.mod.HierarchyRectangularNode
import typingsSlinky.d3Hierarchy.mod.PackCircle
import typingsSlinky.d3Hierarchy.mod.PackLayout
import typingsSlinky.d3Hierarchy.mod.PackRadius
import typingsSlinky.d3Hierarchy.mod.PartitionLayout
import typingsSlinky.d3Hierarchy.mod.RatioSquarifyTilingFactory
import typingsSlinky.d3Hierarchy.mod.StratifyOperator
import typingsSlinky.d3Hierarchy.mod.TreeLayout
import typingsSlinky.d3Hierarchy.mod.TreemapLayout
import typingsSlinky.d3Interpolate.anon.ToString
import typingsSlinky.d3Interpolate.mod.ArrayInterpolator
import typingsSlinky.d3Interpolate.mod.ColorGammaInterpolationFactory
import typingsSlinky.d3Interpolate.mod.NumberArray
import typingsSlinky.d3Interpolate.mod.ZoomInterpolator
import typingsSlinky.d3Interpolate.mod.ZoomView
import typingsSlinky.d3Path.mod.Path_
import typingsSlinky.d3Quadtree.mod.Quadtree_
import typingsSlinky.d3Random.mod.RandomBates_
import typingsSlinky.d3Random.mod.RandomBernoulli_
import typingsSlinky.d3Random.mod.RandomBeta_
import typingsSlinky.d3Random.mod.RandomBinomial_
import typingsSlinky.d3Random.mod.RandomCauchy_
import typingsSlinky.d3Random.mod.RandomExponential_
import typingsSlinky.d3Random.mod.RandomGamma_
import typingsSlinky.d3Random.mod.RandomGeometric_
import typingsSlinky.d3Random.mod.RandomInt_
import typingsSlinky.d3Random.mod.RandomIrwinHall_
import typingsSlinky.d3Random.mod.RandomLogNormal_
import typingsSlinky.d3Random.mod.RandomLogistic_
import typingsSlinky.d3Random.mod.RandomNormal_
import typingsSlinky.d3Random.mod.RandomPareto_
import typingsSlinky.d3Random.mod.RandomPoisson_
import typingsSlinky.d3Random.mod.RandomUniform_
import typingsSlinky.d3Random.mod.RandomWeibull_
import typingsSlinky.d3Scale.mod.NumberValue
import typingsSlinky.d3Scale.mod.ScaleBand_
import typingsSlinky.d3Scale.mod.ScaleDiverging_
import typingsSlinky.d3Scale.mod.ScaleIdentity_
import typingsSlinky.d3Scale.mod.ScaleLinear_
import typingsSlinky.d3Scale.mod.ScaleLogarithmic
import typingsSlinky.d3Scale.mod.ScaleOrdinal_
import typingsSlinky.d3Scale.mod.ScalePoint_
import typingsSlinky.d3Scale.mod.ScalePower
import typingsSlinky.d3Scale.mod.ScaleQuantile_
import typingsSlinky.d3Scale.mod.ScaleQuantize_
import typingsSlinky.d3Scale.mod.ScaleRadial_
import typingsSlinky.d3Scale.mod.ScaleSequentialQuantile_
import typingsSlinky.d3Scale.mod.ScaleSequential_
import typingsSlinky.d3Scale.mod.ScaleSymLog_
import typingsSlinky.d3Scale.mod.ScaleThreshold_
import typingsSlinky.d3Scale.mod.ScaleTime_
import typingsSlinky.d3Selection.mod.BaseType
import typingsSlinky.d3Selection.mod.EnterElement
import typingsSlinky.d3Selection.mod.Local_
import typingsSlinky.d3Selection.mod.NamespaceLocalObject
import typingsSlinky.d3Selection.mod.NamespaceMap
import typingsSlinky.d3Selection.mod.Selection_
import typingsSlinky.d3Shape.mod.Arc_
import typingsSlinky.d3Shape.mod.AreaRadial_
import typingsSlinky.d3Shape.mod.Area_
import typingsSlinky.d3Shape.mod.CurveBundleFactory
import typingsSlinky.d3Shape.mod.CurveCardinalFactory
import typingsSlinky.d3Shape.mod.CurveCatmullRomFactory
import typingsSlinky.d3Shape.mod.CurveGenerator
import typingsSlinky.d3Shape.mod.DefaultArcObject
import typingsSlinky.d3Shape.mod.DefaultLinkObject
import typingsSlinky.d3Shape.mod.LineRadial_
import typingsSlinky.d3Shape.mod.Line_
import typingsSlinky.d3Shape.mod.Link
import typingsSlinky.d3Shape.mod.LinkRadial_
import typingsSlinky.d3Shape.mod.Pie_
import typingsSlinky.d3Shape.mod.RadialArea_
import typingsSlinky.d3Shape.mod.RadialLine_
import typingsSlinky.d3Shape.mod.Series
import typingsSlinky.d3Shape.mod.Stack_
import typingsSlinky.d3Shape.mod.SymbolType
import typingsSlinky.d3Shape.mod.Symbol_
import typingsSlinky.d3Time.mod.CountableTimeInterval
import typingsSlinky.d3Time.mod.TimeInterval_
import typingsSlinky.d3TimeFormat.mod.TimeLocaleDefinition
import typingsSlinky.d3TimeFormat.mod.TimeLocaleObject
import typingsSlinky.d3Timer.mod.Timer_
import typingsSlinky.d3Transition.mod.Transition_
import typingsSlinky.d3Zoom.mod.ZoomBehavior
import typingsSlinky.d3Zoom.mod.ZoomTransform_
import typingsSlinky.geojson.mod.GeoJsonProperties
import typingsSlinky.geojson.mod.MultiLineString
import typingsSlinky.plotlyJs.anon.Name
import typingsSlinky.plotlyJs.anon.TypeofDelaunay
import typingsSlinky.plotlyJs.plotlyJsStrings.`object`
import typingsSlinky.plotlyJs.plotlyJsStrings.`var`
import typingsSlinky.plotlyJs.plotlyJsStrings.a
import typingsSlinky.plotlyJs.plotlyJsStrings.abbr
import typingsSlinky.plotlyJs.plotlyJsStrings.address
import typingsSlinky.plotlyJs.plotlyJsStrings.applet
import typingsSlinky.plotlyJs.plotlyJsStrings.area
import typingsSlinky.plotlyJs.plotlyJsStrings.article
import typingsSlinky.plotlyJs.plotlyJsStrings.aside
import typingsSlinky.plotlyJs.plotlyJsStrings.audio
import typingsSlinky.plotlyJs.plotlyJsStrings.b_
import typingsSlinky.plotlyJs.plotlyJsStrings.base
import typingsSlinky.plotlyJs.plotlyJsStrings.basefont
import typingsSlinky.plotlyJs.plotlyJsStrings.bdi
import typingsSlinky.plotlyJs.plotlyJsStrings.bdo
import typingsSlinky.plotlyJs.plotlyJsStrings.blockquote
import typingsSlinky.plotlyJs.plotlyJsStrings.body
import typingsSlinky.plotlyJs.plotlyJsStrings.br
import typingsSlinky.plotlyJs.plotlyJsStrings.button
import typingsSlinky.plotlyJs.plotlyJsStrings.canvas
import typingsSlinky.plotlyJs.plotlyJsStrings.caption
import typingsSlinky.plotlyJs.plotlyJsStrings.circle
import typingsSlinky.plotlyJs.plotlyJsStrings.cite
import typingsSlinky.plotlyJs.plotlyJsStrings.clipPath
import typingsSlinky.plotlyJs.plotlyJsStrings.code
import typingsSlinky.plotlyJs.plotlyJsStrings.col
import typingsSlinky.plotlyJs.plotlyJsStrings.colgroup
import typingsSlinky.plotlyJs.plotlyJsStrings.data
import typingsSlinky.plotlyJs.plotlyJsStrings.datalist
import typingsSlinky.plotlyJs.plotlyJsStrings.dd
import typingsSlinky.plotlyJs.plotlyJsStrings.defs
import typingsSlinky.plotlyJs.plotlyJsStrings.del
import typingsSlinky.plotlyJs.plotlyJsStrings.desc
import typingsSlinky.plotlyJs.plotlyJsStrings.details
import typingsSlinky.plotlyJs.plotlyJsStrings.dfn
import typingsSlinky.plotlyJs.plotlyJsStrings.dialog
import typingsSlinky.plotlyJs.plotlyJsStrings.dir
import typingsSlinky.plotlyJs.plotlyJsStrings.div
import typingsSlinky.plotlyJs.plotlyJsStrings.dl
import typingsSlinky.plotlyJs.plotlyJsStrings.dt
import typingsSlinky.plotlyJs.plotlyJsStrings.ellipse
import typingsSlinky.plotlyJs.plotlyJsStrings.em
import typingsSlinky.plotlyJs.plotlyJsStrings.embed
import typingsSlinky.plotlyJs.plotlyJsStrings.feBlend
import typingsSlinky.plotlyJs.plotlyJsStrings.feColorMatrix
import typingsSlinky.plotlyJs.plotlyJsStrings.feComponentTransfer
import typingsSlinky.plotlyJs.plotlyJsStrings.feComposite
import typingsSlinky.plotlyJs.plotlyJsStrings.feConvolveMatrix
import typingsSlinky.plotlyJs.plotlyJsStrings.feDiffuseLighting
import typingsSlinky.plotlyJs.plotlyJsStrings.feDisplacementMap
import typingsSlinky.plotlyJs.plotlyJsStrings.feDistantLight
import typingsSlinky.plotlyJs.plotlyJsStrings.feFlood
import typingsSlinky.plotlyJs.plotlyJsStrings.feFuncA
import typingsSlinky.plotlyJs.plotlyJsStrings.feFuncB
import typingsSlinky.plotlyJs.plotlyJsStrings.feFuncG
import typingsSlinky.plotlyJs.plotlyJsStrings.feFuncR
import typingsSlinky.plotlyJs.plotlyJsStrings.feGaussianBlur
import typingsSlinky.plotlyJs.plotlyJsStrings.feImage
import typingsSlinky.plotlyJs.plotlyJsStrings.feMerge
import typingsSlinky.plotlyJs.plotlyJsStrings.feMergeNode
import typingsSlinky.plotlyJs.plotlyJsStrings.feMorphology
import typingsSlinky.plotlyJs.plotlyJsStrings.feOffset
import typingsSlinky.plotlyJs.plotlyJsStrings.fePointLight
import typingsSlinky.plotlyJs.plotlyJsStrings.feSpecularLighting
import typingsSlinky.plotlyJs.plotlyJsStrings.feSpotLight
import typingsSlinky.plotlyJs.plotlyJsStrings.feTile
import typingsSlinky.plotlyJs.plotlyJsStrings.feTurbulence
import typingsSlinky.plotlyJs.plotlyJsStrings.fieldset
import typingsSlinky.plotlyJs.plotlyJsStrings.figcaption
import typingsSlinky.plotlyJs.plotlyJsStrings.figure
import typingsSlinky.plotlyJs.plotlyJsStrings.filter
import typingsSlinky.plotlyJs.plotlyJsStrings.font
import typingsSlinky.plotlyJs.plotlyJsStrings.footer
import typingsSlinky.plotlyJs.plotlyJsStrings.foreignObject
import typingsSlinky.plotlyJs.plotlyJsStrings.form
import typingsSlinky.plotlyJs.plotlyJsStrings.frame
import typingsSlinky.plotlyJs.plotlyJsStrings.frameset
import typingsSlinky.plotlyJs.plotlyJsStrings.g
import typingsSlinky.plotlyJs.plotlyJsStrings.h1
import typingsSlinky.plotlyJs.plotlyJsStrings.h2
import typingsSlinky.plotlyJs.plotlyJsStrings.h3
import typingsSlinky.plotlyJs.plotlyJsStrings.h4
import typingsSlinky.plotlyJs.plotlyJsStrings.h5
import typingsSlinky.plotlyJs.plotlyJsStrings.h6
import typingsSlinky.plotlyJs.plotlyJsStrings.head
import typingsSlinky.plotlyJs.plotlyJsStrings.header
import typingsSlinky.plotlyJs.plotlyJsStrings.hgroup
import typingsSlinky.plotlyJs.plotlyJsStrings.hr
import typingsSlinky.plotlyJs.plotlyJsStrings.html
import typingsSlinky.plotlyJs.plotlyJsStrings.i
import typingsSlinky.plotlyJs.plotlyJsStrings.iframe
import typingsSlinky.plotlyJs.plotlyJsStrings.image
import typingsSlinky.plotlyJs.plotlyJsStrings.img
import typingsSlinky.plotlyJs.plotlyJsStrings.input
import typingsSlinky.plotlyJs.plotlyJsStrings.ins
import typingsSlinky.plotlyJs.plotlyJsStrings.kbd
import typingsSlinky.plotlyJs.plotlyJsStrings.label
import typingsSlinky.plotlyJs.plotlyJsStrings.legend
import typingsSlinky.plotlyJs.plotlyJsStrings.li
import typingsSlinky.plotlyJs.plotlyJsStrings.line
import typingsSlinky.plotlyJs.plotlyJsStrings.linearGradient
import typingsSlinky.plotlyJs.plotlyJsStrings.link
import typingsSlinky.plotlyJs.plotlyJsStrings.main
import typingsSlinky.plotlyJs.plotlyJsStrings.map
import typingsSlinky.plotlyJs.plotlyJsStrings.mark
import typingsSlinky.plotlyJs.plotlyJsStrings.marker
import typingsSlinky.plotlyJs.plotlyJsStrings.marquee
import typingsSlinky.plotlyJs.plotlyJsStrings.mask
import typingsSlinky.plotlyJs.plotlyJsStrings.menu
import typingsSlinky.plotlyJs.plotlyJsStrings.meta
import typingsSlinky.plotlyJs.plotlyJsStrings.metadata
import typingsSlinky.plotlyJs.plotlyJsStrings.meter
import typingsSlinky.plotlyJs.plotlyJsStrings.nav
import typingsSlinky.plotlyJs.plotlyJsStrings.noscript
import typingsSlinky.plotlyJs.plotlyJsStrings.ol
import typingsSlinky.plotlyJs.plotlyJsStrings.optgroup
import typingsSlinky.plotlyJs.plotlyJsStrings.option
import typingsSlinky.plotlyJs.plotlyJsStrings.output
import typingsSlinky.plotlyJs.plotlyJsStrings.p
import typingsSlinky.plotlyJs.plotlyJsStrings.param
import typingsSlinky.plotlyJs.plotlyJsStrings.path
import typingsSlinky.plotlyJs.plotlyJsStrings.pattern
import typingsSlinky.plotlyJs.plotlyJsStrings.picture
import typingsSlinky.plotlyJs.plotlyJsStrings.polygon
import typingsSlinky.plotlyJs.plotlyJsStrings.polyline
import typingsSlinky.plotlyJs.plotlyJsStrings.pre
import typingsSlinky.plotlyJs.plotlyJsStrings.progress
import typingsSlinky.plotlyJs.plotlyJsStrings.q
import typingsSlinky.plotlyJs.plotlyJsStrings.radialGradient
import typingsSlinky.plotlyJs.plotlyJsStrings.rect
import typingsSlinky.plotlyJs.plotlyJsStrings.rp
import typingsSlinky.plotlyJs.plotlyJsStrings.rt
import typingsSlinky.plotlyJs.plotlyJsStrings.ruby
import typingsSlinky.plotlyJs.plotlyJsStrings.s
import typingsSlinky.plotlyJs.plotlyJsStrings.samp
import typingsSlinky.plotlyJs.plotlyJsStrings.script
import typingsSlinky.plotlyJs.plotlyJsStrings.section
import typingsSlinky.plotlyJs.plotlyJsStrings.select
import typingsSlinky.plotlyJs.plotlyJsStrings.slot
import typingsSlinky.plotlyJs.plotlyJsStrings.small
import typingsSlinky.plotlyJs.plotlyJsStrings.source
import typingsSlinky.plotlyJs.plotlyJsStrings.span
import typingsSlinky.plotlyJs.plotlyJsStrings.stop
import typingsSlinky.plotlyJs.plotlyJsStrings.strong
import typingsSlinky.plotlyJs.plotlyJsStrings.style
import typingsSlinky.plotlyJs.plotlyJsStrings.sub
import typingsSlinky.plotlyJs.plotlyJsStrings.summary
import typingsSlinky.plotlyJs.plotlyJsStrings.sup
import typingsSlinky.plotlyJs.plotlyJsStrings.svg
import typingsSlinky.plotlyJs.plotlyJsStrings.switch
import typingsSlinky.plotlyJs.plotlyJsStrings.symbol
import typingsSlinky.plotlyJs.plotlyJsStrings.table
import typingsSlinky.plotlyJs.plotlyJsStrings.tbody
import typingsSlinky.plotlyJs.plotlyJsStrings.td
import typingsSlinky.plotlyJs.plotlyJsStrings.template
import typingsSlinky.plotlyJs.plotlyJsStrings.text
import typingsSlinky.plotlyJs.plotlyJsStrings.textPath
import typingsSlinky.plotlyJs.plotlyJsStrings.textarea
import typingsSlinky.plotlyJs.plotlyJsStrings.tfoot
import typingsSlinky.plotlyJs.plotlyJsStrings.th
import typingsSlinky.plotlyJs.plotlyJsStrings.thead
import typingsSlinky.plotlyJs.plotlyJsStrings.time
import typingsSlinky.plotlyJs.plotlyJsStrings.title
import typingsSlinky.plotlyJs.plotlyJsStrings.tr
import typingsSlinky.plotlyJs.plotlyJsStrings.track
import typingsSlinky.plotlyJs.plotlyJsStrings.tspan
import typingsSlinky.plotlyJs.plotlyJsStrings.u
import typingsSlinky.plotlyJs.plotlyJsStrings.ul
import typingsSlinky.plotlyJs.plotlyJsStrings.use
import typingsSlinky.plotlyJs.plotlyJsStrings.video
import typingsSlinky.plotlyJs.plotlyJsStrings.view
import typingsSlinky.plotlyJs.plotlyJsStrings.wbr
import typingsSlinky.std.ArrayLike
import typingsSlinky.std.HTMLAppletElement
import typingsSlinky.std.HTMLBaseFontElement
import typingsSlinky.std.HTMLDataElement
import typingsSlinky.std.HTMLDetailsElement
import typingsSlinky.std.HTMLDialogElement
import typingsSlinky.std.HTMLDirectoryElement
import typingsSlinky.std.HTMLFontElement
import typingsSlinky.std.HTMLFrameElement
import typingsSlinky.std.HTMLFrameSetElement
import typingsSlinky.std.HTMLMarqueeElement
import typingsSlinky.std.HTMLMeterElement
import typingsSlinky.std.HTMLOutputElement
import typingsSlinky.std.HTMLPictureElement
import typingsSlinky.std.HTMLSlotElement
import typingsSlinky.std.HTMLTableDataCellElement
import typingsSlinky.std.HTMLTableHeaderCellElement
import typingsSlinky.std.HTMLTemplateElement
import typingsSlinky.std.HTMLTimeElement
import typingsSlinky.std.Iterable
import typingsSlinky.std.Map
import typingsSlinky.std.SVGForeignObjectElement
import typingsSlinky.std.Set
import typingsSlinky.std.XMLDocument
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

@JSImport("plotly.js", "d3")
@js.native
object d3 extends js.Object {
  
  var Delaunay: js.Any | TypeofDelaunay = js.native
  
  def active[Datum, PElement /* <: BaseType */, PDatum](): (Transition_[Null, Datum, PElement, PDatum]) | Null = js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Null, name: String): (Transition_[Null, Datum, PElement, PDatum]) | Null = js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: EnterElement): (Transition_[EnterElement, Datum, PElement, PDatum]) | Null = js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: EnterElement, name: String): (Transition_[EnterElement, Datum, PElement, PDatum]) | Null = js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Document): (Transition_[Document, Datum, PElement, PDatum]) | Null = js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Document, name: String): (Transition_[Document, Datum, PElement, PDatum]) | Null = js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Element): (Transition_[Element, Datum, PElement, PDatum]) | Null = js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Element, name: String): (Transition_[Element, Datum, PElement, PDatum]) | Null = js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Window): (Transition_[Window, Datum, PElement, PDatum]) | Null = js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Window, name: String): (Transition_[Window, Datum, PElement, PDatum]) | Null = js.native
  
  def arc(): Arc_[_, DefaultArcObject] = js.native
  @JSName("arc")
  def arc_Datum[Datum](): Arc_[_, Datum] = js.native
  @JSName("arc")
  def arc_ThisDatum[This, Datum](): Arc_[This, Datum] = js.native
  
  def area[Datum](): Area_[Datum] = js.native
  def area[Datum](
    x: js.UndefOr[scala.Nothing],
    y0: js.UndefOr[scala.Nothing],
    y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  def area[Datum](x: js.UndefOr[scala.Nothing], y0: js.UndefOr[scala.Nothing], y1: Double): Area_[Datum] = js.native
  def area[Datum](
    x: js.UndefOr[scala.Nothing],
    y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  def area[Datum](
    x: js.UndefOr[scala.Nothing],
    y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  def area[Datum](
    x: js.UndefOr[scala.Nothing],
    y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y1: Double
  ): Area_[Datum] = js.native
  def area[Datum](x: js.UndefOr[scala.Nothing], y0: Double): Area_[Datum] = js.native
  def area[Datum](
    x: js.UndefOr[scala.Nothing],
    y0: Double,
    y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  def area[Datum](x: js.UndefOr[scala.Nothing], y0: Double, y1: Double): Area_[Datum] = js.native
  def area[Datum](x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]): Area_[Datum] = js.native
  def area[Datum](
    x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y0: js.UndefOr[scala.Nothing],
    y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  def area[Datum](
    x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y0: js.UndefOr[scala.Nothing],
    y1: Double
  ): Area_[Datum] = js.native
  def area[Datum](
    x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  def area[Datum](
    x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  def area[Datum](
    x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y1: Double
  ): Area_[Datum] = js.native
  def area[Datum](x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double], y0: Double): Area_[Datum] = js.native
  def area[Datum](
    x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y0: Double,
    y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  def area[Datum](
    x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y0: Double,
    y1: Double
  ): Area_[Datum] = js.native
  def area[Datum](x: Double): Area_[Datum] = js.native
  def area[Datum](
    x: Double,
    y0: js.UndefOr[scala.Nothing],
    y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  def area[Datum](x: Double, y0: js.UndefOr[scala.Nothing], y1: Double): Area_[Datum] = js.native
  def area[Datum](x: Double, y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]): Area_[Datum] = js.native
  def area[Datum](
    x: Double,
    y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  def area[Datum](
    x: Double,
    y0: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y1: Double
  ): Area_[Datum] = js.native
  def area[Datum](x: Double, y0: Double): Area_[Datum] = js.native
  def area[Datum](
    x: Double,
    y0: Double,
    y1: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Area_[Datum] = js.native
  def area[Datum](x: Double, y0: Double, y1: Double): Area_[Datum] = js.native
  
  def areaRadial(): AreaRadial_[js.Tuple2[Double, Double]] = js.native
  @JSName("areaRadial")
  def areaRadial_Datum[Datum](): AreaRadial_[Datum] = js.native
  
  def ascending(): Double = js.native
  def ascending(a: js.UndefOr[Primitive], b: Primitive): Double = js.native
  def ascending(a: Primitive): Double = js.native
  
  def autoType[ParsedRow /* <: js.UndefOr[js.Object | Null] */, Columns /* <: String */](// tslint:disable-next-line:no-unnecessary-generics
  `object`: js.Array[String]): ParsedRow = js.native
  def autoType[ParsedRow /* <: js.UndefOr[js.Object | Null] */, Columns /* <: String */](// tslint:disable-next-line:no-unnecessary-generics
  `object`: DSVRowString[Columns]): ParsedRow = js.native
  
  def axisBottom[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): typingsSlinky.d3Axis.mod.Axis[Domain] = js.native
  
  def axisLeft[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): typingsSlinky.d3Axis.mod.Axis[Domain] = js.native
  
  def axisRight[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): typingsSlinky.d3Axis.mod.Axis[Domain] = js.native
  
  def axisTop[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): typingsSlinky.d3Axis.mod.Axis[Domain] = js.native
  
  def bin(): HistogramGeneratorNumber[Double, Double] = js.native
  @JSName("bin")
  def `bin_DatumValue_UnionDate<undefined>_HistogramGeneratorDate`[Datum, Value /* <: js.UndefOr[js.Date] */](): HistogramGeneratorDate[Datum, Value] = js.native
  @JSName("bin")
  def `bin_DatumValue_UnionDouble<undefined>`[Datum, Value /* <: js.UndefOr[Double] */](): HistogramGeneratorNumber[Datum, Value] = js.native
  
  def bisect(array: ArrayLike[String], x: String): Double = js.native
  def bisect(array: ArrayLike[String], x: String, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  def bisect(array: ArrayLike[String], x: String, lo: Double): Double = js.native
  def bisect(array: ArrayLike[String], x: String, lo: Double, hi: Double): Double = js.native
  def bisect(array: ArrayLike[Double], x: Double): Double = js.native
  def bisect(array: ArrayLike[Double], x: Double, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  def bisect(array: ArrayLike[Double], x: Double, lo: Double): Double = js.native
  def bisect(array: ArrayLike[Double], x: Double, lo: Double, hi: Double): Double = js.native
  def bisect(array: ArrayLike[js.Date], x: js.Date): Double = js.native
  def bisect(array: ArrayLike[js.Date], x: js.Date, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  def bisect(array: ArrayLike[js.Date], x: js.Date, lo: Double): Double = js.native
  def bisect(array: ArrayLike[js.Date], x: js.Date, lo: Double, hi: Double): Double = js.native
  
  def bisectCenter(array: ArrayLike[String], x: String): Double = js.native
  def bisectCenter(array: ArrayLike[String], x: String, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  def bisectCenter(array: ArrayLike[String], x: String, lo: Double): Double = js.native
  def bisectCenter(array: ArrayLike[String], x: String, lo: Double, hi: Double): Double = js.native
  def bisectCenter(array: ArrayLike[Double], x: Double): Double = js.native
  def bisectCenter(array: ArrayLike[Double], x: Double, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  def bisectCenter(array: ArrayLike[Double], x: Double, lo: Double): Double = js.native
  def bisectCenter(array: ArrayLike[Double], x: Double, lo: Double, hi: Double): Double = js.native
  def bisectCenter(array: ArrayLike[js.Date], x: js.Date): Double = js.native
  def bisectCenter(array: ArrayLike[js.Date], x: js.Date, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  def bisectCenter(array: ArrayLike[js.Date], x: js.Date, lo: Double): Double = js.native
  def bisectCenter(array: ArrayLike[js.Date], x: js.Date, lo: Double, hi: Double): Double = js.native
  
  def bisectLeft(array: ArrayLike[String], x: String): Double = js.native
  def bisectLeft(array: ArrayLike[String], x: String, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  def bisectLeft(array: ArrayLike[String], x: String, lo: Double): Double = js.native
  def bisectLeft(array: ArrayLike[String], x: String, lo: Double, hi: Double): Double = js.native
  def bisectLeft(array: ArrayLike[Double], x: Double): Double = js.native
  def bisectLeft(array: ArrayLike[Double], x: Double, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  def bisectLeft(array: ArrayLike[Double], x: Double, lo: Double): Double = js.native
  def bisectLeft(array: ArrayLike[Double], x: Double, lo: Double, hi: Double): Double = js.native
  def bisectLeft(array: ArrayLike[js.Date], x: js.Date): Double = js.native
  def bisectLeft(array: ArrayLike[js.Date], x: js.Date, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  def bisectLeft(array: ArrayLike[js.Date], x: js.Date, lo: Double): Double = js.native
  def bisectLeft(array: ArrayLike[js.Date], x: js.Date, lo: Double, hi: Double): Double = js.native
  
  def bisectRight(array: ArrayLike[String], x: String): Double = js.native
  def bisectRight(array: ArrayLike[String], x: String, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  def bisectRight(array: ArrayLike[String], x: String, lo: Double): Double = js.native
  def bisectRight(array: ArrayLike[String], x: String, lo: Double, hi: Double): Double = js.native
  def bisectRight(array: ArrayLike[Double], x: Double): Double = js.native
  def bisectRight(array: ArrayLike[Double], x: Double, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  def bisectRight(array: ArrayLike[Double], x: Double, lo: Double): Double = js.native
  def bisectRight(array: ArrayLike[Double], x: Double, lo: Double, hi: Double): Double = js.native
  def bisectRight(array: ArrayLike[js.Date], x: js.Date): Double = js.native
  def bisectRight(array: ArrayLike[js.Date], x: js.Date, lo: js.UndefOr[scala.Nothing], hi: Double): Double = js.native
  def bisectRight(array: ArrayLike[js.Date], x: js.Date, lo: Double): Double = js.native
  def bisectRight(array: ArrayLike[js.Date], x: js.Date, lo: Double, hi: Double): Double = js.native
  
  def bisector[T, U](accessor: js.Function1[/* x */ T, U]): Bisector_[T, U] = js.native
  def bisector[T, U](comparator: js.Function2[/* a */ T, /* b */ U, Double]): Bisector_[T, U] = js.native
  
  def blob(url: String): js.Promise[Blob] = js.native
  def blob(url: String, init: RequestInit): js.Promise[Blob] = js.native
  
  def brush[Datum](): BrushBehavior[Datum] = js.native
  
  def brushSelection(node: SVGGElement): BrushSelection_ | Null = js.native
  
  def brushX[Datum](): BrushBehavior[Datum] = js.native
  
  def brushY[Datum](): BrushBehavior[Datum] = js.native
  
  def buffer(url: String): js.Promise[js.typedarray.ArrayBuffer] = js.native
  def buffer(url: String, init: RequestInit): js.Promise[js.typedarray.ArrayBuffer] = js.native
  
  def chord(): ChordLayout = js.native
  
  def chordDirected(): ChordLayout = js.native
  
  def chordTranspose(): ChordLayout = js.native
  
  def cluster[Datum](): ClusterLayout[Datum] = js.native
  
  def color(color: ColorCommonInstance): RGBColor | HSLColor = js.native
  /**
    * Converts the provided color instance and returns an RGB or HSL color.
    *
    * @param color A permissible color space instance.
    */
  def color(color: ColorSpaceObject): RGBColor | HSLColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning an RGB or HSL color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
    */
  def color(cssColorSpecifier: String): RGBColor | HSLColor | Null = js.native
  @JSName("color")
  val color_Original: ColorFactory = js.native
  
  def contourDensity[Datum](): ContourDensity_[Datum] = js.native
  
  def contours(): Contours_ = js.native
  
  def count[TObject](iterable: js.Iterable[TObject]): Double = js.native
  def count[TObject](
    iterable: js.Iterable[TObject],
    accessor: js.Function2[/* a */ TObject, /* b */ TObject, js.UndefOr[Double | Null]]
  ): Double = js.native
  
  def create[NewGElement /* <: Element */](name: String): Selection_[NewGElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_a(name: a): Selection_[HTMLAnchorElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_abbr(name: abbr): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_address(name: address): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_applet(name: applet): Selection_[HTMLAppletElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_area(name: area): Selection_[HTMLAreaElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_article(name: article): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_aside(name: aside): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_audio(name: audio): Selection_[HTMLAudioElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_b(name: b_): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_base(name: base): Selection_[HTMLBaseElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_basefont(name: basefont): Selection_[HTMLBaseFontElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_bdi(name: bdi): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_bdo(name: bdo): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_blockquote(name: blockquote): Selection_[HTMLQuoteElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_body(name: body): Selection_[HTMLBodyElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_br(name: br): Selection_[HTMLBRElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_button(name: button): Selection_[HTMLButtonElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_canvas(name: canvas): Selection_[HTMLCanvasElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_caption(name: caption): Selection_[HTMLTableCaptionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_circle(name: circle): Selection_[SVGCircleElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_cite(name: cite): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_clipPath(name: clipPath): Selection_[SVGClipPathElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_code(name: code): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_col(name: col): Selection_[HTMLTableColElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_colgroup(name: colgroup): Selection_[HTMLTableColElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_data(name: data): Selection_[HTMLDataElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_datalist(name: datalist): Selection_[HTMLDataListElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_dd(name: dd): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_defs(name: defs): Selection_[SVGDefsElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_del(name: del): Selection_[HTMLModElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_desc(name: desc): Selection_[SVGDescElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_details(name: details): Selection_[HTMLDetailsElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_dfn(name: dfn): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_dialog(name: dialog): Selection_[HTMLDialogElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_dir(name: dir): Selection_[HTMLDirectoryElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_div(name: div): Selection_[HTMLDivElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_dl(name: dl): Selection_[HTMLDListElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_dt(name: dt): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_ellipse(name: ellipse): Selection_[SVGEllipseElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_em(name: em): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_embed(name: embed): Selection_[HTMLEmbedElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_feBlend(name: feBlend): Selection_[SVGFEBlendElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_feColorMatrix(name: feColorMatrix): Selection_[SVGFEColorMatrixElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_feComponentTransfer(name: feComponentTransfer): Selection_[
    SVGFEComponentTransferElement, 
    js.UndefOr[scala.Nothing], 
    Null, 
    js.UndefOr[scala.Nothing]
  ] = js.native
  @JSName("create")
  def create_feComposite(name: feComposite): Selection_[SVGFECompositeElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_feConvolveMatrix(name: feConvolveMatrix): Selection_[SVGFEConvolveMatrixElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_feDiffuseLighting(name: feDiffuseLighting): Selection_[
    SVGFEDiffuseLightingElement, 
    js.UndefOr[scala.Nothing], 
    Null, 
    js.UndefOr[scala.Nothing]
  ] = js.native
  @JSName("create")
  def create_feDisplacementMap(name: feDisplacementMap): Selection_[
    SVGFEDisplacementMapElement, 
    js.UndefOr[scala.Nothing], 
    Null, 
    js.UndefOr[scala.Nothing]
  ] = js.native
  @JSName("create")
  def create_feDistantLight(name: feDistantLight): Selection_[SVGFEDistantLightElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_feFlood(name: feFlood): Selection_[SVGFEFloodElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_feFuncA(name: feFuncA): Selection_[SVGFEFuncAElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_feFuncB(name: feFuncB): Selection_[SVGFEFuncBElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_feFuncG(name: feFuncG): Selection_[SVGFEFuncGElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_feFuncR(name: feFuncR): Selection_[SVGFEFuncRElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_feGaussianBlur(name: feGaussianBlur): Selection_[SVGFEGaussianBlurElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_feImage(name: feImage): Selection_[SVGFEImageElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_feMerge(name: feMerge): Selection_[SVGFEMergeElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_feMergeNode(name: feMergeNode): Selection_[SVGFEMergeNodeElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_feMorphology(name: feMorphology): Selection_[SVGFEMorphologyElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_feOffset(name: feOffset): Selection_[SVGFEOffsetElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_fePointLight(name: fePointLight): Selection_[SVGFEPointLightElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_feSpecularLighting(name: feSpecularLighting): Selection_[
    SVGFESpecularLightingElement, 
    js.UndefOr[scala.Nothing], 
    Null, 
    js.UndefOr[scala.Nothing]
  ] = js.native
  @JSName("create")
  def create_feSpotLight(name: feSpotLight): Selection_[SVGFESpotLightElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_feTile(name: feTile): Selection_[SVGFETileElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_feTurbulence(name: feTurbulence): Selection_[SVGFETurbulenceElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_fieldset(name: fieldset): Selection_[HTMLFieldSetElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_figcaption(name: figcaption): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_figure(name: figure): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_filter(name: filter): Selection_[SVGFilterElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_font(name: font): Selection_[HTMLFontElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_footer(name: footer): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_foreignObject(name: foreignObject): Selection_[SVGForeignObjectElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_form(name: form): Selection_[HTMLFormElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_frame(name: frame): Selection_[HTMLFrameElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_frameset(name: frameset): Selection_[HTMLFrameSetElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_g(name: g): Selection_[SVGGElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_h1(name: h1): Selection_[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_h2(name: h2): Selection_[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_h3(name: h3): Selection_[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_h4(name: h4): Selection_[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_h5(name: h5): Selection_[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_h6(name: h6): Selection_[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_head(name: head): Selection_[HTMLHeadElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_header(name: header): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_hgroup(name: hgroup): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_hr(name: hr): Selection_[HTMLHRElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_html(name: html): Selection_[HTMLHtmlElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_i(name: i): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_iframe(name: iframe): Selection_[HTMLIFrameElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_image(name: image): Selection_[SVGImageElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_img(name: img): Selection_[HTMLImageElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_input(name: input): Selection_[HTMLInputElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_ins(name: ins): Selection_[HTMLModElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_kbd(name: kbd): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_label(name: label): Selection_[HTMLLabelElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_legend(name: legend): Selection_[HTMLLegendElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_li(name: li): Selection_[HTMLLIElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_line(name: line): Selection_[SVGLineElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_linearGradient(name: linearGradient): Selection_[SVGLinearGradientElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_link(name: link): Selection_[HTMLLinkElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_main(name: main): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_map(name: map): Selection_[HTMLMapElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_mark(name: mark): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_marker(name: marker): Selection_[SVGMarkerElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_marquee(name: marquee): Selection_[HTMLMarqueeElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_mask(name: mask): Selection_[SVGMaskElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_menu(name: menu): Selection_[HTMLMenuElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_meta(name: meta): Selection_[HTMLMetaElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_metadata(name: metadata): Selection_[SVGMetadataElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_meter(name: meter): Selection_[HTMLMeterElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_nav(name: nav): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_noscript(name: noscript): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_object(name: `object`): Selection_[HTMLObjectElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_ol(name: ol): Selection_[HTMLOListElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_optgroup(name: optgroup): Selection_[HTMLOptGroupElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_option(name: option): Selection_[HTMLOptionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_output(name: output): Selection_[HTMLOutputElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_p(name: p): Selection_[HTMLParagraphElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_param(name: param): Selection_[HTMLParamElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_path(name: path): Selection_[SVGPathElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_pattern(name: pattern): Selection_[SVGPatternElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_picture(name: picture): Selection_[HTMLPictureElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_polygon(name: polygon): Selection_[SVGPolygonElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_polyline(name: polyline): Selection_[SVGPolylineElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_pre(name: pre): Selection_[HTMLPreElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_progress(name: progress): Selection_[HTMLProgressElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_q(name: q): Selection_[HTMLQuoteElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_radialGradient(name: radialGradient): Selection_[SVGRadialGradientElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_rect(name: rect): Selection_[SVGRectElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_rp(name: rp): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_rt(name: rt): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_ruby(name: ruby): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_s(name: s): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_samp(name: samp): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_script(name: script): Selection_[HTMLScriptElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_section(name: section): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_select(name: select): Selection_[HTMLSelectElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_slot(name: slot): Selection_[HTMLSlotElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_small(name: small): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_source(name: source): Selection_[HTMLSourceElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_span(name: span): Selection_[HTMLSpanElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_stop(name: stop): Selection_[SVGStopElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_strong(name: strong): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_style(name: style): Selection_[HTMLStyleElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_sub(name: sub): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_summary(name: summary): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_sup(name: sup): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_svg(name: svg): Selection_[SVGSVGElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_switch(name: switch): Selection_[SVGSwitchElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_symbol(name: symbol): Selection_[SVGSymbolElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_table(name: table): Selection_[HTMLTableElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_tbody(name: tbody): Selection_[HTMLTableSectionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_td(name: td): Selection_[HTMLTableDataCellElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_template(name: template): Selection_[HTMLTemplateElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_text(name: text): Selection_[SVGTextElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_textPath(name: textPath): Selection_[SVGTextPathElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_textarea(name: textarea): Selection_[HTMLTextAreaElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_tfoot(name: tfoot): Selection_[HTMLTableSectionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_th(name: th): Selection_[HTMLTableHeaderCellElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_thead(name: thead): Selection_[HTMLTableSectionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_time(name: time): Selection_[HTMLTimeElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_title(name: title): Selection_[HTMLTitleElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_tr(name: tr): Selection_[HTMLTableRowElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_track(name: track): Selection_[HTMLTrackElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_tspan(name: tspan): Selection_[SVGTSpanElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_u(name: u): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_ul(name: ul): Selection_[HTMLUListElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_use(name: use): Selection_[SVGUseElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_var(name: `var`): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_video(name: video): Selection_[HTMLVideoElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_view(name: view): Selection_[SVGViewElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_wbr(name: wbr): Selection_[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  
  def creator[NewGElement /* <: Element */](name: String): js.ThisFunction0[/* this */ BaseType, NewGElement] = js.native
  @JSName("creator")
  def creator_a(name: a): js.ThisFunction0[/* this */ BaseType, HTMLAnchorElement] = js.native
  @JSName("creator")
  def creator_abbr(name: abbr): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_address(name: address): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_applet(name: applet): js.ThisFunction0[/* this */ BaseType, HTMLAppletElement] = js.native
  @JSName("creator")
  def creator_area(name: area): js.ThisFunction0[/* this */ BaseType, HTMLAreaElement] = js.native
  @JSName("creator")
  def creator_article(name: article): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_aside(name: aside): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_audio(name: audio): js.ThisFunction0[/* this */ BaseType, HTMLAudioElement] = js.native
  @JSName("creator")
  def creator_b(name: b_): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_base(name: base): js.ThisFunction0[/* this */ BaseType, HTMLBaseElement] = js.native
  @JSName("creator")
  def creator_basefont(name: basefont): js.ThisFunction0[/* this */ BaseType, HTMLBaseFontElement] = js.native
  @JSName("creator")
  def creator_bdi(name: bdi): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_bdo(name: bdo): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_blockquote(name: blockquote): js.ThisFunction0[/* this */ BaseType, HTMLQuoteElement] = js.native
  @JSName("creator")
  def creator_body(name: body): js.ThisFunction0[/* this */ BaseType, HTMLBodyElement] = js.native
  @JSName("creator")
  def creator_br(name: br): js.ThisFunction0[/* this */ BaseType, HTMLBRElement] = js.native
  @JSName("creator")
  def creator_button(name: button): js.ThisFunction0[/* this */ BaseType, HTMLButtonElement] = js.native
  @JSName("creator")
  def creator_canvas(name: canvas): js.ThisFunction0[/* this */ BaseType, HTMLCanvasElement] = js.native
  @JSName("creator")
  def creator_caption(name: caption): js.ThisFunction0[/* this */ BaseType, HTMLTableCaptionElement] = js.native
  @JSName("creator")
  def creator_circle(name: circle): js.ThisFunction0[/* this */ BaseType, SVGCircleElement] = js.native
  @JSName("creator")
  def creator_cite(name: cite): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_clipPath(name: clipPath): js.ThisFunction0[/* this */ BaseType, SVGClipPathElement] = js.native
  @JSName("creator")
  def creator_code(name: code): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_col(name: col): js.ThisFunction0[/* this */ BaseType, HTMLTableColElement] = js.native
  @JSName("creator")
  def creator_colgroup(name: colgroup): js.ThisFunction0[/* this */ BaseType, HTMLTableColElement] = js.native
  @JSName("creator")
  def creator_data(name: data): js.ThisFunction0[/* this */ BaseType, HTMLDataElement] = js.native
  @JSName("creator")
  def creator_datalist(name: datalist): js.ThisFunction0[/* this */ BaseType, HTMLDataListElement] = js.native
  @JSName("creator")
  def creator_dd(name: dd): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_defs(name: defs): js.ThisFunction0[/* this */ BaseType, SVGDefsElement] = js.native
  @JSName("creator")
  def creator_del(name: del): js.ThisFunction0[/* this */ BaseType, HTMLModElement] = js.native
  @JSName("creator")
  def creator_desc(name: desc): js.ThisFunction0[/* this */ BaseType, SVGDescElement] = js.native
  @JSName("creator")
  def creator_details(name: details): js.ThisFunction0[/* this */ BaseType, HTMLDetailsElement] = js.native
  @JSName("creator")
  def creator_dfn(name: dfn): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_dialog(name: dialog): js.ThisFunction0[/* this */ BaseType, HTMLDialogElement] = js.native
  @JSName("creator")
  def creator_dir(name: dir): js.ThisFunction0[/* this */ BaseType, HTMLDirectoryElement] = js.native
  @JSName("creator")
  def creator_div(name: div): js.ThisFunction0[/* this */ BaseType, HTMLDivElement] = js.native
  @JSName("creator")
  def creator_dl(name: dl): js.ThisFunction0[/* this */ BaseType, HTMLDListElement] = js.native
  @JSName("creator")
  def creator_dt(name: dt): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_ellipse(name: ellipse): js.ThisFunction0[/* this */ BaseType, SVGEllipseElement] = js.native
  @JSName("creator")
  def creator_em(name: em): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_embed(name: embed): js.ThisFunction0[/* this */ BaseType, HTMLEmbedElement] = js.native
  @JSName("creator")
  def creator_feBlend(name: feBlend): js.ThisFunction0[/* this */ BaseType, SVGFEBlendElement] = js.native
  @JSName("creator")
  def creator_feColorMatrix(name: feColorMatrix): js.ThisFunction0[/* this */ BaseType, SVGFEColorMatrixElement] = js.native
  @JSName("creator")
  def creator_feComponentTransfer(name: feComponentTransfer): js.ThisFunction0[/* this */ BaseType, SVGFEComponentTransferElement] = js.native
  @JSName("creator")
  def creator_feComposite(name: feComposite): js.ThisFunction0[/* this */ BaseType, SVGFECompositeElement] = js.native
  @JSName("creator")
  def creator_feConvolveMatrix(name: feConvolveMatrix): js.ThisFunction0[/* this */ BaseType, SVGFEConvolveMatrixElement] = js.native
  @JSName("creator")
  def creator_feDiffuseLighting(name: feDiffuseLighting): js.ThisFunction0[/* this */ BaseType, SVGFEDiffuseLightingElement] = js.native
  @JSName("creator")
  def creator_feDisplacementMap(name: feDisplacementMap): js.ThisFunction0[/* this */ BaseType, SVGFEDisplacementMapElement] = js.native
  @JSName("creator")
  def creator_feDistantLight(name: feDistantLight): js.ThisFunction0[/* this */ BaseType, SVGFEDistantLightElement] = js.native
  @JSName("creator")
  def creator_feFlood(name: feFlood): js.ThisFunction0[/* this */ BaseType, SVGFEFloodElement] = js.native
  @JSName("creator")
  def creator_feFuncA(name: feFuncA): js.ThisFunction0[/* this */ BaseType, SVGFEFuncAElement] = js.native
  @JSName("creator")
  def creator_feFuncB(name: feFuncB): js.ThisFunction0[/* this */ BaseType, SVGFEFuncBElement] = js.native
  @JSName("creator")
  def creator_feFuncG(name: feFuncG): js.ThisFunction0[/* this */ BaseType, SVGFEFuncGElement] = js.native
  @JSName("creator")
  def creator_feFuncR(name: feFuncR): js.ThisFunction0[/* this */ BaseType, SVGFEFuncRElement] = js.native
  @JSName("creator")
  def creator_feGaussianBlur(name: feGaussianBlur): js.ThisFunction0[/* this */ BaseType, SVGFEGaussianBlurElement] = js.native
  @JSName("creator")
  def creator_feImage(name: feImage): js.ThisFunction0[/* this */ BaseType, SVGFEImageElement] = js.native
  @JSName("creator")
  def creator_feMerge(name: feMerge): js.ThisFunction0[/* this */ BaseType, SVGFEMergeElement] = js.native
  @JSName("creator")
  def creator_feMergeNode(name: feMergeNode): js.ThisFunction0[/* this */ BaseType, SVGFEMergeNodeElement] = js.native
  @JSName("creator")
  def creator_feMorphology(name: feMorphology): js.ThisFunction0[/* this */ BaseType, SVGFEMorphologyElement] = js.native
  @JSName("creator")
  def creator_feOffset(name: feOffset): js.ThisFunction0[/* this */ BaseType, SVGFEOffsetElement] = js.native
  @JSName("creator")
  def creator_fePointLight(name: fePointLight): js.ThisFunction0[/* this */ BaseType, SVGFEPointLightElement] = js.native
  @JSName("creator")
  def creator_feSpecularLighting(name: feSpecularLighting): js.ThisFunction0[/* this */ BaseType, SVGFESpecularLightingElement] = js.native
  @JSName("creator")
  def creator_feSpotLight(name: feSpotLight): js.ThisFunction0[/* this */ BaseType, SVGFESpotLightElement] = js.native
  @JSName("creator")
  def creator_feTile(name: feTile): js.ThisFunction0[/* this */ BaseType, SVGFETileElement] = js.native
  @JSName("creator")
  def creator_feTurbulence(name: feTurbulence): js.ThisFunction0[/* this */ BaseType, SVGFETurbulenceElement] = js.native
  @JSName("creator")
  def creator_fieldset(name: fieldset): js.ThisFunction0[/* this */ BaseType, HTMLFieldSetElement] = js.native
  @JSName("creator")
  def creator_figcaption(name: figcaption): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_figure(name: figure): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_filter(name: filter): js.ThisFunction0[/* this */ BaseType, SVGFilterElement] = js.native
  @JSName("creator")
  def creator_font(name: font): js.ThisFunction0[/* this */ BaseType, HTMLFontElement] = js.native
  @JSName("creator")
  def creator_footer(name: footer): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_foreignObject(name: foreignObject): js.ThisFunction0[/* this */ BaseType, SVGForeignObjectElement] = js.native
  @JSName("creator")
  def creator_form(name: form): js.ThisFunction0[/* this */ BaseType, HTMLFormElement] = js.native
  @JSName("creator")
  def creator_frame(name: frame): js.ThisFunction0[/* this */ BaseType, HTMLFrameElement] = js.native
  @JSName("creator")
  def creator_frameset(name: frameset): js.ThisFunction0[/* this */ BaseType, HTMLFrameSetElement] = js.native
  @JSName("creator")
  def creator_g(name: g): js.ThisFunction0[/* this */ BaseType, SVGGElement] = js.native
  @JSName("creator")
  def creator_h1(name: h1): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
  @JSName("creator")
  def creator_h2(name: h2): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
  @JSName("creator")
  def creator_h3(name: h3): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
  @JSName("creator")
  def creator_h4(name: h4): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
  @JSName("creator")
  def creator_h5(name: h5): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
  @JSName("creator")
  def creator_h6(name: h6): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
  @JSName("creator")
  def creator_head(name: head): js.ThisFunction0[/* this */ BaseType, HTMLHeadElement] = js.native
  @JSName("creator")
  def creator_header(name: header): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_hgroup(name: hgroup): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_hr(name: hr): js.ThisFunction0[/* this */ BaseType, HTMLHRElement] = js.native
  @JSName("creator")
  def creator_html(name: html): js.ThisFunction0[/* this */ BaseType, HTMLHtmlElement] = js.native
  @JSName("creator")
  def creator_i(name: i): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_iframe(name: iframe): js.ThisFunction0[/* this */ BaseType, HTMLIFrameElement] = js.native
  @JSName("creator")
  def creator_image(name: image): js.ThisFunction0[/* this */ BaseType, SVGImageElement] = js.native
  @JSName("creator")
  def creator_img(name: img): js.ThisFunction0[/* this */ BaseType, HTMLImageElement] = js.native
  @JSName("creator")
  def creator_input(name: input): js.ThisFunction0[/* this */ BaseType, HTMLInputElement] = js.native
  @JSName("creator")
  def creator_ins(name: ins): js.ThisFunction0[/* this */ BaseType, HTMLModElement] = js.native
  @JSName("creator")
  def creator_kbd(name: kbd): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_label(name: label): js.ThisFunction0[/* this */ BaseType, HTMLLabelElement] = js.native
  @JSName("creator")
  def creator_legend(name: legend): js.ThisFunction0[/* this */ BaseType, HTMLLegendElement] = js.native
  @JSName("creator")
  def creator_li(name: li): js.ThisFunction0[/* this */ BaseType, HTMLLIElement] = js.native
  @JSName("creator")
  def creator_line(name: line): js.ThisFunction0[/* this */ BaseType, SVGLineElement] = js.native
  @JSName("creator")
  def creator_linearGradient(name: linearGradient): js.ThisFunction0[/* this */ BaseType, SVGLinearGradientElement] = js.native
  @JSName("creator")
  def creator_link(name: link): js.ThisFunction0[/* this */ BaseType, HTMLLinkElement] = js.native
  @JSName("creator")
  def creator_main(name: main): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_map(name: map): js.ThisFunction0[/* this */ BaseType, HTMLMapElement] = js.native
  @JSName("creator")
  def creator_mark(name: mark): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_marker(name: marker): js.ThisFunction0[/* this */ BaseType, SVGMarkerElement] = js.native
  @JSName("creator")
  def creator_marquee(name: marquee): js.ThisFunction0[/* this */ BaseType, HTMLMarqueeElement] = js.native
  @JSName("creator")
  def creator_mask(name: mask): js.ThisFunction0[/* this */ BaseType, SVGMaskElement] = js.native
  @JSName("creator")
  def creator_menu(name: menu): js.ThisFunction0[/* this */ BaseType, HTMLMenuElement] = js.native
  @JSName("creator")
  def creator_meta(name: meta): js.ThisFunction0[/* this */ BaseType, HTMLMetaElement] = js.native
  @JSName("creator")
  def creator_metadata(name: metadata): js.ThisFunction0[/* this */ BaseType, SVGMetadataElement] = js.native
  @JSName("creator")
  def creator_meter(name: meter): js.ThisFunction0[/* this */ BaseType, HTMLMeterElement] = js.native
  @JSName("creator")
  def creator_nav(name: nav): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_noscript(name: noscript): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_object(name: `object`): js.ThisFunction0[/* this */ BaseType, HTMLObjectElement] = js.native
  @JSName("creator")
  def creator_ol(name: ol): js.ThisFunction0[/* this */ BaseType, HTMLOListElement] = js.native
  @JSName("creator")
  def creator_optgroup(name: optgroup): js.ThisFunction0[/* this */ BaseType, HTMLOptGroupElement] = js.native
  @JSName("creator")
  def creator_option(name: option): js.ThisFunction0[/* this */ BaseType, HTMLOptionElement] = js.native
  @JSName("creator")
  def creator_output(name: output): js.ThisFunction0[/* this */ BaseType, HTMLOutputElement] = js.native
  @JSName("creator")
  def creator_p(name: p): js.ThisFunction0[/* this */ BaseType, HTMLParagraphElement] = js.native
  @JSName("creator")
  def creator_param(name: param): js.ThisFunction0[/* this */ BaseType, HTMLParamElement] = js.native
  @JSName("creator")
  def creator_path(name: path): js.ThisFunction0[/* this */ BaseType, SVGPathElement] = js.native
  @JSName("creator")
  def creator_pattern(name: pattern): js.ThisFunction0[/* this */ BaseType, SVGPatternElement] = js.native
  @JSName("creator")
  def creator_picture(name: picture): js.ThisFunction0[/* this */ BaseType, HTMLPictureElement] = js.native
  @JSName("creator")
  def creator_polygon(name: polygon): js.ThisFunction0[/* this */ BaseType, SVGPolygonElement] = js.native
  @JSName("creator")
  def creator_polyline(name: polyline): js.ThisFunction0[/* this */ BaseType, SVGPolylineElement] = js.native
  @JSName("creator")
  def creator_pre(name: pre): js.ThisFunction0[/* this */ BaseType, HTMLPreElement] = js.native
  @JSName("creator")
  def creator_progress(name: progress): js.ThisFunction0[/* this */ BaseType, HTMLProgressElement] = js.native
  @JSName("creator")
  def creator_q(name: q): js.ThisFunction0[/* this */ BaseType, HTMLQuoteElement] = js.native
  @JSName("creator")
  def creator_radialGradient(name: radialGradient): js.ThisFunction0[/* this */ BaseType, SVGRadialGradientElement] = js.native
  @JSName("creator")
  def creator_rect(name: rect): js.ThisFunction0[/* this */ BaseType, SVGRectElement] = js.native
  @JSName("creator")
  def creator_rp(name: rp): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_rt(name: rt): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_ruby(name: ruby): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_s(name: s): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_samp(name: samp): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_script(name: script): js.ThisFunction0[/* this */ BaseType, HTMLScriptElement] = js.native
  @JSName("creator")
  def creator_section(name: section): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_select(name: select): js.ThisFunction0[/* this */ BaseType, HTMLSelectElement] = js.native
  @JSName("creator")
  def creator_slot(name: slot): js.ThisFunction0[/* this */ BaseType, HTMLSlotElement] = js.native
  @JSName("creator")
  def creator_small(name: small): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_source(name: source): js.ThisFunction0[/* this */ BaseType, HTMLSourceElement] = js.native
  @JSName("creator")
  def creator_span(name: span): js.ThisFunction0[/* this */ BaseType, HTMLSpanElement] = js.native
  @JSName("creator")
  def creator_stop(name: stop): js.ThisFunction0[/* this */ BaseType, SVGStopElement] = js.native
  @JSName("creator")
  def creator_strong(name: strong): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_style(name: style): js.ThisFunction0[/* this */ BaseType, HTMLStyleElement] = js.native
  @JSName("creator")
  def creator_sub(name: sub): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_summary(name: summary): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_sup(name: sup): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_svg(name: svg): js.ThisFunction0[/* this */ BaseType, SVGSVGElement] = js.native
  @JSName("creator")
  def creator_switch(name: switch): js.ThisFunction0[/* this */ BaseType, SVGSwitchElement] = js.native
  @JSName("creator")
  def creator_symbol(name: symbol): js.ThisFunction0[/* this */ BaseType, SVGSymbolElement] = js.native
  @JSName("creator")
  def creator_table(name: table): js.ThisFunction0[/* this */ BaseType, HTMLTableElement] = js.native
  @JSName("creator")
  def creator_tbody(name: tbody): js.ThisFunction0[/* this */ BaseType, HTMLTableSectionElement] = js.native
  @JSName("creator")
  def creator_td(name: td): js.ThisFunction0[/* this */ BaseType, HTMLTableDataCellElement] = js.native
  @JSName("creator")
  def creator_template(name: template): js.ThisFunction0[/* this */ BaseType, HTMLTemplateElement] = js.native
  @JSName("creator")
  def creator_text(name: text): js.ThisFunction0[/* this */ BaseType, SVGTextElement] = js.native
  @JSName("creator")
  def creator_textPath(name: textPath): js.ThisFunction0[/* this */ BaseType, SVGTextPathElement] = js.native
  @JSName("creator")
  def creator_textarea(name: textarea): js.ThisFunction0[/* this */ BaseType, HTMLTextAreaElement] = js.native
  @JSName("creator")
  def creator_tfoot(name: tfoot): js.ThisFunction0[/* this */ BaseType, HTMLTableSectionElement] = js.native
  @JSName("creator")
  def creator_th(name: th): js.ThisFunction0[/* this */ BaseType, HTMLTableHeaderCellElement] = js.native
  @JSName("creator")
  def creator_thead(name: thead): js.ThisFunction0[/* this */ BaseType, HTMLTableSectionElement] = js.native
  @JSName("creator")
  def creator_time(name: time): js.ThisFunction0[/* this */ BaseType, HTMLTimeElement] = js.native
  @JSName("creator")
  def creator_title(name: title): js.ThisFunction0[/* this */ BaseType, HTMLTitleElement] = js.native
  @JSName("creator")
  def creator_tr(name: tr): js.ThisFunction0[/* this */ BaseType, HTMLTableRowElement] = js.native
  @JSName("creator")
  def creator_track(name: track): js.ThisFunction0[/* this */ BaseType, HTMLTrackElement] = js.native
  @JSName("creator")
  def creator_tspan(name: tspan): js.ThisFunction0[/* this */ BaseType, SVGTSpanElement] = js.native
  @JSName("creator")
  def creator_u(name: u): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_ul(name: ul): js.ThisFunction0[/* this */ BaseType, HTMLUListElement] = js.native
  @JSName("creator")
  def creator_use(name: use): js.ThisFunction0[/* this */ BaseType, SVGUseElement] = js.native
  @JSName("creator")
  def creator_var(name: `var`): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_video(name: video): js.ThisFunction0[/* this */ BaseType, HTMLVideoElement] = js.native
  @JSName("creator")
  def creator_view(name: view): js.ThisFunction0[/* this */ BaseType, SVGViewElement] = js.native
  @JSName("creator")
  def creator_wbr(name: wbr): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  
  def cross[S, T](a: js.Iterable[S], b: js.Iterable[T]): js.Array[js.Tuple2[S, T]] = js.native
  def cross[S, T, U](a: js.Iterable[S], b: js.Iterable[T], reducer: js.Function2[/* a */ S, /* b */ T, U]): js.Array[U] = js.native
  
  def csv[Columns /* <: String */](url: String): js.Promise[DSVRowArray[Columns]] = js.native
  def csv[Columns /* <: String */](url: String, init: RequestInit): js.Promise[DSVRowArray[Columns]] = js.native
  def csv[ParsedRow /* <: js.Object */, Columns /* <: String */](
    url: String,
    init: RequestInit,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
  def csv[ParsedRow /* <: js.Object */, Columns /* <: String */](
    url: String,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
  
  def csvFormat[T /* <: js.Object */](rows: js.Array[T]): String = js.native
  def csvFormat[T /* <: js.Object */](rows: js.Array[T], columns: js.Array[/* keyof T */ String]): String = js.native
  
  def csvFormatBody[T /* <: js.Object */](rows: js.Array[T]): String = js.native
  def csvFormatBody[T /* <: js.Object */](rows: js.Array[T], columns: js.Array[/* keyof T */ String]): String = js.native
  
  def csvFormatRow(row: js.Array[String]): String = js.native
  
  def csvFormatRows(rows: js.Array[js.Array[String]]): String = js.native
  
  def csvFormatValue(value: String): String = js.native
  
  def csvParse[Columns /* <: String */](csvString: String): DSVRowArray[Columns] = js.native
  def csvParse[ParsedRow /* <: js.Object */, Columns /* <: String */](
    csvString: String,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): DSVParsedArray[ParsedRow] = js.native
  
  def csvParseRows(csvString: String): js.Array[js.Array[String]] = js.native
  def csvParseRows[ParsedRow /* <: js.Object */](
    csvString: String,
    row: js.Function2[/* rawRow */ js.Array[String], /* index */ Double, js.UndefOr[ParsedRow | Null]]
  ): js.Array[ParsedRow] = js.native
  
  def cubehelix(color: ColorCommonInstance): CubehelixColor = js.native
  /**
    * Converts the provided color instance and returns a Cubehelix color.
    * The color instance is specified, it is converted to the RGB color space using color.rgb and then converted to Cubehelix.
    * (Colors already in the Cubehelix color space skip the conversion to RGB.)
    *
    * @param color A permissible color space instance.
    */
  def cubehelix(color: ColorSpaceObject): CubehelixColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning an Cubehelix color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
    */
  def cubehelix(cssColorSpecifier: String): CubehelixColor = js.native
  /**
    * Constructs a new Cubehelix color based on the specified channel values and opacity.
    *
    * @param h Hue channel value.
    * @param s Saturation channel value.
    * @param l Lightness channel value.
    * @param opacity Optional opacity value, defaults to 1.
    */
  def cubehelix(h: Double, s: Double, l: Double): CubehelixColor = js.native
  def cubehelix(h: Double, s: Double, l: Double, opacity: Double): CubehelixColor = js.native
  @JSName("cubehelix")
  val cubehelix_Original: CubehelixColorFactory = js.native
  
  def cumsum[T /* <: Numeric */](iterable: js.Iterable[js.UndefOr[T | Null]]): js.typedarray.Float64Array = js.native
  def cumsum[T](
    iterable: js.Iterable[T],
    accessor: js.Function3[/* element */ T, /* i */ Double, /* array */ js.Iterable[T], js.UndefOr[Double | Null]]
  ): js.typedarray.Float64Array = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveBasis(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveBasis(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveBasisClosed(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveBasisClosed(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveBasisOpen(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveBasisOpen(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  val curveBundle: CurveBundleFactory = js.native
  
  val curveCardinal: CurveCardinalFactory = js.native
  
  val curveCardinalClosed: CurveCardinalFactory = js.native
  
  val curveCardinalOpen: CurveCardinalFactory = js.native
  
  val curveCatmullRom: CurveCatmullRomFactory = js.native
  
  val curveCatmullRomClosed: CurveCatmullRomFactory = js.native
  
  val curveCatmullRomOpen: CurveCatmullRomFactory = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveLinear(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveLinear(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveLinearClosed(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveLinearClosed(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveMonotoneX(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveMonotoneX(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveMonotoneY(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveMonotoneY(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveNatural(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveNatural(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveStep(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveStep(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveStepAfter(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveStepAfter(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveStepBefore(context: Path_): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveStepBefore(context: CanvasRenderingContext2D): CurveGenerator = js.native
  
  def descending(): Double = js.native
  def descending(a: js.UndefOr[Primitive], b: Primitive): Double = js.native
  def descending(a: Primitive): Double = js.native
  
  def deviation[T /* <: Numeric */](iterable: js.Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = js.native
  def deviation[T](
    iterable: js.Iterable[T],
    accessor: js.Function3[
      /* datum */ T, 
      /* index */ Double, 
      /* array */ js.Iterable[T], 
      js.UndefOr[Double | Null]
    ]
  ): js.UndefOr[Double] = js.native
  
  def difference[T](iterable: js.Iterable[T], others: js.Iterable[T]*): Set[T] = js.native
  
  def disjoint[T](a: js.Iterable[T], b: js.Iterable[T]): Boolean = js.native
  
  def dispatch[T /* <: js.Object */](types: String*): Dispatch_[T] = js.native
  
  def drag[GElement /* <: Element */, Datum](): DragBehavior[GElement, Datum, Datum | SubjectPosition] = js.native
  
  def dragDisable(window: Window): Unit = js.native
  
  def dragEnable(window: Window): Unit = js.native
  def dragEnable(window: Window, noClick: Boolean): Unit = js.native
  
  @JSName("drag")
  def drag_GElement_DraggedElementBaseTypeDatumSubject[GElement /* <: Element */, Datum, Subject](): DragBehavior[GElement, Datum, Subject] = js.native
  
  def dsv[Columns /* <: String */](delimiter: String, url: String): js.Promise[DSVRowArray[Columns]] = js.native
  def dsv[Columns /* <: String */](delimiter: String, url: String, init: RequestInit): js.Promise[DSVRowArray[Columns]] = js.native
  def dsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
    delimiter: String,
    url: String,
    init: RequestInit,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
  def dsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
    delimiter: String,
    url: String,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
  
  def dsvFormat(delimiter: String): DSV = js.native
  
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easeBack(normalizedTime: Double): Double = js.native
  
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easeBackIn(normalizedTime: Double): Double = js.native
  
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easeBackInOut(normalizedTime: Double): Double = js.native
  @JSName("easeBackInOut")
  val easeBackInOut_Original: BackEasingFactory = js.native
  
  @JSName("easeBackIn")
  val easeBackIn_Original: BackEasingFactory = js.native
  
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easeBackOut(normalizedTime: Double): Double = js.native
  @JSName("easeBackOut")
  val easeBackOut_Original: BackEasingFactory = js.native
  
  @JSName("easeBack")
  val easeBack_Original: BackEasingFactory = js.native
  
  def easeBounce(normalizedTime: Double): Double = js.native
  
  def easeBounceIn(normalizedTime: Double): Double = js.native
  
  def easeBounceInOut(normalizedTime: Double): Double = js.native
  
  def easeBounceOut(normalizedTime: Double): Double = js.native
  
  def easeCircle(normalizedTime: Double): Double = js.native
  
  def easeCircleIn(normalizedTime: Double): Double = js.native
  
  def easeCircleInOut(normalizedTime: Double): Double = js.native
  
  def easeCircleOut(normalizedTime: Double): Double = js.native
  
  def easeCubic(normalizedTime: Double): Double = js.native
  
  def easeCubicIn(normalizedTime: Double): Double = js.native
  
  def easeCubicInOut(normalizedTime: Double): Double = js.native
  
  def easeCubicOut(normalizedTime: Double): Double = js.native
  
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easeElastic(normalizedTime: Double): Double = js.native
  
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easeElasticIn(normalizedTime: Double): Double = js.native
  
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easeElasticInOut(normalizedTime: Double): Double = js.native
  @JSName("easeElasticInOut")
  val easeElasticInOut_Original: ElasticEasingFactory = js.native
  
  @JSName("easeElasticIn")
  val easeElasticIn_Original: ElasticEasingFactory = js.native
  
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easeElasticOut(normalizedTime: Double): Double = js.native
  @JSName("easeElasticOut")
  val easeElasticOut_Original: ElasticEasingFactory = js.native
  
  @JSName("easeElastic")
  val easeElastic_Original: ElasticEasingFactory = js.native
  
  def easeExp(normalizedTime: Double): Double = js.native
  
  def easeExpIn(normalizedTime: Double): Double = js.native
  
  def easeExpInOut(normalizedTime: Double): Double = js.native
  
  def easeExpOut(normalizedTime: Double): Double = js.native
  
  def easeLinear(normalizedTime: Double): Double = js.native
  
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easePoly(normalizedTime: Double): Double = js.native
  
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easePolyIn(normalizedTime: Double): Double = js.native
  
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easePolyInOut(normalizedTime: Double): Double = js.native
  @JSName("easePolyInOut")
  val easePolyInOut_Original: PolynomialEasingFactory = js.native
  
  @JSName("easePolyIn")
  val easePolyIn_Original: PolynomialEasingFactory = js.native
  
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easePolyOut(normalizedTime: Double): Double = js.native
  @JSName("easePolyOut")
  val easePolyOut_Original: PolynomialEasingFactory = js.native
  
  @JSName("easePoly")
  val easePoly_Original: PolynomialEasingFactory = js.native
  
  def easeQuad(normalizedTime: Double): Double = js.native
  
  def easeQuadIn(normalizedTime: Double): Double = js.native
  
  def easeQuadInOut(normalizedTime: Double): Double = js.native
  
  def easeQuadOut(normalizedTime: Double): Double = js.native
  
  def easeSin(normalizedTime: Double): Double = js.native
  
  def easeSinIn(normalizedTime: Double): Double = js.native
  
  def easeSinInOut(normalizedTime: Double): Double = js.native
  
  def easeSinOut(normalizedTime: Double): Double = js.native
  
  def every[T](
    iterable: js.Iterable[T],
    test: js.Function3[/* value */ T, /* index */ Double, /* iterable */ js.Iterable[T], _]
  ): Boolean = js.native
  
  def extent(iterable: js.Iterable[String]): js.Tuple2[js.UndefOr[String], js.UndefOr[String]] = js.native
  def extent[T](
    iterable: js.Iterable[T],
    accessor: js.Function3[
      /* datum */ T, 
      /* index */ Double, 
      /* array */ js.Iterable[T], 
      js.UndefOr[String | Null]
    ]
  ): js.Tuple2[js.UndefOr[String], js.UndefOr[String]] = js.native
  @JSName("extent")
  def extent_TU_Numeric[T, U /* <: Numeric */](
    iterable: js.Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ js.Iterable[T], js.UndefOr[U | Null]]
  ): js.Tuple2[js.UndefOr[U], js.UndefOr[U]] = js.native
  @JSName("extent")
  def extent_T_Numeric[T /* <: Numeric */](iterable: js.Iterable[T]): js.Tuple2[js.UndefOr[T], js.UndefOr[T]] = js.native
  
  def filter[T](
    iterable: js.Iterable[T],
    test: js.Function3[/* value */ T, /* index */ Double, /* iterable */ js.Iterable[T], _]
  ): js.Array[T] = js.native
  
  def forceCenter[NodeDatum /* <: SimulationNodeDatum */](): ForceCenter_[NodeDatum] = js.native
  def forceCenter[NodeDatum /* <: SimulationNodeDatum */](x: js.UndefOr[scala.Nothing], y: Double): ForceCenter_[NodeDatum] = js.native
  def forceCenter[NodeDatum /* <: SimulationNodeDatum */](x: Double): ForceCenter_[NodeDatum] = js.native
  def forceCenter[NodeDatum /* <: SimulationNodeDatum */](x: Double, y: Double): ForceCenter_[NodeDatum] = js.native
  
  def forceCollide[NodeDatum /* <: SimulationNodeDatum */](): ForceCollide_[NodeDatum] = js.native
  def forceCollide[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* node */ NodeDatum, /* i */ Double, /* nodes */ js.Array[NodeDatum], Double]
  ): ForceCollide_[NodeDatum] = js.native
  def forceCollide[NodeDatum /* <: SimulationNodeDatum */](radius: Double): ForceCollide_[NodeDatum] = js.native
  
  def forceLink[NodeDatum /* <: SimulationNodeDatum */, LinksDatum /* <: SimulationLinkDatum[NodeDatum] */](): ForceLink_[NodeDatum, LinksDatum] = js.native
  def forceLink[NodeDatum /* <: SimulationNodeDatum */, LinksDatum /* <: SimulationLinkDatum[NodeDatum] */](links: js.Array[LinksDatum]): ForceLink_[NodeDatum, LinksDatum] = js.native
  
  def forceManyBody[NodeDatum /* <: SimulationNodeDatum */](): ForceManyBody_[NodeDatum] = js.native
  
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]): ForceRadial_[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: js.UndefOr[scala.Nothing],
    y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial_[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: js.UndefOr[scala.Nothing],
    y: Double
  ): ForceRadial_[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial_[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial_[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    y: Double
  ): ForceRadial_[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: Double
  ): ForceRadial_[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: Double,
    y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial_[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: Double,
    y: Double
  ): ForceRadial_[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: Double): ForceRadial_[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: Double,
    x: js.UndefOr[scala.Nothing],
    y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial_[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: Double, x: js.UndefOr[scala.Nothing], y: Double): ForceRadial_[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: Double,
    x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial_[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: Double,
    x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial_[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: Double,
    x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    y: Double
  ): ForceRadial_[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: Double, x: Double): ForceRadial_[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: Double,
    x: Double,
    y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial_[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: Double, x: Double, y: Double): ForceRadial_[NodeDatum] = js.native
  
  def forceSimulation[NodeDatum /* <: SimulationNodeDatum */](): Simulation[NodeDatum, js.UndefOr[scala.Nothing]] = js.native
  def forceSimulation[NodeDatum /* <: SimulationNodeDatum */](nodesData: js.Array[NodeDatum]): Simulation[NodeDatum, js.UndefOr[scala.Nothing]] = js.native
  @JSName("forceSimulation")
  def forceSimulation_NodeDatum_SimulationNodeDatumLinkDatum_SimulationLinkDatumNodeDatum[NodeDatum /* <: SimulationNodeDatum */, LinkDatum /* <: SimulationLinkDatum[NodeDatum] */](): Simulation[NodeDatum, LinkDatum] = js.native
  @JSName("forceSimulation")
  def forceSimulation_NodeDatum_SimulationNodeDatumLinkDatum_SimulationLinkDatumNodeDatum[NodeDatum /* <: SimulationNodeDatum */, LinkDatum /* <: SimulationLinkDatum[NodeDatum] */](nodesData: js.Array[NodeDatum]): Simulation[NodeDatum, LinkDatum] = js.native
  
  def forceX[NodeDatum /* <: SimulationNodeDatum */](): ForceX_[NodeDatum] = js.native
  def forceX[NodeDatum /* <: SimulationNodeDatum */](x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]): ForceX_[NodeDatum] = js.native
  def forceX[NodeDatum /* <: SimulationNodeDatum */](x: Double): ForceX_[NodeDatum] = js.native
  
  def forceY[NodeDatum /* <: SimulationNodeDatum */](): ForceY_[NodeDatum] = js.native
  def forceY[NodeDatum /* <: SimulationNodeDatum */](y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]): ForceY_[NodeDatum] = js.native
  def forceY[NodeDatum /* <: SimulationNodeDatum */](y: Double): ForceY_[NodeDatum] = js.native
  
  def format(specifier: String): js.Function1[/* n */ Double | ValueOf, String] = js.native
  
  def formatDefaultLocale(defaultLocale: FormatLocaleDefinition): FormatLocaleObject = js.native
  
  def formatLocale(locale: FormatLocaleDefinition): FormatLocaleObject = js.native
  
  def formatPrefix(specifier: String, value: Double): js.Function1[/* n */ Double | ValueOf, String] = js.native
  
  def formatSpecifier(specifier: String): FormatSpecifier_ = js.native
  
  def fsum[T /* <: Numeric */](values: js.Iterable[js.UndefOr[T | Null]]): Double = js.native
  def fsum[T](
    values: js.Iterable[T],
    accessor: js.Function3[
      /* datum */ T, 
      /* index */ Double, 
      /* array */ js.Iterable[T], 
      js.UndefOr[Double | Null]
    ]
  ): Double = js.native
  
  def geoAlbers(): GeoConicProjection = js.native
  
  def geoAlbersUsa(): GeoProjection_ = js.native
  
  def geoArea(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): Double = js.native
  def geoArea(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): Double = js.native
  def geoArea(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): Double = js.native
  def geoArea(`object`: GeoGeometryObjects): Double = js.native
  
  def geoAzimuthalEqualArea(): GeoProjection_ = js.native
  
  def geoAzimuthalEqualAreaRaw(): GeoRawProjection = js.native
  
  def geoAzimuthalEquidistant(): GeoProjection_ = js.native
  
  def geoAzimuthalEquidistantRaw(): GeoRawProjection = js.native
  
  def geoBounds(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = js.native
  def geoBounds(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = js.native
  def geoBounds(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = js.native
  def geoBounds(`object`: GeoGeometryObjects): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = js.native
  
  def geoCentroid(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): js.Tuple2[Double, Double] = js.native
  def geoCentroid(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): js.Tuple2[Double, Double] = js.native
  def geoCentroid(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): js.Tuple2[Double, Double] = js.native
  def geoCentroid(`object`: GeoGeometryObjects): js.Tuple2[Double, Double] = js.native
  
  def geoCircle(): GeoCircleGenerator[_, _] = js.native
  @JSName("geoCircle")
  def geoCircle_Datum[Datum](): GeoCircleGenerator[_, Datum] = js.native
  @JSName("geoCircle")
  def geoCircle_ThisDatum[This, Datum](): GeoCircleGenerator[This, Datum] = js.native
  
  def geoClipAntimeridian(stream: GeoStream_): GeoStream_ = js.native
  
  def geoClipCircle(angle: Double): js.Function1[/* stream */ GeoStream_, GeoStream_] = js.native
  
  def geoClipRectangle(x0: Double, y0: Double, x1: Double, y1: Double): js.Function1[/* stream */ GeoStream_, GeoStream_] = js.native
  
  def geoConicConformal(): GeoConicProjection = js.native
  
  def geoConicConformalRaw(phi0: Double, phi1: Double): GeoRawProjection = js.native
  
  def geoConicEqualArea(): GeoConicProjection = js.native
  
  def geoConicEqualAreaRaw(phi0: Double, phi1: Double): GeoRawProjection = js.native
  
  def geoConicEquidistant(): GeoConicProjection = js.native
  
  def geoConicEquidistantRaw(phi0: Double, phi1: Double): GeoRawProjection = js.native
  
  def geoContains(
    `object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]],
    point: js.Tuple2[Double, Double]
  ): Boolean = js.native
  def geoContains(
    `object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties],
    point: js.Tuple2[Double, Double]
  ): Boolean = js.native
  def geoContains(`object`: ExtendedGeometryCollection[GeoGeometryObjects], point: js.Tuple2[Double, Double]): Boolean = js.native
  def geoContains(`object`: GeoGeometryObjects, point: js.Tuple2[Double, Double]): Boolean = js.native
  
  def geoDistance(a: js.Tuple2[Double, Double], b: js.Tuple2[Double, Double]): Double = js.native
  
  def geoEqualEarth(): GeoProjection_ = js.native
  
  def geoEqualEarthRaw(): GeoRawProjection = js.native
  
  def geoEquirectangular(): GeoProjection_ = js.native
  
  def geoEquirectangularRaw(): GeoRawProjection = js.native
  
  def geoGnomonic(): GeoProjection_ = js.native
  
  def geoGnomonicRaw(): GeoRawProjection = js.native
  
  def geoGraticule(): GeoGraticuleGenerator = js.native
  
  def geoGraticule10(): MultiLineString = js.native
  
  def geoIdentity(): GeoIdentityTransform = js.native
  
  def geoInterpolate(a: js.Tuple2[Double, Double], b: js.Tuple2[Double, Double]): js.Function1[/* t */ Double, js.Tuple2[Double, Double]] = js.native
  
  def geoLength(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): Double = js.native
  def geoLength(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): Double = js.native
  def geoLength(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): Double = js.native
  def geoLength(`object`: GeoGeometryObjects): Double = js.native
  
  def geoMercator(): GeoProjection_ = js.native
  
  def geoMercatorRaw(): GeoRawProjection = js.native
  
  def geoNaturalEarth1(): GeoProjection_ = js.native
  
  def geoNaturalEarth1Raw(): GeoRawProjection = js.native
  
  def geoOrthographic(): GeoProjection_ = js.native
  
  def geoOrthographicRaw(): GeoRawProjection = js.native
  
  def geoPath(): GeoPath_[_, GeoPermissibleObjects] = js.native
  def geoPath(projection: js.UndefOr[scala.Nothing], context: GeoContext): GeoPath_[_, GeoPermissibleObjects] = js.native
  def geoPath(projection: Null, context: GeoContext): GeoPath_[_, GeoPermissibleObjects] = js.native
  def geoPath(projection: GeoProjection_): GeoPath_[_, GeoPermissibleObjects] = js.native
  def geoPath(projection: GeoProjection_, context: GeoContext): GeoPath_[_, GeoPermissibleObjects] = js.native
  def geoPath(projection: GeoStreamWrapper): GeoPath_[_, GeoPermissibleObjects] = js.native
  def geoPath(projection: GeoStreamWrapper, context: GeoContext): GeoPath_[_, GeoPermissibleObjects] = js.native
  @JSName("geoPath")
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](): GeoPath_[_, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: js.UndefOr[scala.Nothing], context: GeoContext): GeoPath_[_, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: Null, context: GeoContext): GeoPath_[_, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection_): GeoPath_[_, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection_, context: GeoContext): GeoPath_[_, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper): GeoPath_[_, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper, context: GeoContext): GeoPath_[_, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](): GeoPath_[This, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: js.UndefOr[scala.Nothing], context: GeoContext): GeoPath_[This, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: Null, context: GeoContext): GeoPath_[This, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection_): GeoPath_[This, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection_, context: GeoContext): GeoPath_[This, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper): GeoPath_[This, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper, context: GeoContext): GeoPath_[This, DatumObject] = js.native
  
  def geoProjection(project: GeoRawProjection): GeoProjection_ = js.native
  
  def geoProjectionMutator(factory: js.Function1[/* repeated */ js.Any, GeoRawProjection]): js.Function0[GeoProjection_] = js.native
  
  def geoRotation(angles: js.Tuple2[Double, Double]): GeoRotation_ = js.native
  def geoRotation(angles: js.Tuple3[Double, Double, Double]): GeoRotation_ = js.native
  
  def geoStereographic(): GeoProjection_ = js.native
  
  def geoStereographicRaw(): GeoRawProjection = js.native
  
  def geoStream(
    `object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]],
    stream: GeoStream_
  ): Unit = js.native
  def geoStream(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties], stream: GeoStream_): Unit = js.native
  def geoStream(`object`: ExtendedGeometryCollection[GeoGeometryObjects], stream: GeoStream_): Unit = js.native
  def geoStream(`object`: GeoGeometryObjects, stream: GeoStream_): Unit = js.native
  
  def geoTransform[T /* <: GeoTransformPrototype */](methods: T): `0`[T] = js.native
  
  def geoTransverseMercator(): GeoProjection_ = js.native
  
  def geoTransverseMercatorRaw(): GeoRawProjection = js.native
  
  /**
    * Constructs a new CIELAB color with the specified l value and a = b = 0.
    *
    * @param l Lightness typically in the range [0, 100].
    * @param opacity Optional opacity value, defaults to 1.
    */
  def gray(l: Double): LabColor = js.native
  /**
    * Constructs a new CIELAB color with the specified l value and a = b = 0.
    *
    * @param l Lightness typically in the range [0, 100].
    * @param opacity Optional opacity value, defaults to 1.
    */
  def gray(l: Double, opacity: Double): LabColor = js.native
  
  def greatest[T](iterable: js.Iterable[T]): js.UndefOr[T] = js.native
  def greatest[T](iterable: js.Iterable[T], comparator: js.Function2[/* a */ T, /* b */ T, Double]): js.UndefOr[T] = js.native
  def greatest[T, U](iterable: js.Iterable[T], accessor: js.Function1[/* a */ T, U]): js.UndefOr[T] = js.native
  
  def greatestIndex[T](iterable: js.Iterable[T]): js.UndefOr[Double] = js.native
  def greatestIndex[T](iterable: js.Iterable[T], comparator: js.Function2[/* a */ T, /* b */ T, Double]): js.UndefOr[Double] = js.native
  def greatestIndex[T, U](iterable: js.Iterable[T], accessor: js.Function1[/* a */ T, U]): js.UndefOr[Double] = js.native
  
  def group[TObject, TKey](iterable: js.Iterable[TObject], key: js.Function1[/* value */ TObject, TKey]): Map[TKey, js.Array[TObject]] = js.native
  def group[TObject, TKey1, TKey2](
    iterable: js.Iterable[TObject],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2]
  ): Map[TKey1, Map[TKey2, js.Array[TObject]]] = js.native
  def group[TObject, TKey1, TKey2, TKey3](
    iterable: js.Iterable[TObject],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2],
    key3: js.Function1[/* value */ TObject, TKey3]
  ): Map[TKey1, Map[TKey2, Map[TKey3, js.Array[TObject]]]] = js.native
  
  def groups[TObject, TKey](iterable: js.Iterable[TObject], key: js.Function1[/* value */ TObject, TKey]): js.Array[js.Tuple2[TKey, js.Array[TObject]]] = js.native
  def groups[TObject, TKey1, TKey2](
    iterable: js.Iterable[TObject],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2]
  ): js.Array[js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, js.Array[TObject]]]]] = js.native
  def groups[TObject, TKey1, TKey2, TKey3](
    iterable: js.Iterable[TObject],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2],
    key3: js.Function1[/* value */ TObject, TKey3]
  ): js.Array[
    js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, js.Array[js.Tuple2[TKey3, js.Array[TObject]]]]]]
  ] = js.native
  
  def hcl(color: ColorCommonInstance): HCLColor = js.native
  /**
    * Converts the provided color instance and returns an HCL color.
    * The color instance is converted to the RGB color space using color.rgb and then converted to HCL.
    * (Colors already in the HCL color space skip the conversion to RGB,
    * and colors in the Lab color space are converted directly to HCL.)
    *
    * @param color A permissible color space instance.
    */
  def hcl(color: ColorSpaceObject): HCLColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning an HCL color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
    */
  def hcl(cssColorSpecifier: String): HCLColor = js.native
  /**
    * Constructs a new HCL color based on the specified channel values and opacity.
    *
    * @param h Hue channel value typically in [0, 360).
    * @param c Chroma channel value typically in [0, 230].
    * @param l Luminance channel value typically in the range [0, 100].
    * @param opacity Optional opacity value, defaults to 1.
    */
  def hcl(h: Double, c: Double, l: Double): HCLColor = js.native
  def hcl(h: Double, c: Double, l: Double, opacity: Double): HCLColor = js.native
  @JSName("hcl")
  val hcl_Original: HCLColorFactory = js.native
  
  def hierarchy[Datum](data: Datum): HierarchyNode[Datum] = js.native
  def hierarchy[Datum](data: Datum, children: js.Function1[/* d */ Datum, js.UndefOr[js.Iterable[Datum] | Null]]): HierarchyNode[Datum] = js.native
  
  def histogram(): HistogramGeneratorNumber[Double, Double] = js.native
  @JSName("histogram")
  def `histogram_DatumValue_UnionDate<undefined>_HistogramGeneratorDate`[Datum, Value /* <: js.UndefOr[js.Date] */](): HistogramGeneratorDate[Datum, Value] = js.native
  @JSName("histogram")
  def `histogram_DatumValue_UnionDouble<undefined>`[Datum, Value /* <: js.UndefOr[Double] */](): HistogramGeneratorNumber[Datum, Value] = js.native
  
  def hsl(color: ColorCommonInstance): HSLColor = js.native
  /**
    * Converts the provided color instance and returns an HSL color.
    * The color instance is converted to the RGB color space using color.rgb and then converted to HSL.
    * (Colors already in the HSL color space skip the conversion to RGB.)
    *
    * @param color A permissible color space instance.
    */
  def hsl(color: ColorSpaceObject): HSLColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning an HSL color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
    */
  def hsl(cssColorSpecifier: String): HSLColor = js.native
  /**
    * Constructs a new HSL color based on the specified channel values and opacity.
    *
    * @param h Hue channel value.
    * @param s Saturation channel value.
    * @param l Lightness channel value.
    * @param opacity Optional opacity value, defaults to 1.
    */
  def hsl(h: Double, s: Double, l: Double): HSLColor = js.native
  def hsl(h: Double, s: Double, l: Double, opacity: Double): HSLColor = js.native
  @JSName("hsl")
  val hsl_Original: HSLColorFactory = js.native
  
  def html(url: String): js.Promise[Document] = js.native
  def html(url: String, init: RequestInit): js.Promise[Document] = js.native
  
  def image(url: String): js.Promise[HTMLImageElement] = js.native
  def image(url: String, init: PartialHTMLImageElement): js.Promise[HTMLImageElement] = js.native
  
  def index[TObject, TKey](iterable: js.Iterable[TObject], key: js.Function1[/* value */ TObject, TKey]): Map[TKey, TObject] = js.native
  def index[TObject, TKey1, TKey2](
    iterable: js.Iterable[TObject],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2]
  ): Map[TKey1, Map[TKey2, TObject]] = js.native
  def index[TObject, TKey1, TKey2, TKey3](
    iterable: js.Iterable[TObject],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2],
    key3: js.Function1[/* value */ TObject, TKey3]
  ): Map[TKey1, Map[TKey2, Map[TKey3, TObject]]] = js.native
  
  def indexes[TObject, TKey](iterable: js.Iterable[TObject], key: js.Function1[/* value */ TObject, TKey]): js.Array[js.Tuple2[TKey, TObject]] = js.native
  def indexes[TObject, TKey1, TKey2](
    iterable: js.Iterable[TObject],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2]
  ): js.Array[js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, TObject]]]] = js.native
  def indexes[TObject, TKey1, TKey2, TKey3](
    iterable: js.Iterable[TObject],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2],
    key3: js.Function1[/* value */ TObject, TKey3]
  ): js.Array[
    js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, js.Array[js.Tuple2[TKey3, TObject]]]]]
  ] = js.native
  
  def interpolate(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolate(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolate(a: js.Any, b: Boolean): js.Function1[/* t */ Double, Boolean] = js.native
  def interpolate(a: js.Any, b: Null): js.Function1[/* t */ Double, Null] = js.native
  def interpolate(a: js.Array[Double], b: js.typedarray.DataView): js.Function1[/* t */ Double, js.typedarray.DataView] = js.native
  def interpolate(a: js.Array[Double], b: js.typedarray.Float32Array): js.Function1[/* t */ Double, js.typedarray.Float32Array] = js.native
  def interpolate(a: js.Array[Double], b: js.typedarray.Float64Array): js.Function1[/* t */ Double, js.typedarray.Float64Array] = js.native
  def interpolate(a: js.Array[Double], b: js.typedarray.Int16Array): js.Function1[/* t */ Double, js.typedarray.Int16Array] = js.native
  def interpolate(a: js.Array[Double], b: js.typedarray.Int32Array): js.Function1[/* t */ Double, js.typedarray.Int32Array] = js.native
  def interpolate(a: js.Array[Double], b: js.typedarray.Int8Array): js.Function1[/* t */ Double, js.typedarray.Int8Array] = js.native
  def interpolate(a: js.Array[Double], b: js.typedarray.Uint16Array): js.Function1[/* t */ Double, js.typedarray.Uint16Array] = js.native
  def interpolate(a: js.Array[Double], b: js.typedarray.Uint32Array): js.Function1[/* t */ Double, js.typedarray.Uint32Array] = js.native
  def interpolate(a: js.Array[Double], b: js.typedarray.Uint8Array): js.Function1[/* t */ Double, js.typedarray.Uint8Array] = js.native
  def interpolate(a: js.Array[Double], b: js.typedarray.Uint8ClampedArray): js.Function1[/* t */ Double, js.typedarray.Uint8ClampedArray] = js.native
  def interpolate(a: Double, b: Double): js.Function1[/* t */ Double, Double] = js.native
  def interpolate(a: Double, b: typingsSlinky.d3Interpolate.anon.ValueOf): js.Function1[/* t */ Double, Double] = js.native
  def interpolate(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolate(a: ToString, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolate(a: typingsSlinky.d3Interpolate.anon.ValueOf, b: Double): js.Function1[/* t */ Double, Double] = js.native
  def interpolate(a: typingsSlinky.d3Interpolate.anon.ValueOf, b: typingsSlinky.d3Interpolate.anon.ValueOf): js.Function1[/* t */ Double, Double] = js.native
  def interpolate(a: NumberArray, b: js.typedarray.DataView): js.Function1[/* t */ Double, js.typedarray.DataView] = js.native
  def interpolate(a: NumberArray, b: js.typedarray.Float32Array): js.Function1[/* t */ Double, js.typedarray.Float32Array] = js.native
  def interpolate(a: NumberArray, b: js.typedarray.Float64Array): js.Function1[/* t */ Double, js.typedarray.Float64Array] = js.native
  def interpolate(a: NumberArray, b: js.typedarray.Int16Array): js.Function1[/* t */ Double, js.typedarray.Int16Array] = js.native
  def interpolate(a: NumberArray, b: js.typedarray.Int32Array): js.Function1[/* t */ Double, js.typedarray.Int32Array] = js.native
  def interpolate(a: NumberArray, b: js.typedarray.Int8Array): js.Function1[/* t */ Double, js.typedarray.Int8Array] = js.native
  def interpolate(a: NumberArray, b: js.typedarray.Uint16Array): js.Function1[/* t */ Double, js.typedarray.Uint16Array] = js.native
  def interpolate(a: NumberArray, b: js.typedarray.Uint32Array): js.Function1[/* t */ Double, js.typedarray.Uint32Array] = js.native
  def interpolate(a: NumberArray, b: js.typedarray.Uint8Array): js.Function1[/* t */ Double, js.typedarray.Uint8Array] = js.native
  def interpolate(a: NumberArray, b: js.typedarray.Uint8ClampedArray): js.Function1[/* t */ Double, js.typedarray.Uint8ClampedArray] = js.native
  def interpolate(a: js.Date, b: js.Date): js.Function1[/* t */ Double, js.Date] = js.native
  def interpolate[U /* <: js.Object */](a: js.Any, b: U): js.Function1[/* t */ Double, U] = js.native
  def interpolate[U /* <: js.Array[_] */](a: js.Array[_], b: U): js.Function1[/* t */ Double, U] = js.native
  
  def interpolateArray(a: js.Array[Double], b: js.typedarray.DataView): js.Function1[/* t */ Double, js.typedarray.DataView] = js.native
  def interpolateArray(a: js.Array[Double], b: js.typedarray.Float32Array): js.Function1[/* t */ Double, js.typedarray.Float32Array] = js.native
  def interpolateArray(a: js.Array[Double], b: js.typedarray.Float64Array): js.Function1[/* t */ Double, js.typedarray.Float64Array] = js.native
  def interpolateArray(a: js.Array[Double], b: js.typedarray.Int16Array): js.Function1[/* t */ Double, js.typedarray.Int16Array] = js.native
  def interpolateArray(a: js.Array[Double], b: js.typedarray.Int32Array): js.Function1[/* t */ Double, js.typedarray.Int32Array] = js.native
  def interpolateArray(a: js.Array[Double], b: js.typedarray.Int8Array): js.Function1[/* t */ Double, js.typedarray.Int8Array] = js.native
  def interpolateArray(a: js.Array[Double], b: js.typedarray.Uint16Array): js.Function1[/* t */ Double, js.typedarray.Uint16Array] = js.native
  def interpolateArray(a: js.Array[Double], b: js.typedarray.Uint32Array): js.Function1[/* t */ Double, js.typedarray.Uint32Array] = js.native
  def interpolateArray(a: js.Array[Double], b: js.typedarray.Uint8Array): js.Function1[/* t */ Double, js.typedarray.Uint8Array] = js.native
  def interpolateArray(a: js.Array[Double], b: js.typedarray.Uint8ClampedArray): js.Function1[/* t */ Double, js.typedarray.Uint8ClampedArray] = js.native
  def interpolateArray(a: NumberArray, b: js.typedarray.DataView): js.Function1[/* t */ Double, js.typedarray.DataView] = js.native
  def interpolateArray(a: NumberArray, b: js.typedarray.Float32Array): js.Function1[/* t */ Double, js.typedarray.Float32Array] = js.native
  def interpolateArray(a: NumberArray, b: js.typedarray.Float64Array): js.Function1[/* t */ Double, js.typedarray.Float64Array] = js.native
  def interpolateArray(a: NumberArray, b: js.typedarray.Int16Array): js.Function1[/* t */ Double, js.typedarray.Int16Array] = js.native
  def interpolateArray(a: NumberArray, b: js.typedarray.Int32Array): js.Function1[/* t */ Double, js.typedarray.Int32Array] = js.native
  def interpolateArray(a: NumberArray, b: js.typedarray.Int8Array): js.Function1[/* t */ Double, js.typedarray.Int8Array] = js.native
  def interpolateArray(a: NumberArray, b: js.typedarray.Uint16Array): js.Function1[/* t */ Double, js.typedarray.Uint16Array] = js.native
  def interpolateArray(a: NumberArray, b: js.typedarray.Uint32Array): js.Function1[/* t */ Double, js.typedarray.Uint32Array] = js.native
  def interpolateArray(a: NumberArray, b: js.typedarray.Uint8Array): js.Function1[/* t */ Double, js.typedarray.Uint8Array] = js.native
  def interpolateArray(a: NumberArray, b: js.typedarray.Uint8ClampedArray): js.Function1[/* t */ Double, js.typedarray.Uint8ClampedArray] = js.native
  def interpolateArray[A /* <: js.Array[_] */](a: js.Array[_], b: A): ArrayInterpolator[A] = js.native
  
  def interpolateBasis(splineNodes: js.Array[Double]): js.Function1[/* t */ Double, Double] = js.native
  
  def interpolateBasisClosed(splineNodes: js.Array[Double]): js.Function1[/* t */ Double, Double] = js.native
  
  def interpolateBlues(t: Double): String = js.native
  
  def interpolateBrBG(t: Double): String = js.native
  
  def interpolateBuGn(t: Double): String = js.native
  
  def interpolateBuPu(t: Double): String = js.native
  
  def interpolateCividis(t: Double): String = js.native
  
  def interpolateCool(t: Double): String = js.native
  
  def interpolateCubehelix(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateCubehelix(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateCubehelix(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateCubehelix(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  
  def interpolateCubehelixDefault(t: Double): String = js.native
  
  def interpolateCubehelixLong(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateCubehelixLong(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateCubehelixLong(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateCubehelixLong(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  @JSName("interpolateCubehelixLong")
  val interpolateCubehelixLong_Original: ColorGammaInterpolationFactory = js.native
  
  @JSName("interpolateCubehelix")
  val interpolateCubehelix_Original: ColorGammaInterpolationFactory = js.native
  
  def interpolateDate(a: js.Date, b: js.Date): js.Function1[/* t */ Double, js.Date] = js.native
  
  def interpolateDiscrete[T](values: js.Array[T]): js.Function1[/* t */ Double, T] = js.native
  
  def interpolateGnBu(t: Double): String = js.native
  
  def interpolateGreens(t: Double): String = js.native
  
  def interpolateGreys(t: Double): String = js.native
  
  def interpolateHcl(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateHcl(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateHcl(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateHcl(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  
  def interpolateHclLong(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateHclLong(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateHclLong(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateHclLong(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  
  def interpolateHsl(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateHsl(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateHsl(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateHsl(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  
  def interpolateHslLong(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateHslLong(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateHslLong(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateHslLong(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  
  def interpolateHue(a: Double, b: Double): js.Function1[/* t */ Double, Double] = js.native
  
  def interpolateInferno(t: Double): String = js.native
  
  def interpolateLab(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateLab(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateLab(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateLab(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  
  def interpolateMagma(t: Double): String = js.native
  
  def interpolateNumber(a: Double, b: Double): js.Function1[/* t */ Double, Double] = js.native
  def interpolateNumber(a: Double, b: typingsSlinky.d3Interpolate.anon.ValueOf): js.Function1[/* t */ Double, Double] = js.native
  def interpolateNumber(a: typingsSlinky.d3Interpolate.anon.ValueOf, b: Double): js.Function1[/* t */ Double, Double] = js.native
  def interpolateNumber(a: typingsSlinky.d3Interpolate.anon.ValueOf, b: typingsSlinky.d3Interpolate.anon.ValueOf): js.Function1[/* t */ Double, Double] = js.native
  
  def interpolateNumberArray(a: js.Array[Double], b: js.Array[Double]): js.Function1[/* t */ Double, js.Array[Double]] = js.native
  def interpolateNumberArray(a: js.Array[Double], b: js.typedarray.DataView): js.Function1[/* t */ Double, js.typedarray.DataView] = js.native
  def interpolateNumberArray(a: js.Array[Double], b: js.typedarray.Float32Array): js.Function1[/* t */ Double, js.typedarray.Float32Array] = js.native
  def interpolateNumberArray(a: js.Array[Double], b: js.typedarray.Float64Array): js.Function1[/* t */ Double, js.typedarray.Float64Array] = js.native
  def interpolateNumberArray(a: js.Array[Double], b: js.typedarray.Int16Array): js.Function1[/* t */ Double, js.typedarray.Int16Array] = js.native
  def interpolateNumberArray(a: js.Array[Double], b: js.typedarray.Int32Array): js.Function1[/* t */ Double, js.typedarray.Int32Array] = js.native
  def interpolateNumberArray(a: js.Array[Double], b: js.typedarray.Int8Array): js.Function1[/* t */ Double, js.typedarray.Int8Array] = js.native
  def interpolateNumberArray(a: js.Array[Double], b: js.typedarray.Uint16Array): js.Function1[/* t */ Double, js.typedarray.Uint16Array] = js.native
  def interpolateNumberArray(a: js.Array[Double], b: js.typedarray.Uint32Array): js.Function1[/* t */ Double, js.typedarray.Uint32Array] = js.native
  def interpolateNumberArray(a: js.Array[Double], b: js.typedarray.Uint8Array): js.Function1[/* t */ Double, js.typedarray.Uint8Array] = js.native
  def interpolateNumberArray(a: js.Array[Double], b: js.typedarray.Uint8ClampedArray): js.Function1[/* t */ Double, js.typedarray.Uint8ClampedArray] = js.native
  def interpolateNumberArray(a: NumberArray, b: js.Array[Double]): js.Function1[/* t */ Double, js.Array[Double]] = js.native
  def interpolateNumberArray(a: NumberArray, b: js.typedarray.DataView): js.Function1[/* t */ Double, js.typedarray.DataView] = js.native
  def interpolateNumberArray(a: NumberArray, b: js.typedarray.Float32Array): js.Function1[/* t */ Double, js.typedarray.Float32Array] = js.native
  def interpolateNumberArray(a: NumberArray, b: js.typedarray.Float64Array): js.Function1[/* t */ Double, js.typedarray.Float64Array] = js.native
  def interpolateNumberArray(a: NumberArray, b: js.typedarray.Int16Array): js.Function1[/* t */ Double, js.typedarray.Int16Array] = js.native
  def interpolateNumberArray(a: NumberArray, b: js.typedarray.Int32Array): js.Function1[/* t */ Double, js.typedarray.Int32Array] = js.native
  def interpolateNumberArray(a: NumberArray, b: js.typedarray.Int8Array): js.Function1[/* t */ Double, js.typedarray.Int8Array] = js.native
  def interpolateNumberArray(a: NumberArray, b: js.typedarray.Uint16Array): js.Function1[/* t */ Double, js.typedarray.Uint16Array] = js.native
  def interpolateNumberArray(a: NumberArray, b: js.typedarray.Uint32Array): js.Function1[/* t */ Double, js.typedarray.Uint32Array] = js.native
  def interpolateNumberArray(a: NumberArray, b: js.typedarray.Uint8Array): js.Function1[/* t */ Double, js.typedarray.Uint8Array] = js.native
  def interpolateNumberArray(a: NumberArray, b: js.typedarray.Uint8ClampedArray): js.Function1[/* t */ Double, js.typedarray.Uint8ClampedArray] = js.native
  
  def interpolateObject[U /* <: js.Object */](a: js.Any, b: U): js.Function1[/* t */ Double, U] = js.native
  
  def interpolateOrRd(t: Double): String = js.native
  
  def interpolateOranges(t: Double): String = js.native
  
  def interpolatePRGn(t: Double): String = js.native
  
  def interpolatePiYG(t: Double): String = js.native
  
  def interpolatePlasma(t: Double): String = js.native
  
  def interpolatePuBu(t: Double): String = js.native
  
  def interpolatePuBuGn(t: Double): String = js.native
  
  def interpolatePuOr(t: Double): String = js.native
  
  def interpolatePuRd(t: Double): String = js.native
  
  def interpolatePurples(t: Double): String = js.native
  
  def interpolateRainbow(t: Double): String = js.native
  
  def interpolateRdBu(t: Double): String = js.native
  
  def interpolateRdGy(t: Double): String = js.native
  
  def interpolateRdPu(t: Double): String = js.native
  
  def interpolateRdYlBu(t: Double): String = js.native
  
  def interpolateRdYlGn(t: Double): String = js.native
  
  def interpolateReds(t: Double): String = js.native
  
  def interpolateRgb(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateRgb(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateRgb(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateRgb(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  
  def interpolateRgbBasis(colors: js.Array[String | ColorCommonInstance]): js.Function1[/* t */ Double, String] = js.native
  
  def interpolateRgbBasisClosed(colors: js.Array[String | ColorCommonInstance]): js.Function1[/* t */ Double, String] = js.native
  
  @JSName("interpolateRgb")
  val interpolateRgb_Original: ColorGammaInterpolationFactory = js.native
  
  def interpolateRound(a: Double, b: Double): js.Function1[/* t */ Double, Double] = js.native
  def interpolateRound(a: Double, b: typingsSlinky.d3Interpolate.anon.ValueOf): js.Function1[/* t */ Double, Double] = js.native
  def interpolateRound(a: typingsSlinky.d3Interpolate.anon.ValueOf, b: Double): js.Function1[/* t */ Double, Double] = js.native
  def interpolateRound(a: typingsSlinky.d3Interpolate.anon.ValueOf, b: typingsSlinky.d3Interpolate.anon.ValueOf): js.Function1[/* t */ Double, Double] = js.native
  
  def interpolateSinebow(t: Double): String = js.native
  
  def interpolateSpectral(t: Double): String = js.native
  
  def interpolateString(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateString(a: String, b: ToString): js.Function1[/* t */ Double, String] = js.native
  def interpolateString(a: ToString, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateString(a: ToString, b: ToString): js.Function1[/* t */ Double, String] = js.native
  
  def interpolateTransformCss(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  
  def interpolateTransformSvg(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  
  def interpolateTurbo(t: Double): String = js.native
  
  def interpolateViridis(t: Double): String = js.native
  
  def interpolateWarm(t: Double): String = js.native
  
  def interpolateYlGn(t: Double): String = js.native
  
  def interpolateYlGnBu(t: Double): String = js.native
  
  def interpolateYlOrBr(t: Double): String = js.native
  
  def interpolateYlOrRd(t: Double): String = js.native
  
  def interpolateZoom(a: ZoomView, b: ZoomView): ZoomInterpolator = js.native
  
  def interrupt(node: BaseType): Unit = js.native
  def interrupt(node: BaseType, name: String): Unit = js.native
  
  def intersection[T](iterables: js.Iterable[T]*): Set[T] = js.native
  
  def interval(callback: js.Function1[/* elapsed */ Double, Unit]): Timer_ = js.native
  def interval(callback: js.Function1[/* elapsed */ Double, Unit], delay: js.UndefOr[scala.Nothing], time: Double): Timer_ = js.native
  def interval(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double): Timer_ = js.native
  def interval(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double, time: Double): Timer_ = js.native
  
  def isoFormat(date: js.Date): String = js.native
  
  def isoParse(dateString: String): js.Date | Null = js.native
  
  def json[ParsedJSONObject /* <: js.Any */](url: String): js.Promise[js.UndefOr[ParsedJSONObject]] = js.native
  def json[ParsedJSONObject /* <: js.Any */](url: String, init: RequestInit): js.Promise[js.UndefOr[ParsedJSONObject]] = js.native
  
  def lab(color: ColorCommonInstance): LabColor = js.native
  /**
    * Converts the provided color instance and returns a Lab color.
    * The color instance is converted to the RGB color space using color.rgb and then converted to CIELAB.
    * (Colors already in the Lab color space skip the conversion to RGB,
    * and colors in the HCL color space are converted directly to CIELAB.)
    *
    * @param color A permissible color space instance.
    */
  def lab(color: ColorSpaceObject): LabColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning a Lab color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
    */
  def lab(cssColorSpecifier: String): LabColor = js.native
  /**
    * Constructs a new CIELAB color based on the specified channel values and opacity.
    *
    * @param l Lightness typically in the range [0, 100].
    * @param a Position between red/magenta and green typically in [-160, +160].
    * @param b Position between yellow and blue typically in [-160, +160].
    * @param opacity Optional opacity value, defaults to 1.
    */
  def lab(l: Double, a: Double, b: Double): LabColor = js.native
  def lab(l: Double, a: Double, b: Double, opacity: Double): LabColor = js.native
  @JSName("lab")
  val lab_Original: LabColorFactory = js.native
  
  def lch(color: ColorCommonInstance): HCLColor = js.native
  /**
    * Converts the provided color instance and returns an HCL color.
    * The color instance is converted to the RGB color space using color.rgb and then converted to HCL.
    * (Colors already in the HCL color space skip the conversion to RGB,
    * and colors in the Lab color space are converted directly to HCL.)
    *
    * @param color A permissible color space instance.
    */
  def lch(color: ColorSpaceObject): HCLColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning an HCL color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS color Module Level 3 specifier string.
    */
  def lch(cssColorSpecifier: String): HCLColor = js.native
  /**
    * Constructs a new HCL color based on the specified channel values and opacity.
    *
    * @param l Luminance channel value typically in the range [0, 100].
    * @param c Chroma channel value typically in [0, 230].
    * @param h Hue channel value typically in [0, 360).
    * @param opacity Optional opacity value, defaults to 1.
    */
  def lch(l: Double, c: Double, h: Double): HCLColor = js.native
  def lch(l: Double, c: Double, h: Double, opacity: Double): HCLColor = js.native
  
  def least[T](iterable: js.Iterable[T]): js.UndefOr[T] = js.native
  def least[T](iterable: js.Iterable[T], comparator: js.Function2[/* a */ T, /* b */ T, Double]): js.UndefOr[T] = js.native
  def least[T, U](iterable: js.Iterable[T], accessor: js.Function1[/* a */ T, U]): js.UndefOr[T] = js.native
  
  def leastIndex[T](iterable: js.Iterable[T]): js.UndefOr[Double] = js.native
  def leastIndex[T](iterable: js.Iterable[T], comparator: js.Function2[/* a */ T, /* b */ T, Double]): js.UndefOr[Double] = js.native
  def leastIndex[T, U](iterable: js.Iterable[T], accessor: js.Function1[/* a */ T, U]): js.UndefOr[Double] = js.native
  
  def line[Datum](): Line_[Datum] = js.native
  def line[Datum](
    x: js.UndefOr[scala.Nothing],
    y: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Line_[Datum] = js.native
  def line[Datum](x: js.UndefOr[scala.Nothing], y: Double): Line_[Datum] = js.native
  def line[Datum](x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]): Line_[Datum] = js.native
  def line[Datum](
    x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double],
    y: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]
  ): Line_[Datum] = js.native
  def line[Datum](x: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double], y: Double): Line_[Datum] = js.native
  def line[Datum](x: Double): Line_[Datum] = js.native
  def line[Datum](x: Double, y: js.Function3[/* d */ Datum, /* index */ Double, /* data */ js.Array[Datum], Double]): Line_[Datum] = js.native
  def line[Datum](x: Double, y: Double): Line_[Datum] = js.native
  
  def lineRadial(): LineRadial_[js.Tuple2[Double, Double]] = js.native
  @JSName("lineRadial")
  def lineRadial_Datum[Datum](): LineRadial_[Datum] = js.native
  
  def linkHorizontal(): Link[_, DefaultLinkObject, js.Tuple2[Double, Double]] = js.native
  @JSName("linkHorizontal")
  def linkHorizontal_LinkDatumNodeDatum[LinkDatum, NodeDatum](): Link[_, LinkDatum, NodeDatum] = js.native
  @JSName("linkHorizontal")
  def linkHorizontal_ThisLinkDatumNodeDatum[This, LinkDatum, NodeDatum](): Link[This, LinkDatum, NodeDatum] = js.native
  
  def linkRadial(): LinkRadial_[_, DefaultLinkObject, js.Tuple2[Double, Double]] = js.native
  @JSName("linkRadial")
  def linkRadial_LinkDatumNodeDatum[LinkDatum, NodeDatum](): LinkRadial_[_, LinkDatum, NodeDatum] = js.native
  @JSName("linkRadial")
  def linkRadial_ThisLinkDatumNodeDatum[This, LinkDatum, NodeDatum](): LinkRadial_[This, LinkDatum, NodeDatum] = js.native
  
  def linkVertical(): Link[_, DefaultLinkObject, js.Tuple2[Double, Double]] = js.native
  @JSName("linkVertical")
  def linkVertical_LinkDatumNodeDatum[LinkDatum, NodeDatum](): Link[_, LinkDatum, NodeDatum] = js.native
  @JSName("linkVertical")
  def linkVertical_ThisLinkDatumNodeDatum[This, LinkDatum, NodeDatum](): Link[This, LinkDatum, NodeDatum] = js.native
  
  def local[T](): Local_[T] = js.native
  
  def map[T, U](
    iterable: js.Iterable[T],
    mapper: js.Function3[/* value */ T, /* index */ Double, /* iterable */ js.Iterable[T], U]
  ): js.Array[U] = js.native
  
  def matcher(selector: String): js.ThisFunction0[/* this */ BaseType, Boolean] = js.native
  
  def max(iterable: js.Iterable[String]): js.UndefOr[String] = js.native
  def max[T](
    iterable: js.Iterable[T],
    accessor: js.Function3[
      /* datum */ T, 
      /* index */ Double, 
      /* array */ js.Iterable[T], 
      js.UndefOr[String | Null]
    ]
  ): js.UndefOr[String] = js.native
  
  def maxIndex[T](iterable: js.Iterable[T]): Double = js.native
  def maxIndex[TDatum, U](
    iterable: js.Iterable[TDatum],
    accessor: js.Function3[
      /* datum */ TDatum, 
      /* index */ Double, 
      /* array */ js.Iterable[TDatum], 
      js.UndefOr[U | Null]
    ]
  ): Double = js.native
  
  @JSName("max")
  def max_TU_Numeric[T, U /* <: Numeric */](
    iterable: js.Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ js.Iterable[T], js.UndefOr[U | Null]]
  ): js.UndefOr[U] = js.native
  @JSName("max")
  def max_T_Numeric[T /* <: Numeric */](iterable: js.Iterable[T]): js.UndefOr[T] = js.native
  
  def mean[T /* <: Numeric */](iterable: js.Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = js.native
  def mean[T](
    iterable: js.Iterable[T],
    accessor: js.Function3[
      /* datum */ T, 
      /* index */ Double, 
      /* array */ js.Iterable[T], 
      js.UndefOr[Double | Null]
    ]
  ): js.UndefOr[Double] = js.native
  
  def median[T /* <: Numeric */](iterable: js.Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = js.native
  def median[T](
    iterable: js.Iterable[T],
    accessor: js.Function3[/* element */ T, /* i */ Double, /* array */ js.Iterable[T], js.UndefOr[Double | Null]]
  ): js.UndefOr[Double] = js.native
  
  def merge[T](iterables: js.Iterable[js.Iterable[T]]): js.Array[T] = js.native
  
  def min(iterable: js.Iterable[String]): js.UndefOr[String] = js.native
  def min[T](
    iterable: js.Iterable[T],
    accessor: js.Function3[
      /* datum */ T, 
      /* index */ Double, 
      /* array */ js.Iterable[T], 
      js.UndefOr[String | Null]
    ]
  ): js.UndefOr[String] = js.native
  
  def minIndex[T](iterable: js.Iterable[T]): Double = js.native
  def minIndex[TDatum, U](
    iterable: js.Iterable[TDatum],
    accessor: js.Function3[
      /* datum */ TDatum, 
      /* index */ Double, 
      /* array */ js.Iterable[TDatum], 
      js.UndefOr[U | Null]
    ]
  ): Double = js.native
  
  @JSName("min")
  def min_TU_Numeric[T, U /* <: Numeric */](
    iterable: js.Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ js.Iterable[T], js.UndefOr[U | Null]]
  ): js.UndefOr[U] = js.native
  @JSName("min")
  def min_T_Numeric[T /* <: Numeric */](iterable: js.Iterable[T]): js.UndefOr[T] = js.native
  
  def namespace(prefixedLocal: String): NamespaceLocalObject | String = js.native
  
  val namespaces: NamespaceMap = js.native
  
  def nice(start: Double, stop: Double, count: Double): js.Tuple2[Double, Double] = js.native
  
  def now(): Double = js.native
  
  def pack[Datum](): PackLayout[Datum] = js.native
  
  def packEnclose[Datum /* <: PackCircle */](circles: js.Array[Datum]): PackCircle = js.native
  
  def packSiblings[Datum /* <: PackRadius */](circles: js.Array[Datum]): js.Array[Datum with PackCircle] = js.native
  
  def pairs[T](iterable: js.Iterable[T]): js.Array[js.Tuple2[T, T]] = js.native
  def pairs[T, U](iterable: js.Iterable[T], reducer: js.Function2[/* a */ T, /* b */ T, U]): js.Array[U] = js.native
  
  def partition[Datum](): PartitionLayout[Datum] = js.native
  
  def path(): Path_ = js.native
  
  def permute[T](source: NumberDictionary[T], keys: Iterable[Double]): js.Array[T] = js.native
  def permute[T, K /* <: /* keyof T */ String */](source: T, keys: Iterable[K]): js.Array[
    /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
  ] = js.native
  
  def pie(): Pie_[_, Double | typingsSlinky.d3Shape.anon.ValueOf] = js.native
  @JSName("pie")
  def pie_Datum[Datum](): Pie_[_, Datum] = js.native
  @JSName("pie")
  def pie_ThisDatum[This, Datum](): Pie_[This, Datum] = js.native
  
  def piecewise(
    interpolate: js.Function2[/* a */ ZoomView, /* b */ ZoomView, ZoomInterpolator],
    values: js.Array[ZoomView]
  ): ZoomInterpolator = js.native
  def piecewise(values: js.Array[ZoomView]): ZoomInterpolator = js.native
  @JSName("piecewise")
  def piecewise_A_ArrayWildcard_ArrayInterpolator[A /* <: js.Array[_] */](
    interpolate: js.Function2[/* a */ js.Array[_], /* b */ A, ArrayInterpolator[A]],
    values: js.Array[A]
  ): ArrayInterpolator[A] = js.native
  @JSName("piecewise")
  def piecewise_A_ArrayWildcard_ArrayInterpolator[A /* <: js.Array[_] */](values: js.Array[A]): ArrayInterpolator[A] = js.native
  @JSName("piecewise")
  def piecewise_TDataInterpolator_Function1[TData, Interpolator](interpolate: js.Function2[/* a */ TData, /* b */ TData, Interpolator], values: js.Array[TData]): js.Function1[/* t */ Double, _] = js.native
  @JSName("piecewise")
  def piecewise_TData_Function1[TData](values: js.Array[TData]): js.Function1[/* t */ Double, _] = js.native
  
  def pointRadial(angle: Double, radius: Double): js.Tuple2[Double, Double] = js.native
  
  def pointer(event: js.Any): js.Tuple2[Double, Double] = js.native
  def pointer(event: js.Any, target: js.Any): js.Tuple2[Double, Double] = js.native
  
  def pointers(event: js.Any): js.Array[js.Tuple2[Double, Double]] = js.native
  def pointers(event: js.Any, target: js.Any): js.Array[js.Tuple2[Double, Double]] = js.native
  
  def polygonArea(polygon: js.Array[js.Tuple2[Double, Double]]): Double = js.native
  
  def polygonCentroid(polygon: js.Array[js.Tuple2[Double, Double]]): js.Tuple2[Double, Double] = js.native
  
  def polygonContains(polygon: js.Array[js.Tuple2[Double, Double]], point: js.Tuple2[Double, Double]): Boolean = js.native
  
  def polygonHull(points: js.Array[js.Tuple2[Double, Double]]): (js.Array[js.Tuple2[Double, Double]]) | Null = js.native
  
  def polygonLength(polygon: js.Array[js.Tuple2[Double, Double]]): Double = js.native
  
  def precisionFixed(step: Double): Double = js.native
  
  def precisionPrefix(step: Double, value: Double): Double = js.native
  
  def precisionRound(step: Double, max: Double): Double = js.native
  
  def quadtree[T](): Quadtree_[T] = js.native
  def quadtree[T](data: js.Array[T]): Quadtree_[T] = js.native
  def quadtree[T](data: js.Array[T], x: js.UndefOr[scala.Nothing], y: js.Function1[/* d */ T, Double]): Quadtree_[T] = js.native
  def quadtree[T](data: js.Array[T], x: js.Function1[/* d */ T, Double]): Quadtree_[T] = js.native
  def quadtree[T](data: js.Array[T], x: js.Function1[/* d */ T, Double], y: js.Function1[/* d */ T, Double]): Quadtree_[T] = js.native
  
  def quantile[T /* <: Numeric */](iterable: js.Iterable[js.UndefOr[T | Null]], p: Double): js.UndefOr[Double] = js.native
  def quantile[T](
    iterable: js.Iterable[T],
    p: Double,
    accessor: js.Function3[/* element */ T, /* i */ Double, /* array */ js.Iterable[T], js.UndefOr[Double | Null]]
  ): js.UndefOr[Double] = js.native
  
  def quantileSorted[T /* <: Numeric */](array: js.Array[js.UndefOr[T | Null]], p: Double): js.UndefOr[Double] = js.native
  def quantileSorted[T](
    array: js.Array[T],
    p: Double,
    accessor: js.Function3[/* element */ T, /* i */ Double, /* array */ js.Array[T], js.UndefOr[Double | Null]]
  ): js.UndefOr[Double] = js.native
  
  def quantize[T](interpolator: js.Function1[/* t */ Double, T], n: Double): js.Array[T] = js.native
  
  def quickselect[T](array: ArrayLike[T], k: Double): js.Array[T] = js.native
  def quickselect[T](array: ArrayLike[T], k: Double, left: Double): js.Array[T] = js.native
  def quickselect[T](array: ArrayLike[T], k: Double, left: Double, right: Double): js.Array[T] = js.native
  def quickselect[T](
    array: ArrayLike[T],
    k: Double,
    left: Double,
    right: Double,
    compare: js.Function2[/* a */ js.UndefOr[Primitive], /* b */ js.UndefOr[Primitive], Double]
  ): js.Array[T] = js.native
  
  def radialArea(): RadialArea_[js.Tuple2[Double, Double]] = js.native
  @JSName("radialArea")
  def radialArea_Datum[Datum](): RadialArea_[Datum] = js.native
  
  def radialLine(): RadialLine_[js.Tuple2[Double, Double]] = js.native
  @JSName("radialLine")
  def radialLine_Datum[Datum](): RadialLine_[Datum] = js.native
  
  /**
    * Returns a function for generating random numbers with a Bates distribution with n independent variables.
    * The case of fractional n is handled as with d3.randomIrwinHall, and d3.randomBates(0) is equivalent to d3.randomUniform().
    *
    * @param n Number of independent random variables to use.
    */
  def randomBates(n: Double): js.Function0[Double] = js.native
  @JSName("randomBates")
  val randomBates_Original: RandomBates_ = js.native
  
  /**
    * Returns a function for generating either 1 or 0 according to a Bernoulli distribution with 1 being returned with success probability p and 0 with failure probability q = 1 - p.
    * The value p is in the range [0, 1].
    *
    * @param p p
    */
  def randomBernoulli(p: Double): js.Function0[Double] = js.native
  @JSName("randomBernoulli")
  val randomBernoulli_Original: RandomBernoulli_ = js.native
  
  /**
    * Returns a function for generating random numbers with a beta distribution with alpha and beta shape parameters, which must both be positive.
    *
    * @param alpha Shape parameter
    * @param beta Shape paramter
    */
  def randomBeta(alpha: Double, beta: Double): js.Function0[Double] = js.native
  @JSName("randomBeta")
  val randomBeta_Original: RandomBeta_ = js.native
  
  /**
    * Returns a function for generating numbers with a geometric distribution with success probability p.
    * The value p is in the range (0, 1].
    *
    * @param p Success probability
    */
  def randomBinomial(p: Double): js.Function0[Double] = js.native
  @JSName("randomBinomial")
  val randomBinomial_Original: RandomBinomial_ = js.native
  
  /**
    * Returns a function for generating random numbers with a Cauchy distribution.
    * a and b have the same meanings and default values as in d3.randomWeibull.
    *
    * @param a Location parameter
    * @param b Scale parameter
    */
  def randomCauchy(): js.Function0[Double] = js.native
  def randomCauchy(a: js.UndefOr[scala.Nothing], b: Double): js.Function0[Double] = js.native
  def randomCauchy(a: Double): js.Function0[Double] = js.native
  def randomCauchy(a: Double, b: Double): js.Function0[Double] = js.native
  @JSName("randomCauchy")
  val randomCauchy_Original: RandomCauchy_ = js.native
  
  /**
    * Returns a function for generating random numbers with an exponential distribution with the rate lambda;
    * equivalent to time between events in a Poisson process with a mean of 1 / lambda.
    *
    * @param lambda Expected time between events.
    */
  def randomExponential(lambda: Double): js.Function0[Double] = js.native
  @JSName("randomExponential")
  val randomExponential_Original: RandomExponential_ = js.native
  
  /**
    * Returns a function for generating random numbers with a gamma distribution with k the shape parameter and theta the scale parameter.
    * The value k must be a positive value; if theta is not specified, it defaults to 1.
    *
    * @param k Shape parameter
    * @param theta Scale paramter
    */
  def randomGamma(k: Double): js.Function0[Double] = js.native
  def randomGamma(k: Double, theta: Double): js.Function0[Double] = js.native
  @JSName("randomGamma")
  val randomGamma_Original: RandomGamma_ = js.native
  
  /**
    * Returns a function for generating numbers with a geometric distribution with success probability p.
    * The value p is in the range [0, 1].
    *
    * @param p Success probability
    */
  def randomGeometric(p: Double): js.Function0[Double] = js.native
  @JSName("randomGeometric")
  val randomGeometric_Original: RandomGeometric_ = js.native
  
  /**
    * Returns a function for generating random integers with a uniform distribution.
    * The minimum allowed value of a returned number is ⌊min⌋ (inclusive), and the maximum is ⌊max - 1⌋ (inclusive)
    * Min defaults to 0.
    *
    * @param max The maximum allowed value of a returned number.
    */
  def randomInt(max: Double): js.Function0[Double] = js.native
  /**
    * Returns a function for generating random integers with a uniform distribution.
    * The minimum allowed value of a returned number is ⌊min⌋ (inclusive), and the maximum is ⌊max - 1⌋ (inclusive)
    *
    * @param min The minimum allowed value of a returned number.
    * @param max The maximum allowed value of a returned number.
    */
  // tslint:disable-next-line:unified-signatures
  def randomInt(min: Double, max: Double): js.Function0[Double] = js.native
  @JSName("randomInt")
  val randomInt_Original: RandomInt_ = js.native
  
  /**
    * Returns a function for generating random numbers with an Irwin–Hall distribution with n independent variables.
    * If the fractional part of n is non-zero, this is treated as adding d3.randomUniform() times that fractional part to the integral part.
    *
    * @param n Number of independent random variables to use.
    */
  def randomIrwinHall(n: Double): js.Function0[Double] = js.native
  @JSName("randomIrwinHall")
  val randomIrwinHall_Original: RandomIrwinHall_ = js.native
  
  def randomLcg(): js.Function0[Double] = js.native
  def randomLcg(seed: Double): js.Function0[Double] = js.native
  
  /**
    * Returns a function for generating random numbers with a log-normal distribution. The expected value of the random variable’s natural logarithm is mu,
    * with the given standard deviation sigma. If mu is not specified, it defaults to 0; if sigma is not specified, it defaults to 1.
    *
    * @param mu Expected value, defaults to 0.
    * @param sigma Standard deviation, defaults to 1.
    */
  def randomLogNormal(): js.Function0[Double] = js.native
  def randomLogNormal(mu: js.UndefOr[scala.Nothing], sigma: Double): js.Function0[Double] = js.native
  def randomLogNormal(mu: Double): js.Function0[Double] = js.native
  def randomLogNormal(mu: Double, sigma: Double): js.Function0[Double] = js.native
  @JSName("randomLogNormal")
  val randomLogNormal_Original: RandomLogNormal_ = js.native
  
  /**
    * Returns a function for generating random numbers with a logistic distribution.
    * a and b have the same meanings and default values as in d3.randomWeibull.
    *
    * @param a Location parameter
    * @param b Scale parameter
    */
  def randomLogistic(): js.Function0[Double] = js.native
  def randomLogistic(a: js.UndefOr[scala.Nothing], b: Double): js.Function0[Double] = js.native
  def randomLogistic(a: Double): js.Function0[Double] = js.native
  def randomLogistic(a: Double, b: Double): js.Function0[Double] = js.native
  @JSName("randomLogistic")
  val randomLogistic_Original: RandomLogistic_ = js.native
  
  /**
    * Returns a function for generating random numbers with a normal (Gaussian) distribution.
    * The expected value of the generated numbers is mu, with the given standard deviation sigma.
    * If mu is not specified, it defaults to 0; if sigma is not specified, it defaults to 1.
    *
    * @param mu Expected value, defaults to 0.
    * @param sigma Standard deviation, defaults to 1.
    */
  def randomNormal(): js.Function0[Double] = js.native
  def randomNormal(mu: js.UndefOr[scala.Nothing], sigma: Double): js.Function0[Double] = js.native
  def randomNormal(mu: Double): js.Function0[Double] = js.native
  def randomNormal(mu: Double, sigma: Double): js.Function0[Double] = js.native
  @JSName("randomNormal")
  val randomNormal_Original: RandomNormal_ = js.native
  
  /**
    * Returns a function for generating random numbers with a Pareto distribution with the shape alpha.
    * The value alpha must be a positive value.
    *
    * @param alpha alpha
    */
  def randomPareto(alpha: Double): js.Function0[Double] = js.native
  @JSName("randomPareto")
  val randomPareto_Original: RandomPareto_ = js.native
  
  /**
    * Returns a function for generating random numbers with a Poisson distribution with mean lambda.
    *
    * @param lambda Mean
    */
  def randomPoisson(lambda: Double): js.Function0[Double] = js.native
  @JSName("randomPoisson")
  val randomPoisson_Original: RandomPoisson_ = js.native
  
  /**
    * Returns a function for generating random numbers with a uniform distribution.
    * The minimum allowed value of a returned number is min (inclusive), and the maximum is max (exclusive).
    * Min defaults to 0; if max is not specified, it defaults to 1.
    *
    * @param max The maximum allowed value of a returned number, defaults to 1.
    */
  def randomUniform(): js.Function0[Double] = js.native
  def randomUniform(max: Double): js.Function0[Double] = js.native
  /**
    * Returns a function for generating random numbers with a uniform distribution.
    * The minimum allowed value of a returned number is min (inclusive), and the maximum is max (exclusive).
    *
    * @param min The minimum allowed value of a returned number.
    * @param max The maximum allowed value of a returned number.
    */
  // tslint:disable-next-line:unified-signatures
  def randomUniform(min: Double, max: Double): js.Function0[Double] = js.native
  @JSName("randomUniform")
  val randomUniform_Original: RandomUniform_ = js.native
  
  /**
    * Returns a function for generating random numbers with one of the generalized extreme value distributions, depending on k:
    * If k is positive, the Weibull distribution with shape parameter k
    * If k is zero, the Gumbel distribution
    * If k is negative, the Fréchet distribution with shape parameter −k
    * In all three cases, a is the location parameter and b is the scale parameter.
    * If a is not specified, it defaults to 0; if b is not specified, it defaults to 1.
    *
    * @param k Shape parameter
    * @param a Location parameter
    * @param b Scale parameter
    */
  def randomWeibull(k: Double): js.Function0[Double] = js.native
  def randomWeibull(k: Double, a: js.UndefOr[scala.Nothing], b: Double): js.Function0[Double] = js.native
  def randomWeibull(k: Double, a: Double): js.Function0[Double] = js.native
  def randomWeibull(k: Double, a: Double, b: Double): js.Function0[Double] = js.native
  @JSName("randomWeibull")
  val randomWeibull_Original: RandomWeibull_ = js.native
  
  def range(start: Double, stop: Double): js.Array[Double] = js.native
  def range(start: Double, stop: Double, step: Double): js.Array[Double] = js.native
  def range(stop: Double): js.Array[Double] = js.native
  
  def reduce[T](
    iterable: js.Iterable[T],
    reducer: js.Function4[
      /* previousValue */ T, 
      /* currentValue */ T, 
      /* currentIndex */ Double, 
      /* iterable */ js.Iterable[T], 
      T
    ]
  ): T = js.native
  def reduce[T](
    iterable: js.Iterable[T],
    reducer: js.Function4[
      /* previousValue */ T, 
      /* currentValue */ T, 
      /* currentIndex */ Double, 
      /* iterable */ js.Iterable[T], 
      T
    ],
    initialValue: T
  ): T = js.native
  @JSName("reduce")
  def reduce_TU_U[T, U](
    iterable: js.Iterable[T],
    reducer: js.Function4[
      /* previousValue */ U, 
      /* currentValue */ T, 
      /* currentIndex */ Double, 
      /* iterable */ js.Iterable[T], 
      U
    ],
    initialValue: U
  ): U = js.native
  
  def reverse[T](iterable: js.Iterable[T]): js.Array[T] = js.native
  
  def rgb(color: ColorCommonInstance): RGBColor = js.native
  /**
    * Converts the provided color instance and returns an RGB color. The color instance is converted to the RGB color space using color.rgb.
    * Note that unlike color.rgb this method always returns a new instance, even if color is already an RGB color.
    *
    * @param color A permissible color space instance.
    */
  def rgb(color: ColorSpaceObject): RGBColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning an RGB color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
    */
  def rgb(cssColorSpecifier: String): RGBColor = js.native
  /**
    * Constructs a new RGB color based on the specified channel values and opacity.
    *
    * @param r Red channel value.
    * @param g Green channel value.
    * @param b Blue channel value.
    * @param opacity Optional opacity value, defaults to 1.
    */
  def rgb(r: Double, g: Double, b: Double): RGBColor = js.native
  def rgb(r: Double, g: Double, b: Double, opacity: Double): RGBColor = js.native
  @JSName("rgb")
  val rgb_Original: RGBColorFactory = js.native
  
  def ribbon(): RibbonGenerator[_, Ribbon_, RibbonSubgroup] = js.native
  @JSName("ribbon")
  def ribbon_DatumSubgroupDatum[Datum, SubgroupDatum](): RibbonGenerator[_, Datum, SubgroupDatum] = js.native
  @JSName("ribbon")
  def ribbon_ThisDatumSubgroupDatum[This, Datum, SubgroupDatum](): RibbonGenerator[This, Datum, SubgroupDatum] = js.native
  
  def rollup[TObject, TReduce, TKey](
    iterable: js.Iterable[TObject],
    reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
    key: js.Function1[/* value */ TObject, TKey]
  ): Map[TKey, TReduce] = js.native
  def rollup[TObject, TReduce, TKey1, TKey2](
    iterable: js.Iterable[TObject],
    reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2]
  ): Map[TKey1, Map[TKey2, TReduce]] = js.native
  def rollup[TObject, TReduce, TKey1, TKey2, TKey3](
    iterable: js.Iterable[TObject],
    reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2],
    key3: js.Function1[/* value */ TObject, TKey3]
  ): Map[TKey1, Map[TKey2, Map[TKey3, TReduce]]] = js.native
  
  def rollups[TObject, TReduce, TKey](
    iterable: js.Iterable[TObject],
    reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
    key: js.Function1[/* value */ TObject, TKey]
  ): js.Array[js.Tuple2[TKey, TReduce]] = js.native
  def rollups[TObject, TReduce, TKey1, TKey2](
    iterable: js.Iterable[TObject],
    reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2]
  ): js.Array[js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, TReduce]]]] = js.native
  def rollups[TObject, TReduce, TKey1, TKey2, TKey3](
    iterable: js.Iterable[TObject],
    reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
    key1: js.Function1[/* value */ TObject, TKey1],
    key2: js.Function1[/* value */ TObject, TKey2],
    key3: js.Function1[/* value */ TObject, TKey3]
  ): js.Array[
    js.Tuple2[TKey1, js.Array[js.Tuple2[TKey2, js.Array[js.Tuple2[TKey3, TReduce]]]]]
  ] = js.native
  
  def scaleBand[Domain /* <: typingsSlinky.d3Scale.anon.ToString */](): ScaleBand_[Domain] = js.native
  def scaleBand[Domain /* <: typingsSlinky.d3Scale.anon.ToString */](domain: js.Iterable[Domain], range: js.Iterable[NumberValue]): ScaleBand_[Domain] = js.native
  def scaleBand[Domain /* <: typingsSlinky.d3Scale.anon.ToString */](range: js.Iterable[NumberValue]): ScaleBand_[Domain] = js.native
  
  def scaleDiverging[Output, Unknown](): ScaleDiverging_[Output, Unknown] = js.native
  def scaleDiverging[Output, Unknown](domain: js.Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  def scaleDiverging[Output, Unknown](domain: js.Iterable[NumberValue], interpolator: js.Iterable[Output]): ScaleDiverging_[Output, Unknown] = js.native
  def scaleDiverging[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  def scaleDiverging[Output, Unknown](interpolator: js.Iterable[Output]): ScaleDiverging_[Output, Unknown] = js.native
  
  def scaleDivergingLog[Output, Unknown](): ScaleDiverging_[Output, Unknown] = js.native
  def scaleDivergingLog[Output, Unknown](domain: js.Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  def scaleDivergingLog[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  
  def scaleDivergingPow[Output, Unknown](): ScaleDiverging_[Output, Unknown] = js.native
  def scaleDivergingPow[Output, Unknown](domain: js.Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  def scaleDivergingPow[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  
  def scaleDivergingSqrt[Output, Unknown](): ScaleDiverging_[Output, Unknown] = js.native
  def scaleDivergingSqrt[Output, Unknown](domain: js.Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  def scaleDivergingSqrt[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  
  def scaleDivergingSymlog[Output, Unknown](): ScaleDiverging_[Output, Unknown] = js.native
  def scaleDivergingSymlog[Output, Unknown](domain: js.Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  def scaleDivergingSymlog[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleDiverging_[Output, Unknown] = js.native
  
  def scaleIdentity[Unknown](): ScaleIdentity_[Unknown] = js.native
  def scaleIdentity[Unknown](range: js.Iterable[NumberValue]): ScaleIdentity_[Unknown] = js.native
  
  val scaleImplicit: Name = js.native
  
  def scaleLinear[Range, Output, Unknown](): ScaleLinear_[Range, Output, Unknown] = js.native
  def scaleLinear[Range, Output, Unknown](domain: js.Iterable[NumberValue], range: js.Iterable[Range]): ScaleLinear_[Range, Output, Unknown] = js.native
  def scaleLinear[Range, Output, Unknown](range: js.Iterable[Range]): ScaleLinear_[Range, Output, Unknown] = js.native
  
  def scaleLog[Range, Output, Unknown](): ScaleLogarithmic[Range, Output, Unknown] = js.native
  def scaleLog[Range, Output, Unknown](domain: js.Iterable[NumberValue], range: js.Iterable[Range]): ScaleLogarithmic[Range, Output, Unknown] = js.native
  def scaleLog[Range, Output, Unknown](range: js.Iterable[Range]): ScaleLogarithmic[Range, Output, Unknown] = js.native
  
  def scaleOrdinal[Range](): ScaleOrdinal_[String, Range, scala.Nothing] = js.native
  def scaleOrdinal[Range](range: js.Iterable[Range]): ScaleOrdinal_[String, Range, scala.Nothing] = js.native
  def scaleOrdinal[Domain /* <: typingsSlinky.d3Scale.anon.ToString */, Range, Unknown](domain: js.Iterable[Domain], range: js.Iterable[Range]): ScaleOrdinal_[Domain, Range, Unknown] = js.native
  @JSName("scaleOrdinal")
  def scaleOrdinal_Domain_ToStringRangeUnknown[Domain /* <: typingsSlinky.d3Scale.anon.ToString */, Range, Unknown](): ScaleOrdinal_[Domain, Range, Unknown] = js.native
  @JSName("scaleOrdinal")
  def scaleOrdinal_Domain_ToStringRangeUnknown[Domain /* <: typingsSlinky.d3Scale.anon.ToString */, Range, Unknown](range: js.Iterable[Range]): ScaleOrdinal_[Domain, Range, Unknown] = js.native
  
  def scalePoint[Domain /* <: typingsSlinky.d3Scale.anon.ToString */](): ScalePoint_[Domain] = js.native
  def scalePoint[Domain /* <: typingsSlinky.d3Scale.anon.ToString */](domain: js.Iterable[Domain], range: js.Iterable[NumberValue]): ScalePoint_[Domain] = js.native
  def scalePoint[Domain /* <: typingsSlinky.d3Scale.anon.ToString */](range: js.Iterable[NumberValue]): ScalePoint_[Domain] = js.native
  
  def scalePow[Range, Output, Unknown](): ScalePower[Range, Output, Unknown] = js.native
  def scalePow[Range, Output, Unknown](domain: js.Iterable[NumberValue], range: js.Iterable[Range]): ScalePower[Range, Output, Unknown] = js.native
  def scalePow[Range, Output, Unknown](range: js.Iterable[Range]): ScalePower[Range, Output, Unknown] = js.native
  
  def scaleQuantile[Range, Unknown](): ScaleQuantile_[Range, Unknown] = js.native
  def scaleQuantile[Range, Unknown](domain: js.Iterable[js.UndefOr[NumberValue | Null]], range: js.Iterable[Range]): ScaleQuantile_[Range, Unknown] = js.native
  def scaleQuantile[Range, Unknown](range: js.Iterable[Range]): ScaleQuantile_[Range, Unknown] = js.native
  
  def scaleQuantize[Range, Unknown](): ScaleQuantize_[Range, Unknown] = js.native
  def scaleQuantize[Range, Unknown](domain: js.Iterable[NumberValue], range: js.Iterable[Range]): ScaleQuantize_[Range, Unknown] = js.native
  def scaleQuantize[Range, Unknown](range: js.Iterable[Range]): ScaleQuantize_[Range, Unknown] = js.native
  
  def scaleRadial[Range, Unknown](): ScaleRadial_[Range, Range, Unknown] = js.native
  def scaleRadial[Range, Unknown](domain: js.Iterable[NumberValue], range: js.Iterable[Range]): ScaleRadial_[Range, Range, Unknown] = js.native
  def scaleRadial[Range, Unknown](range: js.Iterable[Range]): ScaleRadial_[Range, Range, Unknown] = js.native
  
  def scaleSequential[Output, Unknown](): ScaleSequential_[Output, Unknown] = js.native
  def scaleSequential[Output, Unknown](domain: js.Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  def scaleSequential[Output, Unknown](domain: js.Iterable[NumberValue], interpolator: js.Iterable[Output]): ScaleSequential_[Output, Unknown] = js.native
  def scaleSequential[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  def scaleSequential[Output, Unknown](interpolator: js.Iterable[Output]): ScaleSequential_[Output, Unknown] = js.native
  
  def scaleSequentialLog[Output, Unknown](): ScaleSequential_[Output, Unknown] = js.native
  def scaleSequentialLog[Output, Unknown](domain: js.Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  def scaleSequentialLog[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  
  def scaleSequentialPow[Output, Unknown](): ScaleSequential_[Output, Unknown] = js.native
  def scaleSequentialPow[Output, Unknown](domain: js.Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  def scaleSequentialPow[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  
  def scaleSequentialQuantile[Output, Unknown](): ScaleSequentialQuantile_[Output, Unknown] = js.native
  def scaleSequentialQuantile[Output, Unknown](domain: js.Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleSequentialQuantile_[Output, Unknown] = js.native
  def scaleSequentialQuantile[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequentialQuantile_[Output, Unknown] = js.native
  
  def scaleSequentialSqrt[Output, Unknown](): ScaleSequential_[Output, Unknown] = js.native
  def scaleSequentialSqrt[Output, Unknown](domain: js.Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  def scaleSequentialSqrt[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  
  def scaleSequentialSymlog[Output, Unknown](): ScaleSequential_[Output, Unknown] = js.native
  def scaleSequentialSymlog[Output, Unknown](domain: js.Iterable[NumberValue], interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  def scaleSequentialSymlog[Output, Unknown](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential_[Output, Unknown] = js.native
  
  def scaleSqrt[Range, Output, Unknown](): ScalePower[Range, Output, Unknown] = js.native
  def scaleSqrt[Range, Output, Unknown](domain: js.Iterable[NumberValue], range: js.Iterable[Range]): ScalePower[Range, Output, Unknown] = js.native
  def scaleSqrt[Range, Output, Unknown](range: js.Iterable[Range]): ScalePower[Range, Output, Unknown] = js.native
  
  def scaleSymlog[Range, Output, Unknown](): ScaleSymLog_[Range, Output, Unknown] = js.native
  def scaleSymlog[Range, Output, Unknown](domain: js.Iterable[NumberValue], range: js.Iterable[Range]): ScaleSymLog_[Range, Output, Unknown] = js.native
  def scaleSymlog[Range, Output, Unknown](range: js.Iterable[Range]): ScaleSymLog_[Range, Output, Unknown] = js.native
  
  def scaleThreshold[Domain /* <: Double | String | js.Date */, Range, Unknown](): ScaleThreshold_[Domain, Range, Unknown] = js.native
  def scaleThreshold[Domain /* <: Double | String | js.Date */, Range, Unknown](domain: js.Iterable[Domain], range: js.Iterable[Range]): ScaleThreshold_[Domain, Range, Unknown] = js.native
  def scaleThreshold[Domain /* <: Double | String | js.Date */, Range, Unknown](range: js.Iterable[Range]): ScaleThreshold_[Domain, Range, Unknown] = js.native
  
  def scaleTime[Range, Output, Unknown](): ScaleTime_[Range, Output, Unknown] = js.native
  def scaleTime[Range, Output, Unknown](domain: js.Iterable[js.Date | NumberValue], range: js.Iterable[Range]): ScaleTime_[Range, Output, Unknown] = js.native
  def scaleTime[Range, Output, Unknown](range: js.Iterable[Range]): ScaleTime_[Range, Output, Unknown] = js.native
  
  def scaleUtc[Range, Output, Unknown](): ScaleTime_[Range, Output, Unknown] = js.native
  def scaleUtc[Range, Output, Unknown](domain: js.Iterable[NumberValue], range: js.Iterable[Range]): ScaleTime_[Range, Output, Unknown] = js.native
  def scaleUtc[Range, Output, Unknown](range: js.Iterable[Range]): ScaleTime_[Range, Output, Unknown] = js.native
  
  val schemeAccent: js.Array[String] = js.native
  
  val schemeBlues: js.Array[js.Array[String]] = js.native
  
  val schemeBrBG: js.Array[js.Array[String]] = js.native
  
  val schemeBuGn: js.Array[js.Array[String]] = js.native
  
  val schemeBuPu: js.Array[js.Array[String]] = js.native
  
  val schemeCategory10: js.Array[String] = js.native
  
  val schemeDark2: js.Array[String] = js.native
  
  val schemeGnBu: js.Array[js.Array[String]] = js.native
  
  val schemeGreens: js.Array[js.Array[String]] = js.native
  
  val schemeGreys: js.Array[js.Array[String]] = js.native
  
  val schemeOrRd: js.Array[js.Array[String]] = js.native
  
  val schemeOranges: js.Array[js.Array[String]] = js.native
  
  val schemePRGn: js.Array[js.Array[String]] = js.native
  
  val schemePaired: js.Array[String] = js.native
  
  val schemePastel1: js.Array[String] = js.native
  
  val schemePastel2: js.Array[String] = js.native
  
  val schemePiYG: js.Array[js.Array[String]] = js.native
  
  val schemePuBu: js.Array[js.Array[String]] = js.native
  
  val schemePuBuGn: js.Array[js.Array[String]] = js.native
  
  val schemePuOr: js.Array[js.Array[String]] = js.native
  
  val schemePuRd: js.Array[js.Array[String]] = js.native
  
  val schemePurples: js.Array[js.Array[String]] = js.native
  
  val schemeRdBu: js.Array[js.Array[String]] = js.native
  
  val schemeRdGy: js.Array[js.Array[String]] = js.native
  
  val schemeRdPu: js.Array[js.Array[String]] = js.native
  
  val schemeRdYlBu: js.Array[js.Array[String]] = js.native
  
  val schemeRdYlGn: js.Array[js.Array[String]] = js.native
  
  val schemeReds: js.Array[js.Array[String]] = js.native
  
  val schemeSet1: js.Array[String] = js.native
  
  val schemeSet2: js.Array[String] = js.native
  
  val schemeSet3: js.Array[String] = js.native
  
  val schemeSpectral: js.Array[js.Array[String]] = js.native
  
  val schemeTableau10: js.Array[String] = js.native
  
  val schemeYlGn: js.Array[js.Array[String]] = js.native
  
  val schemeYlGnBu: js.Array[js.Array[String]] = js.native
  
  val schemeYlOrBr: js.Array[js.Array[String]] = js.native
  
  val schemeYlOrRd: js.Array[js.Array[String]] = js.native
  
  def select[OldDatum](node: Null): Selection_[Null, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def select[OldDatum](node: EnterElement): Selection_[EnterElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def select[OldDatum](node: Document): Selection_[Document, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def select[OldDatum](node: Element): Selection_[Element, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def select[OldDatum](node: Window): Selection_[Window, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def select[GElement /* <: BaseType */, OldDatum](selector: String): Selection_[GElement, OldDatum, HTMLElement, _] = js.native
  
  def selectAll(): Selection_[Null, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  def selectAll(selector: js.UndefOr[scala.Nothing]): Selection_[Null, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  def selectAll(selector: Null): Selection_[Null, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  def selectAll[GElement /* <: BaseType */, OldDatum](nodes: js.Array[GElement]): Selection_[GElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def selectAll[GElement /* <: BaseType */, OldDatum](nodes: typingsSlinky.d3Selection.mod.ArrayLike[GElement]): Selection_[GElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def selectAll[GElement /* <: BaseType */, OldDatum](nodes: js.Iterable[GElement]): Selection_[GElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def selectAll[GElement /* <: BaseType */, OldDatum](selector: String): Selection_[GElement, OldDatum, HTMLElement, _] = js.native
  
  def selection(): Selection_[HTMLElement, _, Null, js.UndefOr[scala.Nothing]] = js.native
  
  def selector[DescElement /* <: Element */](selector: String): js.ThisFunction0[/* this */ BaseType, DescElement] = js.native
  
  def selectorAll[DescElement /* <: Element */](selector: String): js.ThisFunction0[/* this */ BaseType, NodeListOf[DescElement with Node]] = js.native
  
  def shuffle(array: js.typedarray.Float32Array): js.typedarray.Float32Array = js.native
  def shuffle(array: js.typedarray.Float32Array, lo: js.UndefOr[scala.Nothing], hi: Double): js.typedarray.Float32Array = js.native
  def shuffle(array: js.typedarray.Float32Array, lo: Double): js.typedarray.Float32Array = js.native
  def shuffle(array: js.typedarray.Float32Array, lo: Double, hi: Double): js.typedarray.Float32Array = js.native
  def shuffle(array: js.typedarray.Float64Array): js.typedarray.Float64Array = js.native
  def shuffle(array: js.typedarray.Float64Array, lo: js.UndefOr[scala.Nothing], hi: Double): js.typedarray.Float64Array = js.native
  def shuffle(array: js.typedarray.Float64Array, lo: Double): js.typedarray.Float64Array = js.native
  def shuffle(array: js.typedarray.Float64Array, lo: Double, hi: Double): js.typedarray.Float64Array = js.native
  def shuffle(array: js.typedarray.Int16Array): js.typedarray.Int16Array = js.native
  def shuffle(array: js.typedarray.Int16Array, lo: js.UndefOr[scala.Nothing], hi: Double): js.typedarray.Int16Array = js.native
  def shuffle(array: js.typedarray.Int16Array, lo: Double): js.typedarray.Int16Array = js.native
  def shuffle(array: js.typedarray.Int16Array, lo: Double, hi: Double): js.typedarray.Int16Array = js.native
  def shuffle(array: js.typedarray.Int32Array): js.typedarray.Int32Array = js.native
  def shuffle(array: js.typedarray.Int32Array, lo: js.UndefOr[scala.Nothing], hi: Double): js.typedarray.Int32Array = js.native
  def shuffle(array: js.typedarray.Int32Array, lo: Double): js.typedarray.Int32Array = js.native
  def shuffle(array: js.typedarray.Int32Array, lo: Double, hi: Double): js.typedarray.Int32Array = js.native
  def shuffle(array: js.typedarray.Int8Array): js.typedarray.Int8Array = js.native
  def shuffle(array: js.typedarray.Int8Array, lo: js.UndefOr[scala.Nothing], hi: Double): js.typedarray.Int8Array = js.native
  def shuffle(array: js.typedarray.Int8Array, lo: Double): js.typedarray.Int8Array = js.native
  def shuffle(array: js.typedarray.Int8Array, lo: Double, hi: Double): js.typedarray.Int8Array = js.native
  def shuffle(array: js.typedarray.Uint16Array): js.typedarray.Uint16Array = js.native
  def shuffle(array: js.typedarray.Uint16Array, lo: js.UndefOr[scala.Nothing], hi: Double): js.typedarray.Uint16Array = js.native
  def shuffle(array: js.typedarray.Uint16Array, lo: Double): js.typedarray.Uint16Array = js.native
  def shuffle(array: js.typedarray.Uint16Array, lo: Double, hi: Double): js.typedarray.Uint16Array = js.native
  def shuffle(array: js.typedarray.Uint32Array): js.typedarray.Uint32Array = js.native
  def shuffle(array: js.typedarray.Uint32Array, lo: js.UndefOr[scala.Nothing], hi: Double): js.typedarray.Uint32Array = js.native
  def shuffle(array: js.typedarray.Uint32Array, lo: Double): js.typedarray.Uint32Array = js.native
  def shuffle(array: js.typedarray.Uint32Array, lo: Double, hi: Double): js.typedarray.Uint32Array = js.native
  def shuffle(array: js.typedarray.Uint8Array): js.typedarray.Uint8Array = js.native
  def shuffle(array: js.typedarray.Uint8Array, lo: js.UndefOr[scala.Nothing], hi: Double): js.typedarray.Uint8Array = js.native
  def shuffle(array: js.typedarray.Uint8Array, lo: Double): js.typedarray.Uint8Array = js.native
  def shuffle(array: js.typedarray.Uint8Array, lo: Double, hi: Double): js.typedarray.Uint8Array = js.native
  def shuffle(array: js.typedarray.Uint8ClampedArray): js.typedarray.Uint8ClampedArray = js.native
  def shuffle(array: js.typedarray.Uint8ClampedArray, lo: js.UndefOr[scala.Nothing], hi: Double): js.typedarray.Uint8ClampedArray = js.native
  def shuffle(array: js.typedarray.Uint8ClampedArray, lo: Double): js.typedarray.Uint8ClampedArray = js.native
  def shuffle(array: js.typedarray.Uint8ClampedArray, lo: Double, hi: Double): js.typedarray.Uint8ClampedArray = js.native
  def shuffle[T](array: js.Array[T]): js.Array[T] = js.native
  def shuffle[T](array: js.Array[T], lo: js.UndefOr[scala.Nothing], hi: Double): js.Array[T] = js.native
  def shuffle[T](array: js.Array[T], lo: Double): js.Array[T] = js.native
  def shuffle[T](array: js.Array[T], lo: Double, hi: Double): js.Array[T] = js.native
  
  def shuffler(random: js.Function0[Double]): FnCall = js.native
  
  def some[T](
    iterable: js.Iterable[T],
    test: js.Function3[/* value */ T, /* index */ Double, /* iterable */ js.Iterable[T], _]
  ): Boolean = js.native
  
  def sort[T](iterable: js.Iterable[T]): js.Array[T] = js.native
  def sort[T](iterable: js.Iterable[T], comparator: js.Function2[/* a */ T, /* b */ T, Double]): js.Array[T] = js.native
  
  def stack(): Stack_[_, StringDictionary[Double], String] = js.native
  
  def stackOffsetDiverging(series: Series[_, _], order: js.Iterable[Double]): Unit = js.native
  
  def stackOffsetExpand(series: Series[_, _], order: js.Iterable[Double]): Unit = js.native
  
  def stackOffsetNone(series: Series[_, _], order: js.Iterable[Double]): Unit = js.native
  
  def stackOffsetSilhouette(series: Series[_, _], order: js.Iterable[Double]): Unit = js.native
  
  def stackOffsetWiggle(series: Series[_, _], order: js.Iterable[Double]): Unit = js.native
  
  def stackOrderAppearance(series: Series[_, _]): js.Array[Double] = js.native
  
  def stackOrderAscending(series: Series[_, _]): js.Array[Double] = js.native
  
  def stackOrderDescending(series: Series[_, _]): js.Array[Double] = js.native
  
  def stackOrderInsideOut(series: Series[_, _]): js.Array[Double] = js.native
  
  def stackOrderNone(series: Series[_, _]): js.Array[Double] = js.native
  
  def stackOrderReverse(series: Series[_, _]): js.Array[Double] = js.native
  
  @JSName("stack")
  def stack_Datum[Datum](): Stack_[_, Datum, String] = js.native
  @JSName("stack")
  def stack_DatumKey[Datum, Key](): Stack_[_, Datum, Key] = js.native
  @JSName("stack")
  def stack_ThisDatumKey[This, Datum, Key](): Stack_[This, Datum, Key] = js.native
  
  def stratify[Datum](): StratifyOperator[Datum] = js.native
  
  def style(node: Element, name: String): String = js.native
  
  def subset[T](a: js.Iterable[T], b: js.Iterable[T]): Boolean = js.native
  
  def sum[T /* <: Numeric */](iterable: js.Iterable[js.UndefOr[T | Null]]): Double = js.native
  def sum[T](
    iterable: js.Iterable[T],
    accessor: js.Function3[
      /* datum */ T, 
      /* index */ Double, 
      /* array */ js.Iterable[T], 
      js.UndefOr[Double | Null]
    ]
  ): Double = js.native
  
  def superset[T](a: js.Iterable[T], b: js.Iterable[T]): Boolean = js.native
  
  def svg(url: String): js.Promise[Document] = js.native
  def svg(url: String, init: RequestInit): js.Promise[Document] = js.native
  
  def symbol[Datum](): Symbol_[_, Datum] = js.native
  def symbol[Datum](
    `type`: js.UndefOr[scala.Nothing],
    size: js.ThisFunction2[/* this */ js.Any, /* d */ Datum, /* repeated */ js.Any, Double]
  ): Symbol_[_, Datum] = js.native
  def symbol[Datum](`type`: js.UndefOr[scala.Nothing], size: Double): Symbol_[_, Datum] = js.native
  def symbol[Datum](`type`: js.ThisFunction2[/* this */ js.Any, /* d */ Datum, /* repeated */ js.Any, SymbolType]): Symbol_[_, Datum] = js.native
  def symbol[Datum](
    `type`: js.ThisFunction2[/* this */ js.Any, /* d */ Datum, /* repeated */ js.Any, SymbolType],
    size: js.ThisFunction2[/* this */ js.Any, /* d */ Datum, /* repeated */ js.Any, Double]
  ): Symbol_[_, Datum] = js.native
  def symbol[Datum](
    `type`: js.ThisFunction2[/* this */ js.Any, /* d */ Datum, /* repeated */ js.Any, SymbolType],
    size: Double
  ): Symbol_[_, Datum] = js.native
  def symbol[Datum](`type`: SymbolType): Symbol_[_, Datum] = js.native
  def symbol[Datum](
    `type`: SymbolType,
    size: js.ThisFunction2[/* this */ js.Any, /* d */ Datum, /* repeated */ js.Any, Double]
  ): Symbol_[_, Datum] = js.native
  def symbol[Datum](`type`: SymbolType, size: Double): Symbol_[_, Datum] = js.native
  
  val symbolCircle: SymbolType = js.native
  
  val symbolCross: SymbolType = js.native
  
  val symbolDiamond: SymbolType = js.native
  
  val symbolSquare: SymbolType = js.native
  
  val symbolStar: SymbolType = js.native
  
  val symbolTriangle: SymbolType = js.native
  
  val symbolWye: SymbolType = js.native
  
  @JSName("symbol")
  def symbol_ThisDatum[This, Datum](): Symbol_[This, Datum] = js.native
  @JSName("symbol")
  def symbol_ThisDatum[This, Datum](
    `type`: js.UndefOr[scala.Nothing],
    size: js.ThisFunction2[/* this */ This, /* d */ Datum, /* repeated */ js.Any, Double]
  ): Symbol_[This, Datum] = js.native
  @JSName("symbol")
  def symbol_ThisDatum[This, Datum](`type`: js.UndefOr[scala.Nothing], size: Double): Symbol_[This, Datum] = js.native
  @JSName("symbol")
  def symbol_ThisDatum[This, Datum](`type`: js.ThisFunction2[/* this */ This, /* d */ Datum, /* repeated */ js.Any, SymbolType]): Symbol_[This, Datum] = js.native
  @JSName("symbol")
  def symbol_ThisDatum[This, Datum](
    `type`: js.ThisFunction2[/* this */ This, /* d */ Datum, /* repeated */ js.Any, SymbolType],
    size: js.ThisFunction2[/* this */ This, /* d */ Datum, /* repeated */ js.Any, Double]
  ): Symbol_[This, Datum] = js.native
  @JSName("symbol")
  def symbol_ThisDatum[This, Datum](
    `type`: js.ThisFunction2[/* this */ This, /* d */ Datum, /* repeated */ js.Any, SymbolType],
    size: Double
  ): Symbol_[This, Datum] = js.native
  @JSName("symbol")
  def symbol_ThisDatum[This, Datum](`type`: SymbolType): Symbol_[This, Datum] = js.native
  @JSName("symbol")
  def symbol_ThisDatum[This, Datum](
    `type`: SymbolType,
    size: js.ThisFunction2[/* this */ This, /* d */ Datum, /* repeated */ js.Any, Double]
  ): Symbol_[This, Datum] = js.native
  @JSName("symbol")
  def symbol_ThisDatum[This, Datum](`type`: SymbolType, size: Double): Symbol_[This, Datum] = js.native
  
  val symbols: js.Array[SymbolType] = js.native
  
  def text(url: String): js.Promise[String] = js.native
  def text(url: String, init: RequestInit): js.Promise[String] = js.native
  
  def thresholdFreedmanDiaconis(values: ArrayLike[js.UndefOr[Double]], min: Double, max: Double): Double = js.native
  
  def thresholdScott(values: ArrayLike[js.UndefOr[Double]], min: Double, max: Double): Double = js.native
  
  def thresholdSturges(values: ArrayLike[js.UndefOr[Double]]): Double = js.native
  
  def tickFormat(start: Double, stop: Double, count: Double): js.Function1[/* d */ NumberValue, String] = js.native
  def tickFormat(start: Double, stop: Double, count: Double, specifier: String): js.Function1[/* d */ NumberValue, String] = js.native
  
  def tickIncrement(start: Double, stop: Double, count: Double): Double = js.native
  
  def tickStep(start: Double, stop: Double, count: Double): Double = js.native
  
  def ticks(start: Double, stop: Double, count: Double): js.Array[Double] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeDay(): js.Date = js.native
  def timeDay(date: js.Date): js.Date = js.native
  @JSName("timeDay")
  val timeDay_Original: CountableTimeInterval = js.native
  
  def timeDays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def timeDays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  def timeFormat(specifier: String): js.Function1[/* date */ js.Date, String] = js.native
  
  def timeFormatDefaultLocale(definition: TimeLocaleDefinition): TimeLocaleObject = js.native
  
  def timeFormatLocale(definition: TimeLocaleDefinition): TimeLocaleObject = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeFriday(): js.Date = js.native
  def timeFriday(date: js.Date): js.Date = js.native
  @JSName("timeFriday")
  val timeFriday_Original: CountableTimeInterval = js.native
  
  def timeFridays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def timeFridays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeHour(): js.Date = js.native
  def timeHour(date: js.Date): js.Date = js.native
  @JSName("timeHour")
  val timeHour_Original: CountableTimeInterval = js.native
  
  def timeHours(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def timeHours(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  def timeInterval(
    floor: js.Function1[/* date */ js.Date, Unit],
    offset: js.Function2[/* date */ js.Date, /* step */ Double, Unit]
  ): TimeInterval_ = js.native
  def timeInterval(
    floor: js.Function1[/* date */ js.Date, Unit],
    offset: js.Function2[/* date */ js.Date, /* step */ Double, Unit],
    count: js.Function2[/* start */ js.Date, /* end */ js.Date, Double]
  ): CountableTimeInterval = js.native
  def timeInterval(
    floor: js.Function1[/* date */ js.Date, Unit],
    offset: js.Function2[/* date */ js.Date, /* step */ Double, Unit],
    count: js.Function2[/* start */ js.Date, /* end */ js.Date, Double],
    field: js.Function1[/* date */ js.Date, Double]
  ): CountableTimeInterval = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeMillisecond(): js.Date = js.native
  def timeMillisecond(date: js.Date): js.Date = js.native
  @JSName("timeMillisecond")
  val timeMillisecond_Original: CountableTimeInterval = js.native
  
  def timeMilliseconds(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def timeMilliseconds(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeMinute(): js.Date = js.native
  def timeMinute(date: js.Date): js.Date = js.native
  @JSName("timeMinute")
  val timeMinute_Original: CountableTimeInterval = js.native
  
  def timeMinutes(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def timeMinutes(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeMonday(): js.Date = js.native
  def timeMonday(date: js.Date): js.Date = js.native
  @JSName("timeMonday")
  val timeMonday_Original: CountableTimeInterval = js.native
  
  def timeMondays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def timeMondays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeMonth(): js.Date = js.native
  def timeMonth(date: js.Date): js.Date = js.native
  @JSName("timeMonth")
  val timeMonth_Original: CountableTimeInterval = js.native
  
  def timeMonths(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def timeMonths(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  def timeParse(specifier: String): js.Function1[/* dateString */ String, js.Date | Null] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeSaturday(): js.Date = js.native
  def timeSaturday(date: js.Date): js.Date = js.native
  @JSName("timeSaturday")
  val timeSaturday_Original: CountableTimeInterval = js.native
  
  def timeSaturdays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def timeSaturdays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeSecond(): js.Date = js.native
  def timeSecond(date: js.Date): js.Date = js.native
  @JSName("timeSecond")
  val timeSecond_Original: CountableTimeInterval = js.native
  
  def timeSeconds(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def timeSeconds(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeSunday(): js.Date = js.native
  def timeSunday(date: js.Date): js.Date = js.native
  @JSName("timeSunday")
  val timeSunday_Original: CountableTimeInterval = js.native
  
  def timeSundays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def timeSundays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeThursday(): js.Date = js.native
  def timeThursday(date: js.Date): js.Date = js.native
  @JSName("timeThursday")
  val timeThursday_Original: CountableTimeInterval = js.native
  
  def timeThursdays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def timeThursdays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeTuesday(): js.Date = js.native
  def timeTuesday(date: js.Date): js.Date = js.native
  @JSName("timeTuesday")
  val timeTuesday_Original: CountableTimeInterval = js.native
  
  def timeTuesdays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def timeTuesdays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeWednesday(): js.Date = js.native
  def timeWednesday(date: js.Date): js.Date = js.native
  @JSName("timeWednesday")
  val timeWednesday_Original: CountableTimeInterval = js.native
  
  def timeWednesdays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def timeWednesdays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeWeek(): js.Date = js.native
  def timeWeek(date: js.Date): js.Date = js.native
  @JSName("timeWeek")
  val timeWeek_Original: CountableTimeInterval = js.native
  
  def timeWeeks(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def timeWeeks(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeYear(): js.Date = js.native
  def timeYear(date: js.Date): js.Date = js.native
  @JSName("timeYear")
  val timeYear_Original: CountableTimeInterval = js.native
  
  def timeYears(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def timeYears(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  def timeout(callback: js.Function1[/* elapsed */ Double, Unit]): Timer_ = js.native
  def timeout(callback: js.Function1[/* elapsed */ Double, Unit], delay: js.UndefOr[scala.Nothing], time: Double): Timer_ = js.native
  def timeout(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double): Timer_ = js.native
  def timeout(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double, time: Double): Timer_ = js.native
  
  def timer(callback: js.Function1[/* elapsed */ Double, Unit]): Timer_ = js.native
  def timer(callback: js.Function1[/* elapsed */ Double, Unit], delay: js.UndefOr[scala.Nothing], time: Double): Timer_ = js.native
  def timer(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double): Timer_ = js.native
  def timer(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double, time: Double): Timer_ = js.native
  
  def timerFlush(): Unit = js.native
  
  def transition[OldDatum](): Transition_[HTMLElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def transition[OldDatum](name: String): Transition_[HTMLElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def transition[OldDatum](transition: Transition_[BaseType, _, BaseType, _]): Transition_[HTMLElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  
  def transpose[T](matrix: ArrayLike[ArrayLike[T]]): js.Array[js.Array[T]] = js.native
  
  def tree[Datum](): TreeLayout[Datum] = js.native
  
  def treemap[Datum](): TreemapLayout[Datum] = js.native
  
  def treemapBinary(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
  
  def treemapDice(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
  
  def treemapResquarify(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
  @JSName("treemapResquarify")
  val treemapResquarify_Original: RatioSquarifyTilingFactory = js.native
  
  def treemapSlice(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
  
  def treemapSliceDice(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
  
  def treemapSquarify(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
  @JSName("treemapSquarify")
  val treemapSquarify_Original: RatioSquarifyTilingFactory = js.native
  
  def tsv[Columns /* <: String */](url: String): js.Promise[DSVRowArray[Columns]] = js.native
  def tsv[Columns /* <: String */](url: String, init: RequestInit): js.Promise[DSVRowArray[Columns]] = js.native
  def tsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
    url: String,
    init: RequestInit,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
  def tsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
    url: String,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
  
  def tsvFormat[T /* <: js.Object */](rows: js.Array[T]): String = js.native
  def tsvFormat[T /* <: js.Object */](rows: js.Array[T], columns: js.Array[/* keyof T */ String]): String = js.native
  
  def tsvFormatBody[T /* <: js.Object */](rows: js.Array[T]): String = js.native
  def tsvFormatBody[T /* <: js.Object */](rows: js.Array[T], columns: js.Array[/* keyof T */ String]): String = js.native
  
  def tsvFormatRow(row: js.Array[String]): String = js.native
  
  def tsvFormatRows(rows: js.Array[js.Array[String]]): String = js.native
  
  def tsvFormatValue(value: String): String = js.native
  
  def tsvParse[Columns /* <: String */](tsvString: String): DSVRowArray[Columns] = js.native
  def tsvParse[ParsedRow /* <: js.Object */, Columns /* <: String */](
    tsvString: String,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): DSVParsedArray[ParsedRow] = js.native
  
  def tsvParseRows(tsvString: String): js.Array[js.Array[String]] = js.native
  def tsvParseRows[ParsedRow /* <: js.Object */](
    tsvString: String,
    row: js.Function2[/* rawRow */ js.Array[String], /* index */ Double, js.UndefOr[ParsedRow | Null]]
  ): js.Array[ParsedRow] = js.native
  
  def union[T](iterables: js.Iterable[T]*): Set[T] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcDay(): js.Date = js.native
  def utcDay(date: js.Date): js.Date = js.native
  @JSName("utcDay")
  val utcDay_Original: CountableTimeInterval = js.native
  
  def utcDays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def utcDays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  def utcFormat(specifier: String): js.Function1[/* date */ js.Date, String] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcFriday(): js.Date = js.native
  def utcFriday(date: js.Date): js.Date = js.native
  @JSName("utcFriday")
  val utcFriday_Original: CountableTimeInterval = js.native
  
  def utcFridays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def utcFridays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcHour(): js.Date = js.native
  def utcHour(date: js.Date): js.Date = js.native
  @JSName("utcHour")
  val utcHour_Original: CountableTimeInterval = js.native
  
  def utcHours(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def utcHours(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcMillisecond(): js.Date = js.native
  def utcMillisecond(date: js.Date): js.Date = js.native
  @JSName("utcMillisecond")
  val utcMillisecond_Original: CountableTimeInterval = js.native
  
  def utcMilliseconds(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def utcMilliseconds(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcMinute(): js.Date = js.native
  def utcMinute(date: js.Date): js.Date = js.native
  @JSName("utcMinute")
  val utcMinute_Original: CountableTimeInterval = js.native
  
  def utcMinutes(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def utcMinutes(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcMonday(): js.Date = js.native
  def utcMonday(date: js.Date): js.Date = js.native
  @JSName("utcMonday")
  val utcMonday_Original: CountableTimeInterval = js.native
  
  def utcMondays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def utcMondays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcMonth(): js.Date = js.native
  def utcMonth(date: js.Date): js.Date = js.native
  @JSName("utcMonth")
  val utcMonth_Original: CountableTimeInterval = js.native
  
  def utcMonths(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def utcMonths(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  def utcParse(specifier: String): js.Function1[/* dateString */ String, js.Date | Null] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcSaturday(): js.Date = js.native
  def utcSaturday(date: js.Date): js.Date = js.native
  @JSName("utcSaturday")
  val utcSaturday_Original: CountableTimeInterval = js.native
  
  def utcSaturdays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def utcSaturdays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcSecond(): js.Date = js.native
  def utcSecond(date: js.Date): js.Date = js.native
  @JSName("utcSecond")
  val utcSecond_Original: CountableTimeInterval = js.native
  
  def utcSeconds(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def utcSeconds(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcSunday(): js.Date = js.native
  def utcSunday(date: js.Date): js.Date = js.native
  @JSName("utcSunday")
  val utcSunday_Original: CountableTimeInterval = js.native
  
  def utcSundays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def utcSundays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcThursday(): js.Date = js.native
  def utcThursday(date: js.Date): js.Date = js.native
  @JSName("utcThursday")
  val utcThursday_Original: CountableTimeInterval = js.native
  
  def utcThursdays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def utcThursdays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcTuesday(): js.Date = js.native
  def utcTuesday(date: js.Date): js.Date = js.native
  @JSName("utcTuesday")
  val utcTuesday_Original: CountableTimeInterval = js.native
  
  def utcTuesdays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def utcTuesdays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcWednesday(): js.Date = js.native
  def utcWednesday(date: js.Date): js.Date = js.native
  @JSName("utcWednesday")
  val utcWednesday_Original: CountableTimeInterval = js.native
  
  def utcWednesdays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def utcWednesdays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcWeek(): js.Date = js.native
  def utcWeek(date: js.Date): js.Date = js.native
  @JSName("utcWeek")
  val utcWeek_Original: CountableTimeInterval = js.native
  
  def utcWeeks(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def utcWeeks(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * Equivalent to interval.floor, except it date is not specified, it defaults to the current time.
    * For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcYear(): js.Date = js.native
  def utcYear(date: js.Date): js.Date = js.native
  @JSName("utcYear")
  val utcYear_Original: CountableTimeInterval = js.native
  
  def utcYears(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
  def utcYears(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
  
  def variance[T /* <: Numeric */](iterable: js.Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = js.native
  def variance[T](
    iterable: js.Iterable[T],
    accessor: js.Function3[
      /* datum */ T, 
      /* index */ Double, 
      /* array */ js.Iterable[T], 
      js.UndefOr[Double | Null]
    ]
  ): js.UndefOr[Double] = js.native
  
  val version: String = js.native
  
  def window(DOMNode: Document): Window = js.native
  def window(DOMNode: Element): Window = js.native
  def window(DOMNode: Window): Window = js.native
  
  def xml(url: String): js.Promise[XMLDocument] = js.native
  def xml(url: String, init: RequestInit): js.Promise[XMLDocument] = js.native
  
  def zip[T](arrays: ArrayLike[T]*): js.Array[js.Array[T]] = js.native
  
  def zoom[ZoomRefElement /* <: Element */, Datum](): ZoomBehavior[ZoomRefElement, Datum] = js.native
  
  val zoomIdentity: ZoomTransform_ = js.native
  
  def zoomTransform(node: Element): ZoomTransform_ = js.native
  
  @js.native
  /**
    * Creates a full precision adder for IEEE 754 floating point numbers, setting its initial value to 0.
    */
  class Adder ()
    extends typingsSlinky.d3.mod.Adder
  @js.native
  object Adder
    extends TopLevel[Instantiable0[typingsSlinky.d3.mod.Adder]]
  
  @js.native
  class FormatSpecifier protected ()
    extends typingsSlinky.d3.mod.FormatSpecifier_ {
    /**
      * Given the specified specifier object, returning an object with exposed fields that correspond to the format specification mini-language and a toString method that reconstructs the specifier.
      * @param specifier A specifier object.
      */
    def this(specifier: FormatSpecifierObject) = this()
  }
  @js.native
  object FormatSpecifier
    extends TopLevel[
          Instantiable1[/* specifier */ FormatSpecifierObject, typingsSlinky.d3.mod.FormatSpecifier_]
        ]
  
  @js.native
  class Voronoi[P] ()
    extends typingsSlinky.d3.mod.Voronoi[P]
  @js.native
  object Voronoi
    extends TopLevel[Instantiable0[typingsSlinky.d3.mod.Voronoi[js.Object]]]
}
