package typingsSlinky.plotlyDotJs

import org.scalablytyped.runtime.NumberDictionary
import org.scalablytyped.runtime.StringDictionary
import org.scalajs.dom.experimental.RequestInit
import org.scalajs.dom.raw.Blob
import org.scalajs.dom.raw.EventTarget
import org.scalajs.dom.raw.HTMLAnchorElement
import org.scalajs.dom.raw.HTMLAppletElement
import org.scalajs.dom.raw.HTMLAreaElement
import org.scalajs.dom.raw.HTMLAudioElement
import org.scalajs.dom.raw.HTMLBRElement
import org.scalajs.dom.raw.HTMLBaseElement
import org.scalajs.dom.raw.HTMLBaseFontElement
import org.scalajs.dom.raw.HTMLBodyElement
import org.scalajs.dom.raw.HTMLButtonElement
import org.scalajs.dom.raw.HTMLCanvasElement
import org.scalajs.dom.raw.HTMLDListElement
import org.scalajs.dom.raw.HTMLDataListElement
import org.scalajs.dom.raw.HTMLDirectoryElement
import org.scalajs.dom.raw.HTMLDivElement
import org.scalajs.dom.raw.HTMLElement
import org.scalajs.dom.raw.HTMLEmbedElement
import org.scalajs.dom.raw.HTMLFieldSetElement
import org.scalajs.dom.raw.HTMLFontElement
import org.scalajs.dom.raw.HTMLFormElement
import org.scalajs.dom.raw.HTMLFrameElement
import org.scalajs.dom.raw.HTMLFrameSetElement
import org.scalajs.dom.raw.HTMLHRElement
import org.scalajs.dom.raw.HTMLHeadElement
import org.scalajs.dom.raw.HTMLHeadingElement
import org.scalajs.dom.raw.HTMLHtmlElement
import org.scalajs.dom.raw.HTMLIFrameElement
import org.scalajs.dom.raw.HTMLImageElement
import org.scalajs.dom.raw.HTMLInputElement
import org.scalajs.dom.raw.HTMLLIElement
import org.scalajs.dom.raw.HTMLLabelElement
import org.scalajs.dom.raw.HTMLLegendElement
import org.scalajs.dom.raw.HTMLLinkElement
import org.scalajs.dom.raw.HTMLMapElement
import org.scalajs.dom.raw.HTMLMarqueeElement
import org.scalajs.dom.raw.HTMLMenuElement
import org.scalajs.dom.raw.HTMLMetaElement
import org.scalajs.dom.raw.HTMLModElement
import org.scalajs.dom.raw.HTMLOListElement
import org.scalajs.dom.raw.HTMLObjectElement
import org.scalajs.dom.raw.HTMLOptGroupElement
import org.scalajs.dom.raw.HTMLOptionElement
import org.scalajs.dom.raw.HTMLParagraphElement
import org.scalajs.dom.raw.HTMLParamElement
import org.scalajs.dom.raw.HTMLPreElement
import org.scalajs.dom.raw.HTMLProgressElement
import org.scalajs.dom.raw.HTMLQuoteElement
import org.scalajs.dom.raw.HTMLScriptElement
import org.scalajs.dom.raw.HTMLSelectElement
import org.scalajs.dom.raw.HTMLSourceElement
import org.scalajs.dom.raw.HTMLSpanElement
import org.scalajs.dom.raw.HTMLStyleElement
import org.scalajs.dom.raw.HTMLTableCaptionElement
import org.scalajs.dom.raw.HTMLTableColElement
import org.scalajs.dom.raw.HTMLTableDataCellElement
import org.scalajs.dom.raw.HTMLTableElement
import org.scalajs.dom.raw.HTMLTableHeaderCellElement
import org.scalajs.dom.raw.HTMLTableRowElement
import org.scalajs.dom.raw.HTMLTableSectionElement
import org.scalajs.dom.raw.HTMLTextAreaElement
import org.scalajs.dom.raw.HTMLTitleElement
import org.scalajs.dom.raw.HTMLTrackElement
import org.scalajs.dom.raw.HTMLUListElement
import org.scalajs.dom.raw.HTMLVideoElement
import org.scalajs.dom.raw.Node
import org.scalajs.dom.raw.NodeListOf
import org.scalajs.dom.raw.SVGGElement
import typingsSlinky.d3DashArray.d3DashArrayMod.Bisector
import typingsSlinky.d3DashArray.d3DashArrayMod.HistogramGeneratorDate
import typingsSlinky.d3DashArray.d3DashArrayMod.HistogramGeneratorNumber
import typingsSlinky.d3DashArray.d3DashArrayMod.Numeric
import typingsSlinky.d3DashArray.d3DashArrayMod.Primitive
import typingsSlinky.d3DashAxis.d3DashAxisMod.Axis
import typingsSlinky.d3DashAxis.d3DashAxisMod.AxisDomain
import typingsSlinky.d3DashAxis.d3DashAxisMod.AxisScale
import typingsSlinky.d3DashBrush.d3DashBrushMod.BrushBehavior
import typingsSlinky.d3DashBrush.d3DashBrushMod.BrushSelection
import typingsSlinky.d3DashChord.d3DashChordMod.ChordLayout
import typingsSlinky.d3DashChord.d3DashChordMod.Ribbon
import typingsSlinky.d3DashChord.d3DashChordMod.RibbonGenerator
import typingsSlinky.d3DashChord.d3DashChordMod.RibbonSubgroup
import typingsSlinky.d3DashCollection.Anon_Key
import typingsSlinky.d3DashCollection.Anon_KeyValue
import typingsSlinky.d3DashCollection.d3DashCollectionMod.Nest
import typingsSlinky.d3DashCollection.d3DashCollectionMod.Set
import typingsSlinky.d3DashCollection.d3DashCollectionMod.Stringifiable
import typingsSlinky.d3DashColor.d3DashColorMod.ColorCommonInstance
import typingsSlinky.d3DashColor.d3DashColorMod.ColorFactory
import typingsSlinky.d3DashColor.d3DashColorMod.ColorSpaceObject
import typingsSlinky.d3DashColor.d3DashColorMod.CubehelixColor
import typingsSlinky.d3DashColor.d3DashColorMod.CubehelixColorFactory
import typingsSlinky.d3DashColor.d3DashColorMod.HCLColor
import typingsSlinky.d3DashColor.d3DashColorMod.HCLColorFactory
import typingsSlinky.d3DashColor.d3DashColorMod.HSLColor
import typingsSlinky.d3DashColor.d3DashColorMod.HSLColorFactory
import typingsSlinky.d3DashColor.d3DashColorMod.LabColor
import typingsSlinky.d3DashColor.d3DashColorMod.LabColorFactory
import typingsSlinky.d3DashColor.d3DashColorMod.RGBColor
import typingsSlinky.d3DashColor.d3DashColorMod.RGBColorFactory
import typingsSlinky.d3DashContour.d3DashContourMod.ContourDensity
import typingsSlinky.d3DashContour.d3DashContourMod.Contours
import typingsSlinky.d3DashDispatch.d3DashDispatchMod.Dispatch
import typingsSlinky.d3DashDrag.d3DashDragMod.DragBehavior
import typingsSlinky.d3DashDrag.d3DashDragMod.DraggedElementBaseType
import typingsSlinky.d3DashDrag.d3DashDragMod.SubjectPosition
import typingsSlinky.d3DashDsv.d3DashDsvMod.DSV
import typingsSlinky.d3DashDsv.d3DashDsvMod.DSVParsedArray
import typingsSlinky.d3DashDsv.d3DashDsvMod.DSVRowArray
import typingsSlinky.d3DashDsv.d3DashDsvMod.DSVRowString
import typingsSlinky.d3DashEase.d3DashEaseMod.BackEasingFactory
import typingsSlinky.d3DashEase.d3DashEaseMod.ElasticEasingFactory
import typingsSlinky.d3DashEase.d3DashEaseMod.PolynomialEasingFactory
import typingsSlinky.d3DashForce.d3DashForceMod.ForceCenter
import typingsSlinky.d3DashForce.d3DashForceMod.ForceCollide
import typingsSlinky.d3DashForce.d3DashForceMod.ForceLink
import typingsSlinky.d3DashForce.d3DashForceMod.ForceManyBody
import typingsSlinky.d3DashForce.d3DashForceMod.ForceRadial
import typingsSlinky.d3DashForce.d3DashForceMod.ForceX
import typingsSlinky.d3DashForce.d3DashForceMod.ForceY
import typingsSlinky.d3DashForce.d3DashForceMod.Simulation
import typingsSlinky.d3DashForce.d3DashForceMod.SimulationLinkDatum
import typingsSlinky.d3DashForce.d3DashForceMod.SimulationNodeDatum
import typingsSlinky.d3DashFormat.Anon_ValueOf
import typingsSlinky.d3DashFormat.d3DashFormatMod.FormatLocaleDefinition
import typingsSlinky.d3DashFormat.d3DashFormatMod.FormatLocaleObject
import typingsSlinky.d3DashFormat.d3DashFormatMod.FormatSpecifier
import typingsSlinky.d3DashGeo.Anon_S
import typingsSlinky.d3DashGeo.d3DashGeoMod.ExtendedFeature
import typingsSlinky.d3DashGeo.d3DashGeoMod.ExtendedFeatureCollection
import typingsSlinky.d3DashGeo.d3DashGeoMod.ExtendedGeometryCollection
import typingsSlinky.d3DashGeo.d3DashGeoMod.GeoCircleGenerator
import typingsSlinky.d3DashGeo.d3DashGeoMod.GeoConicProjection
import typingsSlinky.d3DashGeo.d3DashGeoMod.GeoContext
import typingsSlinky.d3DashGeo.d3DashGeoMod.GeoGeometryObjects
import typingsSlinky.d3DashGeo.d3DashGeoMod.GeoGraticuleGenerator
import typingsSlinky.d3DashGeo.d3DashGeoMod.GeoIdentityTransform
import typingsSlinky.d3DashGeo.d3DashGeoMod.GeoPath
import typingsSlinky.d3DashGeo.d3DashGeoMod.GeoPermissibleObjects
import typingsSlinky.d3DashGeo.d3DashGeoMod.GeoProjection
import typingsSlinky.d3DashGeo.d3DashGeoMod.GeoRawProjection
import typingsSlinky.d3DashGeo.d3DashGeoMod.GeoRotation
import typingsSlinky.d3DashGeo.d3DashGeoMod.GeoStream
import typingsSlinky.d3DashGeo.d3DashGeoMod.GeoStreamWrapper
import typingsSlinky.d3DashGeo.d3DashGeoMod.GeoTransformPrototype
import typingsSlinky.d3DashHierarchy.d3DashHierarchyMod.ClusterLayout
import typingsSlinky.d3DashHierarchy.d3DashHierarchyMod.HierarchyNode
import typingsSlinky.d3DashHierarchy.d3DashHierarchyMod.HierarchyRectangularNode
import typingsSlinky.d3DashHierarchy.d3DashHierarchyMod.PackCircle
import typingsSlinky.d3DashHierarchy.d3DashHierarchyMod.PackLayout
import typingsSlinky.d3DashHierarchy.d3DashHierarchyMod.PackRadius
import typingsSlinky.d3DashHierarchy.d3DashHierarchyMod.PartitionLayout
import typingsSlinky.d3DashHierarchy.d3DashHierarchyMod.RatioSquarifyTilingFactory
import typingsSlinky.d3DashHierarchy.d3DashHierarchyMod.StratifyOperator
import typingsSlinky.d3DashHierarchy.d3DashHierarchyMod.TreeLayout
import typingsSlinky.d3DashHierarchy.d3DashHierarchyMod.TreemapLayout
import typingsSlinky.d3DashInterpolate.Anon_ToString
import typingsSlinky.d3DashInterpolate.d3DashInterpolateMod.ArrayInterpolator
import typingsSlinky.d3DashInterpolate.d3DashInterpolateMod.ColorGammaInterpolationFactory
import typingsSlinky.d3DashInterpolate.d3DashInterpolateMod.ZoomInterpolator
import typingsSlinky.d3DashInterpolate.d3DashInterpolateMod.ZoomView
import typingsSlinky.d3DashPath.d3DashPathMod.Path
import typingsSlinky.d3DashQuadtree.d3DashQuadtreeMod.Quadtree
import typingsSlinky.d3DashRandom.d3DashRandomMod.RandomBates
import typingsSlinky.d3DashRandom.d3DashRandomMod.RandomExponential
import typingsSlinky.d3DashRandom.d3DashRandomMod.RandomIrwinHall
import typingsSlinky.d3DashRandom.d3DashRandomMod.RandomLogNormal
import typingsSlinky.d3DashRandom.d3DashRandomMod.RandomNormal
import typingsSlinky.d3DashRandom.d3DashRandomMod.RandomUniform
import typingsSlinky.d3DashScale.d3DashScaleMod.ScaleBand
import typingsSlinky.d3DashScale.d3DashScaleMod.ScaleDiverging
import typingsSlinky.d3DashScale.d3DashScaleMod.ScaleIdentity
import typingsSlinky.d3DashScale.d3DashScaleMod.ScaleLinear
import typingsSlinky.d3DashScale.d3DashScaleMod.ScaleLogarithmic
import typingsSlinky.d3DashScale.d3DashScaleMod.ScaleOrdinal
import typingsSlinky.d3DashScale.d3DashScaleMod.ScalePoint
import typingsSlinky.d3DashScale.d3DashScaleMod.ScalePower
import typingsSlinky.d3DashScale.d3DashScaleMod.ScaleQuantile
import typingsSlinky.d3DashScale.d3DashScaleMod.ScaleQuantize
import typingsSlinky.d3DashScale.d3DashScaleMod.ScaleSequential
import typingsSlinky.d3DashScale.d3DashScaleMod.ScaleThreshold
import typingsSlinky.d3DashScale.d3DashScaleMod.ScaleTime
import typingsSlinky.d3DashSelection.d3DashSelectionMod.BaseEvent
import typingsSlinky.d3DashSelection.d3DashSelectionMod.BaseType
import typingsSlinky.d3DashSelection.d3DashSelectionMod.ClientPointEvent
import typingsSlinky.d3DashSelection.d3DashSelectionMod.ContainerElement
import typingsSlinky.d3DashSelection.d3DashSelectionMod.EnterElement
import typingsSlinky.d3DashSelection.d3DashSelectionMod.Local
import typingsSlinky.d3DashSelection.d3DashSelectionMod.NamespaceLocalObject
import typingsSlinky.d3DashSelection.d3DashSelectionMod.NamespaceMap
import typingsSlinky.d3DashSelection.d3DashSelectionMod.Selection
import typingsSlinky.d3DashShape.d3DashShapeMod.Arc
import typingsSlinky.d3DashShape.d3DashShapeMod.Area
import typingsSlinky.d3DashShape.d3DashShapeMod.AreaRadial
import typingsSlinky.d3DashShape.d3DashShapeMod.CurveBundleFactory
import typingsSlinky.d3DashShape.d3DashShapeMod.CurveCardinalFactory
import typingsSlinky.d3DashShape.d3DashShapeMod.CurveCatmullRomFactory
import typingsSlinky.d3DashShape.d3DashShapeMod.CurveGenerator
import typingsSlinky.d3DashShape.d3DashShapeMod.DefaultArcObject
import typingsSlinky.d3DashShape.d3DashShapeMod.DefaultLinkObject
import typingsSlinky.d3DashShape.d3DashShapeMod.Line
import typingsSlinky.d3DashShape.d3DashShapeMod.LineRadial
import typingsSlinky.d3DashShape.d3DashShapeMod.Link
import typingsSlinky.d3DashShape.d3DashShapeMod.LinkRadial
import typingsSlinky.d3DashShape.d3DashShapeMod.Pie
import typingsSlinky.d3DashShape.d3DashShapeMod.RadialArea
import typingsSlinky.d3DashShape.d3DashShapeMod.RadialLine
import typingsSlinky.d3DashShape.d3DashShapeMod.Series
import typingsSlinky.d3DashShape.d3DashShapeMod.Stack
import typingsSlinky.d3DashShape.d3DashShapeMod.Symbol
import typingsSlinky.d3DashShape.d3DashShapeMod.SymbolType
import typingsSlinky.d3DashShape.d3DashShapeMod._Global_.CanvasRenderingContext2D
import typingsSlinky.d3DashTime.d3DashTimeMod.CountableTimeInterval
import typingsSlinky.d3DashTime.d3DashTimeMod.TimeInterval
import typingsSlinky.d3DashTimeDashFormat.d3DashTimeDashFormatMod.TimeLocaleDefinition
import typingsSlinky.d3DashTimeDashFormat.d3DashTimeDashFormatMod.TimeLocaleObject
import typingsSlinky.d3DashTimer.d3DashTimerMod.Timer
import typingsSlinky.d3DashTransition.d3DashTransitionMod.Transition
import typingsSlinky.d3DashVoronoi.d3DashVoronoiMod.VoronoiLayout
import typingsSlinky.d3DashZoom.d3DashZoomMod.ZoomBehavior
import typingsSlinky.d3DashZoom.d3DashZoomMod.ZoomTransform
import typingsSlinky.d3DashZoom.d3DashZoomMod.ZoomedElementBaseType
import typingsSlinky.geojson.geojsonMod.GeoJsonProperties
import typingsSlinky.geojson.geojsonMod.MultiLineString
import typingsSlinky.plotlyDotJs.plotlyDotJsMod.Config
import typingsSlinky.plotlyDotJs.plotlyDotJsMod.Data
import typingsSlinky.plotlyDotJs.plotlyDotJsMod.DownloadImgopts
import typingsSlinky.plotlyDotJs.plotlyDotJsMod.Frame
import typingsSlinky.plotlyDotJs.plotlyDotJsMod.Layout
import typingsSlinky.plotlyDotJs.plotlyDotJsMod.PlotlyHTMLElement
import typingsSlinky.plotlyDotJs.plotlyDotJsMod.Root
import typingsSlinky.plotlyDotJs.plotlyDotJsMod.StaticPlots
import typingsSlinky.plotlyDotJs.plotlyDotJsMod.ToImgopts
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.`object`
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.`var`
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.a
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.abbr
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.address
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.applet
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.area
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.article
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.aside
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.audio
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.b_
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.base
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.basefont
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.bdi
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.bdo
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.blockquote
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.body
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.br
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.button
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.canvas
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.caption
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.cite
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.code
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.col
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.colgroup
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.data
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.datalist
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.dd
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.del
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.details
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.dfn
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.dialog
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.dir
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.div
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.dl
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.dt
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.em
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.embed
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.fieldset
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.figcaption
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.figure
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.font
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.footer
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.form
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.frame
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.frameset
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.h1
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.h2
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.h3
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.h4
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.h5
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.h6
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.head
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.header
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.hgroup
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.hr
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.html
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.i
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.iframe
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.img
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.input
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.ins
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.kbd
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.label
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.legend
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.li
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.link
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.main
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.map
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.mark
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.marquee
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.menu
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.meta
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.meter
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.nav
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.noscript
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.ol
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.optgroup
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.option
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.output
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.p
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.param
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.picture
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.pre
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.progress
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.q
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.rp
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.rt
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.ruby
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.s
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.samp
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.script
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.section
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.select
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.slot
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.small
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.source
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.span
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.strong
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.style
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.sub
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.summary
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.sup
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.table
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.tbody
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.td
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.template
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.textarea
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.tfoot
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.th
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.thead
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.time
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.title
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.tr
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.track
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.u
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.ul
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.video
import typingsSlinky.plotlyDotJs.plotlyDotJsStrings.wbr
import typingsSlinky.std.ArrayLike
import typingsSlinky.std.Date
import typingsSlinky.std.Document
import typingsSlinky.std.Element
import typingsSlinky.std.Float32Array
import typingsSlinky.std.Float64Array
import typingsSlinky.std.HTMLDataElement
import typingsSlinky.std.HTMLDetailsElement
import typingsSlinky.std.HTMLDialogElement
import typingsSlinky.std.HTMLMeterElement
import typingsSlinky.std.HTMLOutputElement
import typingsSlinky.std.HTMLPictureElement
import typingsSlinky.std.HTMLSlotElement
import typingsSlinky.std.HTMLTemplateElement
import typingsSlinky.std.HTMLTimeElement
import typingsSlinky.std.Int16Array
import typingsSlinky.std.Int32Array
import typingsSlinky.std.Int8Array
import typingsSlinky.std.Iterable
import typingsSlinky.std.Map
import typingsSlinky.std.Partial
import typingsSlinky.std.TouchList
import typingsSlinky.std.Uint16Array
import typingsSlinky.std.Uint32Array
import typingsSlinky.std.Uint8Array
import typingsSlinky.std.Uint8ClampedArray
import typingsSlinky.std.Window
import typingsSlinky.std.XMLDocument
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

@JSImport("plotly.js/lib/core", JSImport.Namespace)
@js.native
object libCoreMod extends js.Object {
  val Plots: StaticPlots = js.native
  def addFrames(root: Root, frames: js.Array[Partial[Frame]]): js.Promise[PlotlyHTMLElement] = js.native
  def addTraces(root: Root, traces: js.Array[Data]): js.Promise[PlotlyHTMLElement] = js.native
  def addTraces(root: Root, traces: js.Array[Data], newIndices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = js.native
  def addTraces(root: Root, traces: js.Array[Data], newIndices: Double): js.Promise[PlotlyHTMLElement] = js.native
  def addTraces(root: Root, traces: Data): js.Promise[PlotlyHTMLElement] = js.native
  def addTraces(root: Root, traces: Data, newIndices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = js.native
  def addTraces(root: Root, traces: Data, newIndices: Double): js.Promise[PlotlyHTMLElement] = js.native
  def deleteFrames(root: Root, frames: js.Array[Double]): js.Promise[PlotlyHTMLElement] = js.native
  def deleteTraces(root: Root, indices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = js.native
  def deleteTraces(root: Root, indices: Double): js.Promise[PlotlyHTMLElement] = js.native
  def downloadImage(root: Root, opts: DownloadImgopts): js.Promise[String] = js.native
  def extendTraces(root: Root, update: js.Array[Data], indices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = js.native
  def extendTraces(root: Root, update: js.Array[Data], indices: Double): js.Promise[PlotlyHTMLElement] = js.native
  def extendTraces(root: Root, update: Data, indices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = js.native
  def extendTraces(root: Root, update: Data, indices: Double): js.Promise[PlotlyHTMLElement] = js.native
  def moveTraces(root: Root, currentIndices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = js.native
  def moveTraces(root: Root, currentIndices: js.Array[Double], newIndices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = js.native
  def moveTraces(root: Root, currentIndices: js.Array[Double], newIndices: Double): js.Promise[PlotlyHTMLElement] = js.native
  def moveTraces(root: Root, currentIndices: Double): js.Promise[PlotlyHTMLElement] = js.native
  def moveTraces(root: Root, currentIndices: Double, newIndices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = js.native
  def moveTraces(root: Root, currentIndices: Double, newIndices: Double): js.Promise[PlotlyHTMLElement] = js.native
  def newPlot(root: Root, data: js.Array[Data]): js.Promise[PlotlyHTMLElement] = js.native
  def newPlot(root: Root, data: js.Array[Data], layout: Partial[Layout]): js.Promise[PlotlyHTMLElement] = js.native
  def newPlot(root: Root, data: js.Array[Data], layout: Partial[Layout], config: Partial[Config]): js.Promise[PlotlyHTMLElement] = js.native
  def plot(root: Root, data: js.Array[Data]): js.Promise[PlotlyHTMLElement] = js.native
  def plot(root: Root, data: js.Array[Data], layout: Partial[Layout]): js.Promise[PlotlyHTMLElement] = js.native
  def plot(root: Root, data: js.Array[Data], layout: Partial[Layout], config: Partial[Config]): js.Promise[PlotlyHTMLElement] = js.native
  def prependTraces(root: Root, update: js.Array[Data], indices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = js.native
  def prependTraces(root: Root, update: js.Array[Data], indices: Double): js.Promise[PlotlyHTMLElement] = js.native
  def prependTraces(root: Root, update: Data, indices: js.Array[Double]): js.Promise[PlotlyHTMLElement] = js.native
  def prependTraces(root: Root, update: Data, indices: Double): js.Promise[PlotlyHTMLElement] = js.native
  def purge(root: Root): Unit = js.native
  def react(root: Root, data: js.Array[Data]): js.Promise[PlotlyHTMLElement] = js.native
  def react(root: Root, data: js.Array[Data], layout: Partial[Layout]): js.Promise[PlotlyHTMLElement] = js.native
  def react(root: Root, data: js.Array[Data], layout: Partial[Layout], config: Partial[Config]): js.Promise[PlotlyHTMLElement] = js.native
  def redraw(root: Root): js.Promise[PlotlyHTMLElement] = js.native
  def relayout(root: Root, layout: Partial[Layout]): js.Promise[PlotlyHTMLElement] = js.native
  def restyle(root: Root, aobj: Data): js.Promise[PlotlyHTMLElement] = js.native
  def restyle(root: Root, aobj: Data, traces: js.Array[Double]): js.Promise[PlotlyHTMLElement] = js.native
  def restyle(root: Root, aobj: Data, traces: Double): js.Promise[PlotlyHTMLElement] = js.native
  def toImage(root: Root, opts: ToImgopts): js.Promise[String] = js.native
  def update(root: Root, traceUpdate: Data, layoutUpdate: Partial[Layout]): js.Promise[PlotlyHTMLElement] = js.native
  def update(root: Root, traceUpdate: Data, layoutUpdate: Partial[Layout], traces: js.Array[Double]): js.Promise[PlotlyHTMLElement] = js.native
  def update(root: Root, traceUpdate: Data, layoutUpdate: Partial[Layout], traces: Double): js.Promise[PlotlyHTMLElement] = js.native
  @js.native
  object d3 extends js.Object {
    @JSName("color")
    val color_Original: ColorFactory = js.native
    @JSName("cubehelix")
    val cubehelix_Original: CubehelixColorFactory = js.native
    val curveBundle: CurveBundleFactory = js.native
    val curveCardinal: CurveCardinalFactory = js.native
    val curveCardinalClosed: CurveCardinalFactory = js.native
    val curveCardinalOpen: CurveCardinalFactory = js.native
    val curveCatmullRom: CurveCatmullRomFactory = js.native
    val curveCatmullRomClosed: CurveCatmullRomFactory = js.native
    val curveCatmullRomOpen: CurveCatmullRomFactory = js.native
    @JSName("easeBackInOut")
    val easeBackInOut_Original: BackEasingFactory = js.native
    @JSName("easeBackIn")
    val easeBackIn_Original: BackEasingFactory = js.native
    @JSName("easeBackOut")
    val easeBackOut_Original: BackEasingFactory = js.native
    @JSName("easeBack")
    val easeBack_Original: BackEasingFactory = js.native
    @JSName("easeElasticInOut")
    val easeElasticInOut_Original: ElasticEasingFactory = js.native
    @JSName("easeElasticIn")
    val easeElasticIn_Original: ElasticEasingFactory = js.native
    @JSName("easeElasticOut")
    val easeElasticOut_Original: ElasticEasingFactory = js.native
    @JSName("easeElastic")
    val easeElastic_Original: ElasticEasingFactory = js.native
    @JSName("easePolyInOut")
    val easePolyInOut_Original: PolynomialEasingFactory = js.native
    @JSName("easePolyIn")
    val easePolyIn_Original: PolynomialEasingFactory = js.native
    @JSName("easePolyOut")
    val easePolyOut_Original: PolynomialEasingFactory = js.native
    @JSName("easePoly")
    val easePoly_Original: PolynomialEasingFactory = js.native
    val event: js.Any = js.native
    @JSName("hcl")
    val hcl_Original: HCLColorFactory = js.native
    @JSName("hsl")
    val hsl_Original: HSLColorFactory = js.native
    @JSName("interpolateCubehelixLong")
    val interpolateCubehelixLong_Original: ColorGammaInterpolationFactory = js.native
    @JSName("interpolateCubehelix")
    val interpolateCubehelix_Original: ColorGammaInterpolationFactory = js.native
    @JSName("interpolateRgb")
    val interpolateRgb_Original: ColorGammaInterpolationFactory = js.native
    @JSName("lab")
    val lab_Original: LabColorFactory = js.native
    val namespaces: NamespaceMap = js.native
    @JSName("randomBates")
    val randomBates_Original: RandomBates = js.native
    @JSName("randomExponential")
    val randomExponential_Original: RandomExponential = js.native
    @JSName("randomIrwinHall")
    val randomIrwinHall_Original: RandomIrwinHall = js.native
    @JSName("randomLogNormal")
    val randomLogNormal_Original: RandomLogNormal = js.native
    @JSName("randomNormal")
    val randomNormal_Original: RandomNormal = js.native
    @JSName("randomUniform")
    val randomUniform_Original: RandomUniform = js.native
    @JSName("rgb")
    val rgb_Original: RGBColorFactory = js.native
    val scaleImplicit: Anon_Implicit = js.native
    val schemeAccent: js.Array[String] = js.native
    val schemeBlues: js.Array[js.Array[String]] = js.native
    val schemeBrBG: js.Array[js.Array[String]] = js.native
    val schemeBuGn: js.Array[js.Array[String]] = js.native
    val schemeBuPu: js.Array[js.Array[String]] = js.native
    val schemeCategory10: js.Array[String] = js.native
    val schemeDark2: js.Array[String] = js.native
    val schemeGnBu: js.Array[js.Array[String]] = js.native
    val schemeGreens: js.Array[js.Array[String]] = js.native
    val schemeGreys: js.Array[js.Array[String]] = js.native
    val schemeOrRd: js.Array[js.Array[String]] = js.native
    val schemeOranges: js.Array[js.Array[String]] = js.native
    val schemePRGn: js.Array[js.Array[String]] = js.native
    val schemePaired: js.Array[String] = js.native
    val schemePastel1: js.Array[String] = js.native
    val schemePastel2: js.Array[String] = js.native
    val schemePiYG: js.Array[js.Array[String]] = js.native
    val schemePuBu: js.Array[js.Array[String]] = js.native
    val schemePuBuGn: js.Array[js.Array[String]] = js.native
    val schemePuOr: js.Array[js.Array[String]] = js.native
    val schemePuRd: js.Array[js.Array[String]] = js.native
    val schemePurples: js.Array[js.Array[String]] = js.native
    val schemeRdBu: js.Array[js.Array[String]] = js.native
    val schemeRdGy: js.Array[js.Array[String]] = js.native
    val schemeRdPu: js.Array[js.Array[String]] = js.native
    val schemeRdYlBu: js.Array[js.Array[String]] = js.native
    val schemeRdYlGn: js.Array[js.Array[String]] = js.native
    val schemeReds: js.Array[js.Array[String]] = js.native
    val schemeSet1: js.Array[String] = js.native
    val schemeSet2: js.Array[String] = js.native
    val schemeSet3: js.Array[String] = js.native
    val schemeSpectral: js.Array[js.Array[String]] = js.native
    val schemeYlGn: js.Array[js.Array[String]] = js.native
    val schemeYlGnBu: js.Array[js.Array[String]] = js.native
    val schemeYlOrBr: js.Array[js.Array[String]] = js.native
    val schemeYlOrRd: js.Array[js.Array[String]] = js.native
    val symbolCircle: SymbolType = js.native
    val symbolCross: SymbolType = js.native
    val symbolDiamond: SymbolType = js.native
    val symbolSquare: SymbolType = js.native
    val symbolStar: SymbolType = js.native
    val symbolTriangle: SymbolType = js.native
    val symbolWye: SymbolType = js.native
    val symbols: js.Array[SymbolType] = js.native
    @JSName("timeDay")
    val timeDay_Original: CountableTimeInterval = js.native
    @JSName("timeFriday")
    val timeFriday_Original: CountableTimeInterval = js.native
    @JSName("timeHour")
    val timeHour_Original: CountableTimeInterval = js.native
    @JSName("timeMillisecond")
    val timeMillisecond_Original: CountableTimeInterval = js.native
    @JSName("timeMinute")
    val timeMinute_Original: CountableTimeInterval = js.native
    @JSName("timeMonday")
    val timeMonday_Original: CountableTimeInterval = js.native
    @JSName("timeMonth")
    val timeMonth_Original: CountableTimeInterval = js.native
    @JSName("timeSaturday")
    val timeSaturday_Original: CountableTimeInterval = js.native
    @JSName("timeSecond")
    val timeSecond_Original: CountableTimeInterval = js.native
    @JSName("timeSunday")
    val timeSunday_Original: CountableTimeInterval = js.native
    @JSName("timeThursday")
    val timeThursday_Original: CountableTimeInterval = js.native
    @JSName("timeTuesday")
    val timeTuesday_Original: CountableTimeInterval = js.native
    @JSName("timeWednesday")
    val timeWednesday_Original: CountableTimeInterval = js.native
    @JSName("timeWeek")
    val timeWeek_Original: CountableTimeInterval = js.native
    @JSName("timeYear")
    val timeYear_Original: CountableTimeInterval = js.native
    @JSName("treemapResquarify")
    val treemapResquarify_Original: RatioSquarifyTilingFactory = js.native
    @JSName("treemapSquarify")
    val treemapSquarify_Original: RatioSquarifyTilingFactory = js.native
    @JSName("utcDay")
    val utcDay_Original: CountableTimeInterval = js.native
    @JSName("utcFriday")
    val utcFriday_Original: CountableTimeInterval = js.native
    @JSName("utcHour")
    val utcHour_Original: CountableTimeInterval = js.native
    @JSName("utcMillisecond")
    val utcMillisecond_Original: CountableTimeInterval = js.native
    @JSName("utcMinute")
    val utcMinute_Original: CountableTimeInterval = js.native
    @JSName("utcMonday")
    val utcMonday_Original: CountableTimeInterval = js.native
    @JSName("utcMonth")
    val utcMonth_Original: CountableTimeInterval = js.native
    @JSName("utcSaturday")
    val utcSaturday_Original: CountableTimeInterval = js.native
    @JSName("utcSecond")
    val utcSecond_Original: CountableTimeInterval = js.native
    @JSName("utcSunday")
    val utcSunday_Original: CountableTimeInterval = js.native
    @JSName("utcThursday")
    val utcThursday_Original: CountableTimeInterval = js.native
    @JSName("utcTuesday")
    val utcTuesday_Original: CountableTimeInterval = js.native
    @JSName("utcWednesday")
    val utcWednesday_Original: CountableTimeInterval = js.native
    @JSName("utcWeek")
    val utcWeek_Original: CountableTimeInterval = js.native
    @JSName("utcYear")
    val utcYear_Original: CountableTimeInterval = js.native
    val version: String = js.native
    val zoomIdentity: ZoomTransform = js.native
    def active[Datum, PElement /* <: BaseType */, PDatum](): (Transition[Null, Datum, PElement, PDatum]) | Null = js.native
    def active[Datum, PElement /* <: BaseType */, PDatum](node: Null, name: String): (Transition[Null, Datum, PElement, PDatum]) | Null = js.native
    def active[Datum, PElement /* <: BaseType */, PDatum](node: EnterElement): (Transition[EnterElement, Datum, PElement, PDatum]) | Null = js.native
    def active[Datum, PElement /* <: BaseType */, PDatum](node: EnterElement, name: String): (Transition[EnterElement, Datum, PElement, PDatum]) | Null = js.native
    def active[Datum, PElement /* <: BaseType */, PDatum](node: Document): (Transition[org.scalajs.dom.raw.Document, Datum, PElement, PDatum]) | Null = js.native
    def active[Datum, PElement /* <: BaseType */, PDatum](node: Document, name: String): (Transition[org.scalajs.dom.raw.Document, Datum, PElement, PDatum]) | Null = js.native
    def active[Datum, PElement /* <: BaseType */, PDatum](node: Element): (Transition[org.scalajs.dom.raw.Element, Datum, PElement, PDatum]) | Null = js.native
    def active[Datum, PElement /* <: BaseType */, PDatum](node: Element, name: String): (Transition[org.scalajs.dom.raw.Element, Datum, PElement, PDatum]) | Null = js.native
    def active[Datum, PElement /* <: BaseType */, PDatum](node: Window): (Transition[org.scalajs.dom.raw.Window, Datum, PElement, PDatum]) | Null = js.native
    def active[Datum, PElement /* <: BaseType */, PDatum](node: Window, name: String): (Transition[org.scalajs.dom.raw.Window, Datum, PElement, PDatum]) | Null = js.native
    def arc(): Arc[_, DefaultArcObject] = js.native
    @JSName("arc")
    def arc_Datum[Datum](): Arc[_, Datum] = js.native
    @JSName("arc")
    def arc_ThisDatum[This, Datum](): Arc[This, Datum] = js.native
    def area(): Area[js.Tuple2[Double, Double]] = js.native
    def areaRadial(): AreaRadial[js.Tuple2[Double, Double]] = js.native
    @JSName("areaRadial")
    def areaRadial_Datum[Datum](): AreaRadial[Datum] = js.native
    @JSName("area")
    def area_Datum[Datum](): Area[Datum] = js.native
    def ascending(): Double = js.native
    def ascending(a: js.UndefOr[Primitive], b: Primitive): Double = js.native
    def ascending(a: Primitive): Double = js.native
    def axisBottom[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): Axis[Domain] = js.native
    def axisLeft[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): Axis[Domain] = js.native
    def axisRight[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): Axis[Domain] = js.native
    def axisTop[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): Axis[Domain] = js.native
    def bisect(array: ArrayLike[String], x: String): Double = js.native
    def bisect(array: ArrayLike[String], x: String, lo: Double): Double = js.native
    def bisect(array: ArrayLike[String], x: String, lo: Double, hi: Double): Double = js.native
    def bisect(array: ArrayLike[Double], x: Double): Double = js.native
    def bisect(array: ArrayLike[Double], x: Double, lo: Double): Double = js.native
    def bisect(array: ArrayLike[Double], x: Double, lo: Double, hi: Double): Double = js.native
    def bisect(array: ArrayLike[Date], x: Date): Double = js.native
    def bisect(array: ArrayLike[Date], x: Date, lo: Double): Double = js.native
    def bisect(array: ArrayLike[Date], x: Date, lo: Double, hi: Double): Double = js.native
    def bisectLeft(array: ArrayLike[String], x: String): Double = js.native
    def bisectLeft(array: ArrayLike[String], x: String, lo: Double): Double = js.native
    def bisectLeft(array: ArrayLike[String], x: String, lo: Double, hi: Double): Double = js.native
    def bisectLeft(array: ArrayLike[Double], x: Double): Double = js.native
    def bisectLeft(array: ArrayLike[Double], x: Double, lo: Double): Double = js.native
    def bisectLeft(array: ArrayLike[Double], x: Double, lo: Double, hi: Double): Double = js.native
    def bisectLeft(array: ArrayLike[Date], x: Date): Double = js.native
    def bisectLeft(array: ArrayLike[Date], x: Date, lo: Double): Double = js.native
    def bisectLeft(array: ArrayLike[Date], x: Date, lo: Double, hi: Double): Double = js.native
    def bisectRight(array: ArrayLike[String], x: String): Double = js.native
    def bisectRight(array: ArrayLike[String], x: String, lo: Double): Double = js.native
    def bisectRight(array: ArrayLike[String], x: String, lo: Double, hi: Double): Double = js.native
    def bisectRight(array: ArrayLike[Double], x: Double): Double = js.native
    def bisectRight(array: ArrayLike[Double], x: Double, lo: Double): Double = js.native
    def bisectRight(array: ArrayLike[Double], x: Double, lo: Double, hi: Double): Double = js.native
    def bisectRight(array: ArrayLike[Date], x: Date): Double = js.native
    def bisectRight(array: ArrayLike[Date], x: Date, lo: Double): Double = js.native
    def bisectRight(array: ArrayLike[Date], x: Date, lo: Double, hi: Double): Double = js.native
    def bisector[T, U](accessor: js.Function1[/* x */ T, U]): Bisector[T, U] = js.native
    def bisector[T, U](comparator: js.Function2[/* a */ T, /* b */ U, Double]): Bisector[T, U] = js.native
    def blob(url: String): js.Promise[Blob] = js.native
    def blob(url: String, init: RequestInit): js.Promise[Blob] = js.native
    def brush[Datum](): BrushBehavior[Datum] = js.native
    def brushSelection(node: SVGGElement): BrushSelection | Null = js.native
    def brushX[Datum](): BrushBehavior[Datum] = js.native
    def brushY[Datum](): BrushBehavior[Datum] = js.native
    def buffer(url: String): js.Promise[scala.scalajs.js.typedarray.ArrayBuffer] = js.native
    def buffer(url: String, init: RequestInit): js.Promise[scala.scalajs.js.typedarray.ArrayBuffer] = js.native
    def chord(): ChordLayout = js.native
    def clientPoint(container: ContainerElement, event: ClientPointEvent): js.Tuple2[Double, Double] = js.native
    def cluster[Datum](): ClusterLayout[Datum] = js.native
    def color(color: ColorCommonInstance): RGBColor | HSLColor = js.native
    /**
      * Converts the provided color instance and returns an RGB or HSL color.
      *
      * @param color A permissible color space instance.
      */
    def color(color: ColorSpaceObject): RGBColor | HSLColor = js.native
    /**
      * Parses the specified CSS Color Module Level 3 specifier string, returning an RGB or HSL color.
      * If the specifier was not valid, null is returned.
      *
      * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
      */
    def color(cssColorSpecifier: String): RGBColor | HSLColor | Null = js.native
    def contourDensity[Datum](): ContourDensity[Datum] = js.native
    def contours(): Contours = js.native
    def create[NewGElement /* <: org.scalajs.dom.raw.Element */](name: String): Selection[NewGElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_a(name: a): Selection[HTMLAnchorElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_abbr(name: abbr): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_address(name: address): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_applet(name: applet): Selection[HTMLAppletElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_area(name: area): Selection[HTMLAreaElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_article(name: article): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_aside(name: aside): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_audio(name: audio): Selection[HTMLAudioElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_b(name: b_): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_base(name: base): Selection[HTMLBaseElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_basefont(name: basefont): Selection[HTMLBaseFontElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_bdi(name: bdi): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_bdo(name: bdo): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_blockquote(name: blockquote): Selection[HTMLQuoteElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_body(name: body): Selection[HTMLBodyElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_br(name: br): Selection[HTMLBRElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_button(name: button): Selection[HTMLButtonElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_canvas(name: canvas): Selection[HTMLCanvasElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_caption(name: caption): Selection[HTMLTableCaptionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_cite(name: cite): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_code(name: code): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_col(name: col): Selection[HTMLTableColElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_colgroup(name: colgroup): Selection[HTMLTableColElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_data(name: data): Selection[HTMLDataElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_datalist(name: datalist): Selection[HTMLDataListElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_dd(name: dd): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_del(name: del): Selection[HTMLModElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_details(name: details): Selection[HTMLDetailsElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_dfn(name: dfn): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_dialog(name: dialog): Selection[HTMLDialogElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_dir(name: dir): Selection[HTMLDirectoryElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_div(name: div): Selection[HTMLDivElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_dl(name: dl): Selection[HTMLDListElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_dt(name: dt): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_em(name: em): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_embed(name: embed): Selection[HTMLEmbedElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_fieldset(name: fieldset): Selection[HTMLFieldSetElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_figcaption(name: figcaption): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_figure(name: figure): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_font(name: font): Selection[HTMLFontElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_footer(name: footer): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_form(name: form): Selection[HTMLFormElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_frame(name: frame): Selection[HTMLFrameElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_frameset(name: frameset): Selection[HTMLFrameSetElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_h1(name: h1): Selection[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_h2(name: h2): Selection[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_h3(name: h3): Selection[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_h4(name: h4): Selection[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_h5(name: h5): Selection[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_h6(name: h6): Selection[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_head(name: head): Selection[HTMLHeadElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_header(name: header): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_hgroup(name: hgroup): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_hr(name: hr): Selection[HTMLHRElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_html(name: html): Selection[HTMLHtmlElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_i(name: i): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_iframe(name: iframe): Selection[HTMLIFrameElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_img(name: img): Selection[HTMLImageElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_input(name: input): Selection[HTMLInputElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_ins(name: ins): Selection[HTMLModElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_kbd(name: kbd): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_label(name: label): Selection[HTMLLabelElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_legend(name: legend): Selection[HTMLLegendElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_li(name: li): Selection[HTMLLIElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_link(name: link): Selection[HTMLLinkElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_main(name: main): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_map(name: map): Selection[HTMLMapElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_mark(name: mark): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_marquee(name: marquee): Selection[HTMLMarqueeElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_menu(name: menu): Selection[HTMLMenuElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_meta(name: meta): Selection[HTMLMetaElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_meter(name: meter): Selection[HTMLMeterElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_nav(name: nav): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_noscript(name: noscript): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_object(name: `object`): Selection[HTMLObjectElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_ol(name: ol): Selection[HTMLOListElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_optgroup(name: optgroup): Selection[HTMLOptGroupElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_option(name: option): Selection[HTMLOptionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_output(name: output): Selection[HTMLOutputElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_p(name: p): Selection[HTMLParagraphElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_param(name: param): Selection[HTMLParamElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_picture(name: picture): Selection[HTMLPictureElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_pre(name: pre): Selection[HTMLPreElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_progress(name: progress): Selection[HTMLProgressElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_q(name: q): Selection[HTMLQuoteElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_rp(name: rp): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_rt(name: rt): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_ruby(name: ruby): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_s(name: s): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_samp(name: samp): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_script(name: script): Selection[HTMLScriptElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_section(name: section): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_select(name: select): Selection[HTMLSelectElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_slot(name: slot): Selection[HTMLSlotElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_small(name: small): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_source(name: source): Selection[HTMLSourceElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_span(name: span): Selection[HTMLSpanElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_strong(name: strong): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_style(name: style): Selection[HTMLStyleElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_sub(name: sub): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_summary(name: summary): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_sup(name: sup): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_table(name: table): Selection[HTMLTableElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_tbody(name: tbody): Selection[HTMLTableSectionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_td(name: td): Selection[HTMLTableDataCellElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_template(name: template): Selection[HTMLTemplateElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_textarea(name: textarea): Selection[HTMLTextAreaElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_tfoot(name: tfoot): Selection[HTMLTableSectionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_th(name: th): Selection[HTMLTableHeaderCellElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_thead(name: thead): Selection[HTMLTableSectionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_time(name: time): Selection[HTMLTimeElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_title(name: title): Selection[HTMLTitleElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_tr(name: tr): Selection[HTMLTableRowElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_track(name: track): Selection[HTMLTrackElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_u(name: u): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_ul(name: ul): Selection[HTMLUListElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_var(name: `var`): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_video(name: video): Selection[HTMLVideoElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    @JSName("create")
    def create_wbr(name: wbr): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    def creator[NewGElement /* <: org.scalajs.dom.raw.Element */](name: String): js.ThisFunction0[/* this */ BaseType, NewGElement] = js.native
    @JSName("creator")
    def creator_a(name: a): js.ThisFunction0[/* this */ BaseType, HTMLAnchorElement] = js.native
    @JSName("creator")
    def creator_abbr(name: abbr): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_address(name: address): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_applet(name: applet): js.ThisFunction0[/* this */ BaseType, HTMLAppletElement] = js.native
    @JSName("creator")
    def creator_area(name: area): js.ThisFunction0[/* this */ BaseType, HTMLAreaElement] = js.native
    @JSName("creator")
    def creator_article(name: article): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_aside(name: aside): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_audio(name: audio): js.ThisFunction0[/* this */ BaseType, HTMLAudioElement] = js.native
    @JSName("creator")
    def creator_b(name: b_): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_base(name: base): js.ThisFunction0[/* this */ BaseType, HTMLBaseElement] = js.native
    @JSName("creator")
    def creator_basefont(name: basefont): js.ThisFunction0[/* this */ BaseType, HTMLBaseFontElement] = js.native
    @JSName("creator")
    def creator_bdi(name: bdi): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_bdo(name: bdo): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_blockquote(name: blockquote): js.ThisFunction0[/* this */ BaseType, HTMLQuoteElement] = js.native
    @JSName("creator")
    def creator_body(name: body): js.ThisFunction0[/* this */ BaseType, HTMLBodyElement] = js.native
    @JSName("creator")
    def creator_br(name: br): js.ThisFunction0[/* this */ BaseType, HTMLBRElement] = js.native
    @JSName("creator")
    def creator_button(name: button): js.ThisFunction0[/* this */ BaseType, HTMLButtonElement] = js.native
    @JSName("creator")
    def creator_canvas(name: canvas): js.ThisFunction0[/* this */ BaseType, HTMLCanvasElement] = js.native
    @JSName("creator")
    def creator_caption(name: caption): js.ThisFunction0[/* this */ BaseType, HTMLTableCaptionElement] = js.native
    @JSName("creator")
    def creator_cite(name: cite): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_code(name: code): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_col(name: col): js.ThisFunction0[/* this */ BaseType, HTMLTableColElement] = js.native
    @JSName("creator")
    def creator_colgroup(name: colgroup): js.ThisFunction0[/* this */ BaseType, HTMLTableColElement] = js.native
    @JSName("creator")
    def creator_data(name: data): js.ThisFunction0[/* this */ BaseType, HTMLDataElement] = js.native
    @JSName("creator")
    def creator_datalist(name: datalist): js.ThisFunction0[/* this */ BaseType, HTMLDataListElement] = js.native
    @JSName("creator")
    def creator_dd(name: dd): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_del(name: del): js.ThisFunction0[/* this */ BaseType, HTMLModElement] = js.native
    @JSName("creator")
    def creator_details(name: details): js.ThisFunction0[/* this */ BaseType, HTMLDetailsElement] = js.native
    @JSName("creator")
    def creator_dfn(name: dfn): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_dialog(name: dialog): js.ThisFunction0[/* this */ BaseType, HTMLDialogElement] = js.native
    @JSName("creator")
    def creator_dir(name: dir): js.ThisFunction0[/* this */ BaseType, HTMLDirectoryElement] = js.native
    @JSName("creator")
    def creator_div(name: div): js.ThisFunction0[/* this */ BaseType, HTMLDivElement] = js.native
    @JSName("creator")
    def creator_dl(name: dl): js.ThisFunction0[/* this */ BaseType, HTMLDListElement] = js.native
    @JSName("creator")
    def creator_dt(name: dt): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_em(name: em): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_embed(name: embed): js.ThisFunction0[/* this */ BaseType, HTMLEmbedElement] = js.native
    @JSName("creator")
    def creator_fieldset(name: fieldset): js.ThisFunction0[/* this */ BaseType, HTMLFieldSetElement] = js.native
    @JSName("creator")
    def creator_figcaption(name: figcaption): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_figure(name: figure): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_font(name: font): js.ThisFunction0[/* this */ BaseType, HTMLFontElement] = js.native
    @JSName("creator")
    def creator_footer(name: footer): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_form(name: form): js.ThisFunction0[/* this */ BaseType, HTMLFormElement] = js.native
    @JSName("creator")
    def creator_frame(name: frame): js.ThisFunction0[/* this */ BaseType, HTMLFrameElement] = js.native
    @JSName("creator")
    def creator_frameset(name: frameset): js.ThisFunction0[/* this */ BaseType, HTMLFrameSetElement] = js.native
    @JSName("creator")
    def creator_h1(name: h1): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
    @JSName("creator")
    def creator_h2(name: h2): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
    @JSName("creator")
    def creator_h3(name: h3): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
    @JSName("creator")
    def creator_h4(name: h4): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
    @JSName("creator")
    def creator_h5(name: h5): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
    @JSName("creator")
    def creator_h6(name: h6): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
    @JSName("creator")
    def creator_head(name: head): js.ThisFunction0[/* this */ BaseType, HTMLHeadElement] = js.native
    @JSName("creator")
    def creator_header(name: header): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_hgroup(name: hgroup): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_hr(name: hr): js.ThisFunction0[/* this */ BaseType, HTMLHRElement] = js.native
    @JSName("creator")
    def creator_html(name: html): js.ThisFunction0[/* this */ BaseType, HTMLHtmlElement] = js.native
    @JSName("creator")
    def creator_i(name: i): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_iframe(name: iframe): js.ThisFunction0[/* this */ BaseType, HTMLIFrameElement] = js.native
    @JSName("creator")
    def creator_img(name: img): js.ThisFunction0[/* this */ BaseType, HTMLImageElement] = js.native
    @JSName("creator")
    def creator_input(name: input): js.ThisFunction0[/* this */ BaseType, HTMLInputElement] = js.native
    @JSName("creator")
    def creator_ins(name: ins): js.ThisFunction0[/* this */ BaseType, HTMLModElement] = js.native
    @JSName("creator")
    def creator_kbd(name: kbd): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_label(name: label): js.ThisFunction0[/* this */ BaseType, HTMLLabelElement] = js.native
    @JSName("creator")
    def creator_legend(name: legend): js.ThisFunction0[/* this */ BaseType, HTMLLegendElement] = js.native
    @JSName("creator")
    def creator_li(name: li): js.ThisFunction0[/* this */ BaseType, HTMLLIElement] = js.native
    @JSName("creator")
    def creator_link(name: link): js.ThisFunction0[/* this */ BaseType, HTMLLinkElement] = js.native
    @JSName("creator")
    def creator_main(name: main): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_map(name: map): js.ThisFunction0[/* this */ BaseType, HTMLMapElement] = js.native
    @JSName("creator")
    def creator_mark(name: mark): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_marquee(name: marquee): js.ThisFunction0[/* this */ BaseType, HTMLMarqueeElement] = js.native
    @JSName("creator")
    def creator_menu(name: menu): js.ThisFunction0[/* this */ BaseType, HTMLMenuElement] = js.native
    @JSName("creator")
    def creator_meta(name: meta): js.ThisFunction0[/* this */ BaseType, HTMLMetaElement] = js.native
    @JSName("creator")
    def creator_meter(name: meter): js.ThisFunction0[/* this */ BaseType, HTMLMeterElement] = js.native
    @JSName("creator")
    def creator_nav(name: nav): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_noscript(name: noscript): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_object(name: `object`): js.ThisFunction0[/* this */ BaseType, HTMLObjectElement] = js.native
    @JSName("creator")
    def creator_ol(name: ol): js.ThisFunction0[/* this */ BaseType, HTMLOListElement] = js.native
    @JSName("creator")
    def creator_optgroup(name: optgroup): js.ThisFunction0[/* this */ BaseType, HTMLOptGroupElement] = js.native
    @JSName("creator")
    def creator_option(name: option): js.ThisFunction0[/* this */ BaseType, HTMLOptionElement] = js.native
    @JSName("creator")
    def creator_output(name: output): js.ThisFunction0[/* this */ BaseType, HTMLOutputElement] = js.native
    @JSName("creator")
    def creator_p(name: p): js.ThisFunction0[/* this */ BaseType, HTMLParagraphElement] = js.native
    @JSName("creator")
    def creator_param(name: param): js.ThisFunction0[/* this */ BaseType, HTMLParamElement] = js.native
    @JSName("creator")
    def creator_picture(name: picture): js.ThisFunction0[/* this */ BaseType, HTMLPictureElement] = js.native
    @JSName("creator")
    def creator_pre(name: pre): js.ThisFunction0[/* this */ BaseType, HTMLPreElement] = js.native
    @JSName("creator")
    def creator_progress(name: progress): js.ThisFunction0[/* this */ BaseType, HTMLProgressElement] = js.native
    @JSName("creator")
    def creator_q(name: q): js.ThisFunction0[/* this */ BaseType, HTMLQuoteElement] = js.native
    @JSName("creator")
    def creator_rp(name: rp): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_rt(name: rt): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_ruby(name: ruby): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_s(name: s): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_samp(name: samp): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_script(name: script): js.ThisFunction0[/* this */ BaseType, HTMLScriptElement] = js.native
    @JSName("creator")
    def creator_section(name: section): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_select(name: select): js.ThisFunction0[/* this */ BaseType, HTMLSelectElement] = js.native
    @JSName("creator")
    def creator_slot(name: slot): js.ThisFunction0[/* this */ BaseType, HTMLSlotElement] = js.native
    @JSName("creator")
    def creator_small(name: small): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_source(name: source): js.ThisFunction0[/* this */ BaseType, HTMLSourceElement] = js.native
    @JSName("creator")
    def creator_span(name: span): js.ThisFunction0[/* this */ BaseType, HTMLSpanElement] = js.native
    @JSName("creator")
    def creator_strong(name: strong): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_style(name: style): js.ThisFunction0[/* this */ BaseType, HTMLStyleElement] = js.native
    @JSName("creator")
    def creator_sub(name: sub): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_summary(name: summary): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_sup(name: sup): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_table(name: table): js.ThisFunction0[/* this */ BaseType, HTMLTableElement] = js.native
    @JSName("creator")
    def creator_tbody(name: tbody): js.ThisFunction0[/* this */ BaseType, HTMLTableSectionElement] = js.native
    @JSName("creator")
    def creator_td(name: td): js.ThisFunction0[/* this */ BaseType, HTMLTableDataCellElement] = js.native
    @JSName("creator")
    def creator_template(name: template): js.ThisFunction0[/* this */ BaseType, HTMLTemplateElement] = js.native
    @JSName("creator")
    def creator_textarea(name: textarea): js.ThisFunction0[/* this */ BaseType, HTMLTextAreaElement] = js.native
    @JSName("creator")
    def creator_tfoot(name: tfoot): js.ThisFunction0[/* this */ BaseType, HTMLTableSectionElement] = js.native
    @JSName("creator")
    def creator_th(name: th): js.ThisFunction0[/* this */ BaseType, HTMLTableHeaderCellElement] = js.native
    @JSName("creator")
    def creator_thead(name: thead): js.ThisFunction0[/* this */ BaseType, HTMLTableSectionElement] = js.native
    @JSName("creator")
    def creator_time(name: time): js.ThisFunction0[/* this */ BaseType, HTMLTimeElement] = js.native
    @JSName("creator")
    def creator_title(name: title): js.ThisFunction0[/* this */ BaseType, HTMLTitleElement] = js.native
    @JSName("creator")
    def creator_tr(name: tr): js.ThisFunction0[/* this */ BaseType, HTMLTableRowElement] = js.native
    @JSName("creator")
    def creator_track(name: track): js.ThisFunction0[/* this */ BaseType, HTMLTrackElement] = js.native
    @JSName("creator")
    def creator_u(name: u): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_ul(name: ul): js.ThisFunction0[/* this */ BaseType, HTMLUListElement] = js.native
    @JSName("creator")
    def creator_var(name: `var`): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    @JSName("creator")
    def creator_video(name: video): js.ThisFunction0[/* this */ BaseType, HTMLVideoElement] = js.native
    @JSName("creator")
    def creator_wbr(name: wbr): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
    def cross[S, T](a: js.Iterable[S], b: js.Iterable[T]): js.Array[js.Tuple2[S, T]] = js.native
    def cross[S, T, U](a: js.Iterable[S], b: js.Iterable[T], reducer: js.Function2[/* a */ S, /* b */ T, U]): js.Array[U] = js.native
    def csv[Columns /* <: String */](url: String): js.Promise[DSVRowArray[Columns]] = js.native
    def csv[Columns /* <: String */](url: String, init: typingsSlinky.std.RequestInit): js.Promise[DSVRowArray[Columns]] = js.native
    def csv[ParsedRow /* <: js.Object */, Columns /* <: String */](
      url: String,
      init: typingsSlinky.std.RequestInit,
      row: js.Function3[
          /* rawRow */ DSVRowString[Columns], 
          /* index */ Double, 
          /* columns */ js.Array[Columns], 
          js.UndefOr[ParsedRow | Null]
        ]
    ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
    def csv[ParsedRow /* <: js.Object */, Columns /* <: String */](
      url: String,
      row: js.Function3[
          /* rawRow */ DSVRowString[Columns], 
          /* index */ Double, 
          /* columns */ js.Array[Columns], 
          js.UndefOr[ParsedRow | Null]
        ]
    ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
    def csvFormat[T /* <: js.Object */](rows: js.Array[T]): String = js.native
    def csvFormat[T /* <: js.Object */](rows: js.Array[T], columns: js.Array[String]): String = js.native
    def csvFormatRows(rows: js.Array[js.Array[String]]): String = js.native
    def csvParse[Columns /* <: String */](csvString: String): DSVRowArray[Columns] = js.native
    def csvParse[ParsedRow /* <: js.Object */, Columns /* <: String */](
      csvString: String,
      row: js.Function3[
          /* rawRow */ DSVRowString[Columns], 
          /* index */ Double, 
          /* columns */ js.Array[Columns], 
          js.UndefOr[ParsedRow | Null]
        ]
    ): DSVParsedArray[ParsedRow] = js.native
    def csvParseRows(csvString: String): js.Array[js.Array[String]] = js.native
    def csvParseRows[ParsedRow /* <: js.Object */](
      csvString: String,
      row: js.Function2[/* rawRow */ js.Array[String], /* index */ Double, js.UndefOr[ParsedRow | Null]]
    ): js.Array[ParsedRow] = js.native
    def cubehelix(color: ColorCommonInstance): CubehelixColor = js.native
    /**
      * Converts the provided color instance and returns a Cubehelix color.
      * The color instance is specified, it is converted to the RGB color space using color.rgb and then converted to Cubehelix.
      * (Colors already in the Cubehelix color space skip the conversion to RGB.)
      *
      * @param color A permissible color space instance.
      */
    def cubehelix(color: ColorSpaceObject): CubehelixColor = js.native
    /**
      * Parses the specified CSS Color Module Level 3 specifier string, returning an Cubehelix color.
      * If the specifier was not valid, null is returned.
      *
      * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
      */
    def cubehelix(cssColorSpecifier: String): CubehelixColor = js.native
    /**
      * Constructs a new Cubehelix color based on the specified channel values and opacity.
      *
      * @param h Hue channel value.
      * @param s Saturation channel value.
      * @param l Lightness channel value.
      * @param opacity Optional opacity value, defaults to 1.
      */
    def cubehelix(h: Double, s: Double, l: Double): CubehelixColor = js.native
    def cubehelix(h: Double, s: Double, l: Double, opacity: Double): CubehelixColor = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveBasis(context: Path): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveBasis(context: CanvasRenderingContext2D): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveBasisClosed(context: Path): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveBasisClosed(context: CanvasRenderingContext2D): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveBasisOpen(context: Path): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveBasisOpen(context: CanvasRenderingContext2D): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveLinear(context: Path): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveLinear(context: CanvasRenderingContext2D): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveLinearClosed(context: Path): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveLinearClosed(context: CanvasRenderingContext2D): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveMonotoneX(context: Path): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveMonotoneX(context: CanvasRenderingContext2D): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveMonotoneY(context: Path): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveMonotoneY(context: CanvasRenderingContext2D): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveNatural(context: Path): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveNatural(context: CanvasRenderingContext2D): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveStep(context: Path): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveStep(context: CanvasRenderingContext2D): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveStepAfter(context: Path): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveStepAfter(context: CanvasRenderingContext2D): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveStepBefore(context: Path): CurveGenerator = js.native
    /**
      * Returns a curve generator which renders to the specified context.
      *
      * @param context A rendering context.
      */
    def curveStepBefore(context: CanvasRenderingContext2D): CurveGenerator = js.native
    def customEvent[Context, Result](
      event: BaseEvent,
      listener: js.ThisFunction1[/* this */ Context, /* repeated */ js.Any, Result],
      that: Context,
      args: js.Any*
    ): Result = js.native
    def descending(): Double = js.native
    def descending(a: js.UndefOr[Primitive], b: Primitive): Double = js.native
    def descending(a: Primitive): Double = js.native
    def deviation[T /* <: Numeric */](array: Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = js.native
    def deviation[T](
      array: Iterable[T],
      accessor: js.Function3[
          /* datum */ T, 
          /* index */ Double, 
          /* array */ js.Iterable[T], 
          js.UndefOr[Double | Null]
        ]
    ): js.UndefOr[Double] = js.native
    def dispatch[T /* <: EventTarget */](types: String*): Dispatch[T] = js.native
    def drag[GElement /* <: DraggedElementBaseType */, Datum](): DragBehavior[GElement, Datum, Datum | SubjectPosition] = js.native
    def dragDisable(window: org.scalajs.dom.raw.Window): Unit = js.native
    def dragEnable(window: org.scalajs.dom.raw.Window): Unit = js.native
    def dragEnable(window: org.scalajs.dom.raw.Window, noClick: Boolean): Unit = js.native
    @JSName("drag")
    def drag_GElement_DraggedElementBaseTypeDatumSubject[GElement /* <: DraggedElementBaseType */, Datum, Subject](): DragBehavior[GElement, Datum, Subject] = js.native
    def dsv[Columns /* <: String */](delimiter: String, url: String): js.Promise[DSVRowArray[Columns]] = js.native
    def dsv[Columns /* <: String */](delimiter: String, url: String, init: typingsSlinky.std.RequestInit): js.Promise[DSVRowArray[Columns]] = js.native
    def dsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
      delimiter: String,
      url: String,
      init: typingsSlinky.std.RequestInit,
      row: js.Function3[
          /* rawRow */ DSVRowString[Columns], 
          /* index */ Double, 
          /* columns */ js.Array[Columns], 
          js.UndefOr[ParsedRow | Null]
        ]
    ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
    def dsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
      delimiter: String,
      url: String,
      row: js.Function3[
          /* rawRow */ DSVRowString[Columns], 
          /* index */ Double, 
          /* columns */ js.Array[Columns], 
          js.UndefOr[ParsedRow | Null]
        ]
    ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
    def dsvFormat(delimiter: String): DSV = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    def easeBack(normalizedTime: Double): Double = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    def easeBackIn(normalizedTime: Double): Double = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    def easeBackInOut(normalizedTime: Double): Double = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    def easeBackOut(normalizedTime: Double): Double = js.native
    def easeBounce(normalizedTime: Double): Double = js.native
    def easeBounceIn(normalizedTime: Double): Double = js.native
    def easeBounceInOut(normalizedTime: Double): Double = js.native
    def easeBounceOut(normalizedTime: Double): Double = js.native
    def easeCircle(normalizedTime: Double): Double = js.native
    def easeCircleIn(normalizedTime: Double): Double = js.native
    def easeCircleInOut(normalizedTime: Double): Double = js.native
    def easeCircleOut(normalizedTime: Double): Double = js.native
    def easeCubic(normalizedTime: Double): Double = js.native
    def easeCubicIn(normalizedTime: Double): Double = js.native
    def easeCubicInOut(normalizedTime: Double): Double = js.native
    def easeCubicOut(normalizedTime: Double): Double = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    def easeElastic(normalizedTime: Double): Double = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    def easeElasticIn(normalizedTime: Double): Double = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    def easeElasticInOut(normalizedTime: Double): Double = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    def easeElasticOut(normalizedTime: Double): Double = js.native
    def easeExp(normalizedTime: Double): Double = js.native
    def easeExpIn(normalizedTime: Double): Double = js.native
    def easeExpInOut(normalizedTime: Double): Double = js.native
    def easeExpOut(normalizedTime: Double): Double = js.native
    def easeLinear(normalizedTime: Double): Double = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    def easePoly(normalizedTime: Double): Double = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    def easePolyIn(normalizedTime: Double): Double = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    def easePolyInOut(normalizedTime: Double): Double = js.native
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    def easePolyOut(normalizedTime: Double): Double = js.native
    def easeQuad(normalizedTime: Double): Double = js.native
    def easeQuadIn(normalizedTime: Double): Double = js.native
    def easeQuadInOut(normalizedTime: Double): Double = js.native
    def easeQuadOut(normalizedTime: Double): Double = js.native
    def easeSin(normalizedTime: Double): Double = js.native
    def easeSinIn(normalizedTime: Double): Double = js.native
    def easeSinInOut(normalizedTime: Double): Double = js.native
    def easeSinOut(normalizedTime: Double): Double = js.native
    def entries(obj: js.Object): js.Array[Anon_KeyValue] = js.native
    def entries[T](obj: StringDictionary[T]): js.Array[Anon_Key[T]] = js.native
    def entries[T](obj: ArrayLike[T]): js.Array[Anon_Key[T]] = js.native
    def extent(array: Iterable[String]): js.Tuple2[js.UndefOr[String], js.UndefOr[String]] = js.native
    def extent[T](
      array: Iterable[T],
      accessor: js.Function3[
          /* datum */ T, 
          /* index */ Double, 
          /* array */ js.Iterable[T], 
          js.UndefOr[String | Null]
        ]
    ): js.Tuple2[js.UndefOr[String], js.UndefOr[String]] = js.native
    @JSName("extent")
    def extent_TU_Numeric[T, U /* <: Numeric */](
      array: js.Iterable[T],
      accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ js.Iterable[T], js.UndefOr[U | Null]]
    ): js.Tuple2[js.UndefOr[U], js.UndefOr[U]] = js.native
    @JSName("extent")
    def extent_T_Numeric[T /* <: Numeric */](array: js.Iterable[T]): js.Tuple2[js.UndefOr[T], js.UndefOr[T]] = js.native
    def forceCenter[NodeDatum /* <: SimulationNodeDatum */](): ForceCenter[NodeDatum] = js.native
    def forceCenter[NodeDatum /* <: SimulationNodeDatum */](x: Double): ForceCenter[NodeDatum] = js.native
    def forceCenter[NodeDatum /* <: SimulationNodeDatum */](x: Double, y: Double): ForceCenter[NodeDatum] = js.native
    def forceCollide[NodeDatum /* <: SimulationNodeDatum */](): ForceCollide[NodeDatum] = js.native
    def forceCollide[NodeDatum /* <: SimulationNodeDatum */](
      radius: js.Function3[/* node */ NodeDatum, /* i */ Double, /* nodes */ js.Array[NodeDatum], Double]
    ): ForceCollide[NodeDatum] = js.native
    def forceCollide[NodeDatum /* <: SimulationNodeDatum */](radius: Double): ForceCollide[NodeDatum] = js.native
    def forceLink[NodeDatum /* <: SimulationNodeDatum */, LinksDatum /* <: SimulationLinkDatum[NodeDatum] */](): ForceLink[NodeDatum, LinksDatum] = js.native
    def forceLink[NodeDatum /* <: SimulationNodeDatum */, LinksDatum /* <: SimulationLinkDatum[NodeDatum] */](links: js.Array[LinksDatum]): ForceLink[NodeDatum, LinksDatum] = js.native
    def forceManyBody[NodeDatum /* <: SimulationNodeDatum */](): ForceManyBody[NodeDatum] = js.native
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]): ForceRadial[NodeDatum] = js.native
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
    ): ForceRadial[NodeDatum] = js.native
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
    ): ForceRadial[NodeDatum] = js.native
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      y: Double
    ): ForceRadial[NodeDatum] = js.native
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      x: Double
    ): ForceRadial[NodeDatum] = js.native
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      x: Double,
      y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
    ): ForceRadial[NodeDatum] = js.native
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      x: Double,
      y: Double
    ): ForceRadial[NodeDatum] = js.native
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: Double): ForceRadial[NodeDatum] = js.native
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: Double,
      x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
    ): ForceRadial[NodeDatum] = js.native
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: Double,
      x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
    ): ForceRadial[NodeDatum] = js.native
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: Double,
      x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
      y: Double
    ): ForceRadial[NodeDatum] = js.native
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: Double, x: Double): ForceRadial[NodeDatum] = js.native
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
      radius: Double,
      x: Double,
      y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
    ): ForceRadial[NodeDatum] = js.native
    def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: Double, x: Double, y: Double): ForceRadial[NodeDatum] = js.native
    def forceSimulation[NodeDatum /* <: SimulationNodeDatum */](): Simulation[NodeDatum, js.UndefOr[scala.Nothing]] = js.native
    def forceSimulation[NodeDatum /* <: SimulationNodeDatum */](nodesData: js.Array[NodeDatum]): Simulation[NodeDatum, js.UndefOr[scala.Nothing]] = js.native
    @JSName("forceSimulation")
    def forceSimulation_NodeDatum_SimulationNodeDatumLinkDatum_SimulationLinkDatumNodeDatum[NodeDatum /* <: SimulationNodeDatum */, LinkDatum /* <: SimulationLinkDatum[NodeDatum] */](): Simulation[NodeDatum, LinkDatum] = js.native
    @JSName("forceSimulation")
    def forceSimulation_NodeDatum_SimulationNodeDatumLinkDatum_SimulationLinkDatumNodeDatum[NodeDatum /* <: SimulationNodeDatum */, LinkDatum /* <: SimulationLinkDatum[NodeDatum] */](nodesData: js.Array[NodeDatum]): Simulation[NodeDatum, LinkDatum] = js.native
    def forceX[NodeDatum /* <: SimulationNodeDatum */](): ForceX[NodeDatum] = js.native
    def forceX[NodeDatum /* <: SimulationNodeDatum */](x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]): ForceX[NodeDatum] = js.native
    def forceX[NodeDatum /* <: SimulationNodeDatum */](x: Double): ForceX[NodeDatum] = js.native
    def forceY[NodeDatum /* <: SimulationNodeDatum */](): ForceY[NodeDatum] = js.native
    def forceY[NodeDatum /* <: SimulationNodeDatum */](y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]): ForceY[NodeDatum] = js.native
    def forceY[NodeDatum /* <: SimulationNodeDatum */](y: Double): ForceY[NodeDatum] = js.native
    def format(specifier: String): js.Function1[/* n */ Double | Anon_ValueOf, String] = js.native
    def formatDefaultLocale(defaultLocale: FormatLocaleDefinition): FormatLocaleObject = js.native
    def formatLocale(locale: FormatLocaleDefinition): FormatLocaleObject = js.native
    def formatPrefix(specifier: String, value: Double): js.Function1[/* n */ Double | Anon_ValueOf, String] = js.native
    def formatSpecifier(specifier: String): FormatSpecifier = js.native
    def geoAlbers(): GeoConicProjection = js.native
    def geoAlbersUsa(): GeoProjection = js.native
    def geoArea(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): Double = js.native
    def geoArea(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): Double = js.native
    def geoArea(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): Double = js.native
    def geoArea(`object`: GeoGeometryObjects): Double = js.native
    def geoAzimuthalEqualArea(): GeoProjection = js.native
    def geoAzimuthalEqualAreaRaw(): GeoRawProjection = js.native
    def geoAzimuthalEquidistant(): GeoProjection = js.native
    def geoAzimuthalEquidistantRaw(): GeoRawProjection = js.native
    def geoBounds(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = js.native
    def geoBounds(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = js.native
    def geoBounds(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = js.native
    def geoBounds(`object`: GeoGeometryObjects): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = js.native
    def geoCentroid(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): js.Tuple2[Double, Double] = js.native
    def geoCentroid(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): js.Tuple2[Double, Double] = js.native
    def geoCentroid(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): js.Tuple2[Double, Double] = js.native
    def geoCentroid(`object`: GeoGeometryObjects): js.Tuple2[Double, Double] = js.native
    def geoCircle(): GeoCircleGenerator[_, _] = js.native
    @JSName("geoCircle")
    def geoCircle_Datum[Datum](): GeoCircleGenerator[_, Datum] = js.native
    @JSName("geoCircle")
    def geoCircle_ThisDatum[This, Datum](): GeoCircleGenerator[This, Datum] = js.native
    def geoClipAntimeridian(stream: GeoStream): GeoStream = js.native
    def geoClipCircle(angle: Double): js.Function1[/* stream */ GeoStream, GeoStream] = js.native
    def geoClipRectangle(x0: Double, y0: Double, x1: Double, y1: Double): js.Function1[/* stream */ GeoStream, GeoStream] = js.native
    def geoConicConformal(): GeoConicProjection = js.native
    def geoConicConformalRaw(phi0: Double, phi1: Double): GeoRawProjection = js.native
    def geoConicEqualArea(): GeoConicProjection = js.native
    def geoConicEqualAreaRaw(phi0: Double, phi1: Double): GeoRawProjection = js.native
    def geoConicEquidistant(): GeoConicProjection = js.native
    def geoConicEquidistantRaw(phi0: Double, phi1: Double): GeoRawProjection = js.native
    def geoContains(
      `object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]],
      point: js.Tuple2[Double, Double]
    ): Boolean = js.native
    def geoContains(
      `object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties],
      point: js.Tuple2[Double, Double]
    ): Boolean = js.native
    def geoContains(`object`: ExtendedGeometryCollection[GeoGeometryObjects], point: js.Tuple2[Double, Double]): Boolean = js.native
    def geoContains(`object`: GeoGeometryObjects, point: js.Tuple2[Double, Double]): Boolean = js.native
    def geoDistance(a: js.Tuple2[Double, Double], b: js.Tuple2[Double, Double]): Double = js.native
    def geoEqualEarth(): GeoProjection = js.native
    def geoEqualEarthRaw(): GeoRawProjection = js.native
    def geoEquirectangular(): GeoProjection = js.native
    def geoEquirectangularRaw(): GeoRawProjection = js.native
    def geoGnomonic(): GeoProjection = js.native
    def geoGnomonicRaw(): GeoRawProjection = js.native
    def geoGraticule(): GeoGraticuleGenerator = js.native
    def geoGraticule10(): MultiLineString = js.native
    def geoIdentity(): GeoIdentityTransform = js.native
    def geoInterpolate(a: js.Tuple2[Double, Double], b: js.Tuple2[Double, Double]): js.Function1[/* t */ Double, js.Tuple2[Double, Double]] = js.native
    def geoLength(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): Double = js.native
    def geoLength(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): Double = js.native
    def geoLength(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): Double = js.native
    def geoLength(`object`: GeoGeometryObjects): Double = js.native
    def geoMercator(): GeoProjection = js.native
    def geoMercatorRaw(): GeoRawProjection = js.native
    def geoNaturalEarth1(): GeoProjection = js.native
    def geoNaturalEarth1Raw(): GeoRawProjection = js.native
    def geoOrthographic(): GeoProjection = js.native
    def geoOrthographicRaw(): GeoRawProjection = js.native
    def geoPath(): GeoPath[_, GeoPermissibleObjects] = js.native
    def geoPath(projection: Null, context: GeoContext): GeoPath[_, GeoPermissibleObjects] = js.native
    def geoPath(projection: GeoProjection): GeoPath[_, GeoPermissibleObjects] = js.native
    def geoPath(projection: GeoProjection, context: GeoContext): GeoPath[_, GeoPermissibleObjects] = js.native
    def geoPath(projection: GeoStreamWrapper): GeoPath[_, GeoPermissibleObjects] = js.native
    def geoPath(projection: GeoStreamWrapper, context: GeoContext): GeoPath[_, GeoPermissibleObjects] = js.native
    @JSName("geoPath")
    def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](): GeoPath[_, DatumObject] = js.native
    @JSName("geoPath")
    def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: Null, context: GeoContext): GeoPath[_, DatumObject] = js.native
    @JSName("geoPath")
    def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection): GeoPath[_, DatumObject] = js.native
    @JSName("geoPath")
    def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection, context: GeoContext): GeoPath[_, DatumObject] = js.native
    @JSName("geoPath")
    def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper): GeoPath[_, DatumObject] = js.native
    @JSName("geoPath")
    def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper, context: GeoContext): GeoPath[_, DatumObject] = js.native
    @JSName("geoPath")
    def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](): GeoPath[This, DatumObject] = js.native
    @JSName("geoPath")
    def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: Null, context: GeoContext): GeoPath[This, DatumObject] = js.native
    @JSName("geoPath")
    def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection): GeoPath[This, DatumObject] = js.native
    @JSName("geoPath")
    def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection, context: GeoContext): GeoPath[This, DatumObject] = js.native
    @JSName("geoPath")
    def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper): GeoPath[This, DatumObject] = js.native
    @JSName("geoPath")
    def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper, context: GeoContext): GeoPath[This, DatumObject] = js.native
    def geoProjection(project: GeoRawProjection): GeoProjection = js.native
    def geoProjectionMutator(factory: js.Function1[/* repeated */ js.Any, GeoRawProjection]): js.Function0[GeoProjection] = js.native
    def geoRotation(angles: js.Tuple2[Double, Double]): GeoRotation = js.native
    def geoRotation(angles: js.Tuple3[Double, Double, Double]): GeoRotation = js.native
    def geoStereographic(): GeoProjection = js.native
    def geoStereographicRaw(): GeoRawProjection = js.native
    def geoStream(
      `object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]],
      stream: GeoStream
    ): Unit = js.native
    def geoStream(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties], stream: GeoStream): Unit = js.native
    def geoStream(`object`: ExtendedGeometryCollection[GeoGeometryObjects], stream: GeoStream): Unit = js.native
    def geoStream(`object`: GeoGeometryObjects, stream: GeoStream): Unit = js.native
    def geoTransform[T /* <: GeoTransformPrototype */](methods: T): Anon_S[T] = js.native
    def geoTransverseMercator(): GeoProjection = js.native
    def geoTransverseMercatorRaw(): GeoRawProjection = js.native
    /**
      * Constructs a new Lab color with the specified l value and a = b = 0.
      *
      * @param l Lightness typically in the range [0, 100].
      * @param opacity Optional opacity value, defaults to 1.
      */
    def gray(l: Double): LabColor = js.native
    /**
      * Constructs a new Lab color with the specified l value and a = b = 0.
      *
      * @param l Lightness typically in the range [0, 100].
      * @param opacity Optional opacity value, defaults to 1.
      */
    def gray(l: Double, opacity: Double): LabColor = js.native
    def group[TObject, TKey](a: js.Iterable[TObject], key: js.Function1[/* value */ TObject, TKey]): Map[TKey, js.Array[TObject]] = js.native
    def hcl(color: ColorCommonInstance): HCLColor = js.native
    /**
      * Converts the provided color instance and returns an HCL color.
      * The color instance is converted to the RGB color space using color.rgb and then converted to HCL.
      * (Colors already in the HCL color space skip the conversion to RGB,
      * and colors in the Lab color space are converted directly to HCL.)
      *
      * @param color A permissible color space instance.
      */
    def hcl(color: ColorSpaceObject): HCLColor = js.native
    /**
      * Parses the specified CSS Color Module Level 3 specifier string, returning an HCL color.
      * If the specifier was not valid, null is returned.
      *
      * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
      */
    def hcl(cssColorSpecifier: String): HCLColor = js.native
    /**
      * Constructs a new HCL color based on the specified channel values and opacity.
      *
      * @param h Hue channel value typically in [0, 360).
      * @param c Chroma channel value typically in [0, 230].
      * @param l Luminance channel value typically in the range [0, 100].
      * @param opacity Optional opacity value, defaults to 1.
      */
    def hcl(h: Double, l: Double, c: Double): HCLColor = js.native
    def hcl(h: Double, l: Double, c: Double, opacity: Double): HCLColor = js.native
    def hierarchy[Datum](data: Datum): HierarchyNode[Datum] = js.native
    def hierarchy[Datum](data: Datum, children: js.Function1[/* d */ Datum, js.UndefOr[js.Array[Datum] | Null]]): HierarchyNode[Datum] = js.native
    def histogram(): HistogramGeneratorNumber[Double, Double] = js.native
    @JSName("histogram")
    def `histogram_DatumValue_UnionDatejs.undefinedNothing_HistogramGeneratorDate`[Datum, Value /* <: js.UndefOr[js.Date] */](): HistogramGeneratorDate[Datum, Value] = js.native
    @JSName("histogram")
    def `histogram_DatumValue_UnionDoublejs.undefinedNothing`[Datum, Value /* <: js.UndefOr[Double] */](): HistogramGeneratorNumber[Datum, Value] = js.native
    def hsl(color: ColorCommonInstance): HSLColor = js.native
    /**
      * Converts the provided color instance and returns an HSL color.
      * The color instance is converted to the RGB color space using color.rgb and then converted to HSL.
      * (Colors already in the HSL color space skip the conversion to RGB.)
      *
      * @param color A permissible color space instance.
      */
    def hsl(color: ColorSpaceObject): HSLColor = js.native
    /**
      * Parses the specified CSS Color Module Level 3 specifier string, returning an HSL color.
      * If the specifier was not valid, null is returned.
      *
      * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
      */
    def hsl(cssColorSpecifier: String): HSLColor = js.native
    /**
      * Constructs a new HSL color based on the specified channel values and opacity.
      *
      * @param h Hue channel value.
      * @param s Saturation channel value.
      * @param l Lightness channel value.
      * @param opacity Optional opacity value, defaults to 1.
      */
    def hsl(h: Double, s: Double, l: Double): HSLColor = js.native
    def hsl(h: Double, s: Double, l: Double, opacity: Double): HSLColor = js.native
    def html(url: String): js.Promise[org.scalajs.dom.raw.Document] = js.native
    def html(url: String, init: RequestInit): js.Promise[org.scalajs.dom.raw.Document] = js.native
    def image(url: String): js.Promise[HTMLImageElement] = js.native
    def image(url: String, init: Partial[HTMLImageElement]): js.Promise[HTMLImageElement] = js.native
    def interpolate(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolate(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
    def interpolate(a: js.Any): js.Function1[/* t */ Double, Null] = js.native
    def interpolate(a: js.Any, b: Boolean): js.Function1[/* t */ Double, Boolean] = js.native
    def interpolate(a: Double, b: Double): js.Function1[/* t */ Double, Double] = js.native
    def interpolate(a: Double, b: typingsSlinky.d3DashInterpolate.Anon_ValueOf): js.Function1[/* t */ Double, Double] = js.native
    def interpolate(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
    def interpolate(a: Anon_ToString, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolate(a: typingsSlinky.d3DashInterpolate.Anon_ValueOf, b: Double): js.Function1[/* t */ Double, Double] = js.native
    def interpolate(a: typingsSlinky.d3DashInterpolate.Anon_ValueOf, b: typingsSlinky.d3DashInterpolate.Anon_ValueOf): js.Function1[/* t */ Double, Double] = js.native
    def interpolate(a: Date, b: Date): js.Function1[/* t */ Double, js.Date] = js.native
    def interpolate[U /* <: js.Object */](a: js.Any, b: U): js.Function1[/* t */ Double, U] = js.native
    def interpolate[U /* <: js.Array[_] */](a: js.Array[_], b: U): js.Function1[/* t */ Double, U] = js.native
    def interpolateArray[A /* <: js.Array[_] */](a: js.Array[_], b: A): ArrayInterpolator[A] = js.native
    def interpolateBasis(splineNodes: js.Array[Double]): js.Function1[/* t */ Double, Double] = js.native
    def interpolateBasisClosed(splineNodes: js.Array[Double]): js.Function1[/* t */ Double, Double] = js.native
    def interpolateBlues(t: Double): String = js.native
    def interpolateBrBG(t: Double): String = js.native
    def interpolateBuGn(t: Double): String = js.native
    def interpolateBuPu(t: Double): String = js.native
    def interpolateCool(t: Double): String = js.native
    def interpolateCubehelix(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateCubehelix(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
    def interpolateCubehelix(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateCubehelix(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
    def interpolateCubehelixDefault(t: Double): String = js.native
    def interpolateCubehelixLong(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateCubehelixLong(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
    def interpolateCubehelixLong(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateCubehelixLong(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
    def interpolateDate(a: js.Date, b: js.Date): js.Function1[/* t */ Double, js.Date] = js.native
    def interpolateDiscrete[T](values: js.Array[T]): js.Function1[/* t */ Double, T] = js.native
    def interpolateGnBu(t: Double): String = js.native
    def interpolateGreens(t: Double): String = js.native
    def interpolateGreys(t: Double): String = js.native
    def interpolateHcl(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateHcl(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
    def interpolateHcl(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateHcl(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
    def interpolateHclLong(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateHclLong(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
    def interpolateHclLong(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateHclLong(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
    def interpolateHsl(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateHsl(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
    def interpolateHsl(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateHsl(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
    def interpolateHslLong(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateHslLong(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
    def interpolateHslLong(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateHslLong(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
    def interpolateHue(a: Double, b: Double): js.Function1[/* t */ Double, Double] = js.native
    def interpolateInferno(t: Double): String = js.native
    def interpolateLab(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateLab(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
    def interpolateLab(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateLab(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
    def interpolateMagma(t: Double): String = js.native
    def interpolateNumber(a: Double, b: Double): js.Function1[/* t */ Double, Double] = js.native
    def interpolateNumber(a: Double, b: typingsSlinky.d3DashInterpolate.Anon_ValueOf): js.Function1[/* t */ Double, Double] = js.native
    def interpolateNumber(a: typingsSlinky.d3DashInterpolate.Anon_ValueOf, b: Double): js.Function1[/* t */ Double, Double] = js.native
    def interpolateNumber(a: typingsSlinky.d3DashInterpolate.Anon_ValueOf, b: typingsSlinky.d3DashInterpolate.Anon_ValueOf): js.Function1[/* t */ Double, Double] = js.native
    def interpolateObject[U /* <: js.Object */](a: js.Any, b: U): js.Function1[/* t */ Double, U] = js.native
    def interpolateOrRd(t: Double): String = js.native
    def interpolateOranges(t: Double): String = js.native
    def interpolatePRGn(t: Double): String = js.native
    def interpolatePiYG(t: Double): String = js.native
    def interpolatePlasma(t: Double): String = js.native
    def interpolatePuBu(t: Double): String = js.native
    def interpolatePuBuGn(t: Double): String = js.native
    def interpolatePuOr(t: Double): String = js.native
    def interpolatePuRd(t: Double): String = js.native
    def interpolatePurples(t: Double): String = js.native
    def interpolateRainbow(t: Double): String = js.native
    def interpolateRdBu(t: Double): String = js.native
    def interpolateRdGy(t: Double): String = js.native
    def interpolateRdPu(t: Double): String = js.native
    def interpolateRdYlBu(t: Double): String = js.native
    def interpolateRdYlGn(t: Double): String = js.native
    def interpolateReds(t: Double): String = js.native
    def interpolateRgb(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateRgb(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
    def interpolateRgb(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateRgb(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
    def interpolateRgbBasis(colors: js.Array[String | ColorCommonInstance]): js.Function1[/* t */ Double, String] = js.native
    def interpolateRgbBasisClosed(colors: js.Array[String | ColorCommonInstance]): js.Function1[/* t */ Double, String] = js.native
    def interpolateRound(a: Double, b: Double): js.Function1[/* t */ Double, Double] = js.native
    def interpolateRound(a: Double, b: typingsSlinky.d3DashInterpolate.Anon_ValueOf): js.Function1[/* t */ Double, Double] = js.native
    def interpolateRound(a: typingsSlinky.d3DashInterpolate.Anon_ValueOf, b: Double): js.Function1[/* t */ Double, Double] = js.native
    def interpolateRound(a: typingsSlinky.d3DashInterpolate.Anon_ValueOf, b: typingsSlinky.d3DashInterpolate.Anon_ValueOf): js.Function1[/* t */ Double, Double] = js.native
    def interpolateSinebow(t: Double): String = js.native
    def interpolateSpectral(t: Double): String = js.native
    def interpolateString(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateString(a: String, b: Anon_ToString): js.Function1[/* t */ Double, String] = js.native
    def interpolateString(a: Anon_ToString, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateString(a: Anon_ToString, b: Anon_ToString): js.Function1[/* t */ Double, String] = js.native
    def interpolateTransformCss(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateTransformSvg(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
    def interpolateViridis(t: Double): String = js.native
    def interpolateWarm(t: Double): String = js.native
    def interpolateYlGn(t: Double): String = js.native
    def interpolateYlGnBu(t: Double): String = js.native
    def interpolateYlOrBr(t: Double): String = js.native
    def interpolateYlOrRd(t: Double): String = js.native
    def interpolateZoom(a: ZoomView, b: ZoomView): ZoomInterpolator = js.native
    def interrupt(node: BaseType): Unit = js.native
    def interrupt(node: BaseType, name: String): Unit = js.native
    def interval(callback: js.Function1[/* elapsed */ Double, Unit]): Timer = js.native
    def interval(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double): Timer = js.native
    def interval(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double, time: Double): Timer = js.native
    def isoFormat(date: js.Date): String = js.native
    def isoParse(dateString: String): js.Date | Null = js.native
    def json[ParsedJSONObject /* <: js.Any */](url: String): js.Promise[ParsedJSONObject] = js.native
    def json[ParsedJSONObject /* <: js.Any */](url: String, init: RequestInit): js.Promise[ParsedJSONObject] = js.native
    def keys(obj: js.Object): js.Array[String] = js.native
    def lab(color: ColorCommonInstance): LabColor = js.native
    /**
      * Converts the provided color instance and returns a Lab color.
      * The color instance is converted to the RGB color space using color.rgb and then converted to Lab.
      * (Colors already in the Lab color space skip the conversion to RGB,
      * and colors in the HCL color space are converted directly to Lab.)
      *
      * @param color A permissible color space instance.
      */
    def lab(color: ColorSpaceObject): LabColor = js.native
    /**
      * Parses the specified CSS Color Module Level 3 specifier string, returning a Lab color.
      * If the specifier was not valid, null is returned.
      *
      * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
      */
    def lab(cssColorSpecifier: String): LabColor = js.native
    /**
      * Constructs a new Lab color based on the specified channel values and opacity.
      *
      * @param l Lightness typically in the range [0, 100].
      * @param a Position between red/magenta and green typically in [-160, +160].
      * @param b Position between yellow and blue typically in [-160, +160].
      * @param opacity Optional opacity value, defaults to 1.
      */
    def lab(l: Double, a: Double, b: Double): LabColor = js.native
    def lab(l: Double, a: Double, b: Double, opacity: Double): LabColor = js.native
    def lch(color: ColorCommonInstance): HCLColor = js.native
    /**
      * Converts the provided color instance and returns an HCL color.
      * The color instance is converted to the RGB color space using color.rgb and then converted to HCL.
      * (Colors already in the HCL color space skip the conversion to RGB,
      * and colors in the Lab color space are converted directly to HCL.)
      *
      * @param color A permissible color space instance.
      */
    def lch(color: ColorSpaceObject): HCLColor = js.native
    /**
      * Parses the specified CSS Color Module Level 3 specifier string, returning an HCL color.
      * If the specifier was not valid, null is returned.
      *
      * @param cssColorSpecifier A CSS color Module Level 3 specifier string.
      */
    def lch(cssColorSpecifier: String): HCLColor = js.native
    /**
      * Constructs a new HCL color based on the specified channel values and opacity.
      *
      * @param l Luminance channel value typically in the range [0, 100].
      * @param c Chroma channel value typically in [0, 230].
      * @param h Hue channel value typically in [0, 360).
      * @param opacity Optional opacity value, defaults to 1.
      */
    def lch(l: Double, c: Double, h: Double): HCLColor = js.native
    def lch(l: Double, c: Double, h: Double, opacity: Double): HCLColor = js.native
    def line(): Line[js.Tuple2[Double, Double]] = js.native
    def lineRadial(): LineRadial[js.Tuple2[Double, Double]] = js.native
    @JSName("lineRadial")
    def lineRadial_Datum[Datum](): LineRadial[Datum] = js.native
    @JSName("line")
    def line_Datum[Datum](): Line[Datum] = js.native
    def linkHorizontal(): Link[_, DefaultLinkObject, js.Tuple2[Double, Double]] = js.native
    @JSName("linkHorizontal")
    def linkHorizontal_LinkDatumNodeDatum[LinkDatum, NodeDatum](): Link[_, LinkDatum, NodeDatum] = js.native
    @JSName("linkHorizontal")
    def linkHorizontal_ThisLinkDatumNodeDatum[This, LinkDatum, NodeDatum](): Link[This, LinkDatum, NodeDatum] = js.native
    def linkRadial(): LinkRadial[_, DefaultLinkObject, js.Tuple2[Double, Double]] = js.native
    @JSName("linkRadial")
    def linkRadial_LinkDatumNodeDatum[LinkDatum, NodeDatum](): LinkRadial[_, LinkDatum, NodeDatum] = js.native
    @JSName("linkRadial")
    def linkRadial_ThisLinkDatumNodeDatum[This, LinkDatum, NodeDatum](): LinkRadial[This, LinkDatum, NodeDatum] = js.native
    def linkVertical(): Link[_, DefaultLinkObject, js.Tuple2[Double, Double]] = js.native
    @JSName("linkVertical")
    def linkVertical_LinkDatumNodeDatum[LinkDatum, NodeDatum](): Link[_, LinkDatum, NodeDatum] = js.native
    @JSName("linkVertical")
    def linkVertical_ThisLinkDatumNodeDatum[This, LinkDatum, NodeDatum](): Link[This, LinkDatum, NodeDatum] = js.native
    def local[T](): Local[T] = js.native
    def map(obj: js.Object): typingsSlinky.d3DashCollection.d3DashCollectionMod.Map[_] = js.native
    def map[T](): typingsSlinky.d3DashCollection.d3DashCollectionMod.Map[T] = js.native
    def map[T](array: js.Array[T]): typingsSlinky.d3DashCollection.d3DashCollectionMod.Map[T] = js.native
    def map[T](
      array: js.Array[T],
      key: js.Function3[/* value */ T, /* i */ js.UndefOr[Double], /* array */ js.UndefOr[js.Array[T]], String]
    ): typingsSlinky.d3DashCollection.d3DashCollectionMod.Map[T] = js.native
    def map[T](d3Map: typingsSlinky.d3DashCollection.d3DashCollectionMod.Map[T]): typingsSlinky.d3DashCollection.d3DashCollectionMod.Map[T] = js.native
    def map[T](obj: NumberDictionary[T]): typingsSlinky.d3DashCollection.d3DashCollectionMod.Map[T] = js.native
    def map[T](obj: StringDictionary[T]): typingsSlinky.d3DashCollection.d3DashCollectionMod.Map[T] = js.native
    def matcher(selector: String): js.ThisFunction0[/* this */ BaseType, Boolean] = js.native
    def max(array: Iterable[String]): js.UndefOr[String] = js.native
    def max[T](
      array: Iterable[T],
      accessor: js.Function3[
          /* datum */ T, 
          /* index */ Double, 
          /* array */ js.Iterable[T], 
          js.UndefOr[String | Null]
        ]
    ): js.UndefOr[String] = js.native
    @JSName("max")
    def max_TU_Numeric[T, U /* <: Numeric */](
      array: js.Iterable[T],
      accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ js.Iterable[T], js.UndefOr[U | Null]]
    ): js.UndefOr[U] = js.native
    @JSName("max")
    def max_T_Numeric[T /* <: Numeric */](array: js.Iterable[T]): js.UndefOr[T] = js.native
    def mean[T /* <: Numeric */](array: Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = js.native
    def mean[T](
      array: Iterable[T],
      accessor: js.Function3[
          /* datum */ T, 
          /* index */ Double, 
          /* array */ js.Iterable[T], 
          js.UndefOr[Double | Null]
        ]
    ): js.UndefOr[Double] = js.native
    def median[T /* <: Numeric */](array: Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = js.native
    def median[T](
      array: Iterable[T],
      accessor: js.Function3[/* element */ T, /* i */ Double, /* array */ js.Iterable[T], js.UndefOr[Double | Null]]
    ): js.UndefOr[Double] = js.native
    def merge[T](arrays: js.Iterable[js.Iterable[T]]): js.Array[T] = js.native
    def min(array: Iterable[String]): js.UndefOr[String] = js.native
    def min[T](
      array: Iterable[T],
      accessor: js.Function3[
          /* datum */ T, 
          /* index */ Double, 
          /* array */ js.Iterable[T], 
          js.UndefOr[String | Null]
        ]
    ): js.UndefOr[String] = js.native
    @JSName("min")
    def min_TU_Numeric[T, U /* <: Numeric */](
      array: js.Iterable[T],
      accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ js.Iterable[T], js.UndefOr[U | Null]]
    ): js.UndefOr[U] = js.native
    @JSName("min")
    def min_T_Numeric[T /* <: Numeric */](array: js.Iterable[T]): js.UndefOr[T] = js.native
    def mouse(container: ContainerElement): js.Tuple2[Double, Double] = js.native
    def namespace(prefixedLocal: String): NamespaceLocalObject | String = js.native
    def nest[Datum, RollupType](): Nest[Datum, RollupType] = js.native
    def now(): Double = js.native
    def pack[Datum](): PackLayout[Datum] = js.native
    def packEnclose[Datum /* <: PackCircle */](circles: js.Array[Datum]): PackCircle = js.native
    def packSiblings[Datum /* <: PackRadius */](circles: js.Array[Datum]): js.Array[Datum with PackCircle] = js.native
    def pairs[T](array: js.Iterable[T]): js.Array[js.Tuple2[T, T]] = js.native
    def pairs[T, U](array: js.Iterable[T], reducer: js.Function2[/* a */ T, /* b */ T, U]): js.Array[U] = js.native
    def partition[Datum](): PartitionLayout[Datum] = js.native
    def path(): Path = js.native
    def permute[T](array: NumberDictionary[T], keys: ArrayLike[Double]): js.Array[T] = js.native
    def permute[T, K /* <: String */](`object`: T, keys: ArrayLike[K]): js.Array[
        /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
      ] = js.native
    def pie(): Pie[_, Double | typingsSlinky.d3DashShape.Anon_ValueOf] = js.native
    @JSName("pie")
    def pie_Datum[Datum](): Pie[_, Datum] = js.native
    @JSName("pie")
    def pie_ThisDatum[This, Datum](): Pie[This, Datum] = js.native
    def piecewise(
      interpolate: js.Function2[/* a */ ZoomView, /* b */ ZoomView, ZoomInterpolator],
      values: js.Array[ZoomView]
    ): ZoomInterpolator = js.native
    @JSName("piecewise")
    def piecewise_A_ArrayWildcard_ArrayInterpolator[A /* <: js.Array[_] */](
      interpolate: js.Function2[/* a */ js.Array[_], /* b */ A, ArrayInterpolator[A]],
      values: js.Array[A]
    ): ArrayInterpolator[A] = js.native
    @JSName("piecewise")
    def piecewise_TDataInterpolator_Function1[TData, Interpolator](interpolate: js.Function2[/* a */ TData, /* b */ TData, Interpolator], values: js.Array[TData]): js.Function1[/* t */ Double, _] = js.native
    def pointRadial(angle: Double, radius: Double): js.Tuple2[Double, Double] = js.native
    def polygonArea(polygon: js.Array[js.Tuple2[Double, Double]]): Double = js.native
    def polygonCentroid(polygon: js.Array[js.Tuple2[Double, Double]]): js.Tuple2[Double, Double] = js.native
    def polygonContains(polygon: js.Array[js.Tuple2[Double, Double]], point: js.Tuple2[Double, Double]): Boolean = js.native
    def polygonHull(points: js.Array[js.Tuple2[Double, Double]]): (js.Array[js.Tuple2[Double, Double]]) | Null = js.native
    def polygonLength(polygon: js.Array[js.Tuple2[Double, Double]]): Double = js.native
    def precisionFixed(step: Double): Double = js.native
    def precisionPrefix(step: Double, value: Double): Double = js.native
    def precisionRound(step: Double, max: Double): Double = js.native
    def quadtree[T](): Quadtree[T] = js.native
    def quadtree[T](data: js.Array[T]): Quadtree[T] = js.native
    def quadtree[T](data: js.Array[T], x: js.Function1[/* d */ T, Double]): Quadtree[T] = js.native
    def quadtree[T](data: js.Array[T], x: js.Function1[/* d */ T, Double], y: js.Function1[/* d */ T, Double]): Quadtree[T] = js.native
    def quantile[T /* <: Numeric */](array: Iterable[js.UndefOr[T | Null]], p: Double): js.UndefOr[Double] = js.native
    def quantile[T](
      array: Iterable[T],
      p: Double,
      accessor: js.Function3[/* element */ T, /* i */ Double, /* array */ js.Iterable[T], js.UndefOr[Double | Null]]
    ): js.UndefOr[Double] = js.native
    def quantize[T](interpolator: js.Function1[/* t */ Double, T], n: Double): js.Array[T] = js.native
    def quickselect[T](array: ArrayLike[T], k: Double): js.Array[T] = js.native
    def quickselect[T](array: ArrayLike[T], k: Double, left: Double): js.Array[T] = js.native
    def quickselect[T](array: ArrayLike[T], k: Double, left: Double, right: Double): js.Array[T] = js.native
    def quickselect[T](
      array: ArrayLike[T],
      k: Double,
      left: Double,
      right: Double,
      compare: js.Function2[/* a */ js.UndefOr[Primitive], /* b */ js.UndefOr[Primitive], Double]
    ): js.Array[T] = js.native
    def radialArea(): RadialArea[js.Tuple2[Double, Double]] = js.native
    @JSName("radialArea")
    def radialArea_Datum[Datum](): RadialArea[Datum] = js.native
    def radialLine(): RadialLine[js.Tuple2[Double, Double]] = js.native
    @JSName("radialLine")
    def radialLine_Datum[Datum](): RadialLine[Datum] = js.native
    /**
      * Returns a function for generating random numbers with a Bates distribution with n independent variables.
      *
      * @param n Number of independent random variables to use.
      */
    def randomBates(n: Double): js.Function0[Double] = js.native
    /**
      * Returns a function for generating random numbers with an exponential distribution with the rate lambda;
      * equivalent to time between events in a Poisson process with a mean of 1 / lambda.
      *
      * @param lambda Expected time between events.
      */
    def randomExponential(lambda: Double): js.Function0[Double] = js.native
    /**
      * Returns a function for generating random numbers with an IrwinHall distribution with n independent variables.
      *
      * @param n Number of independent random variables to use.
      */
    def randomIrwinHall(n: Double): js.Function0[Double] = js.native
    /**
      * Returns a function for generating random numbers with a log-normal distribution. The expected value of the random variables natural logarithm is mu,
      * with the given standard deviation sigma. If mu is not specified, it defaults to 0; if sigma is not specified, it defaults to 1.
      *
      * @param mu Expected value, defaults to 0.
      * @param sigma Standard deviation, defaults to 1.
      */
    def randomLogNormal(): js.Function0[Double] = js.native
    def randomLogNormal(mu: Double): js.Function0[Double] = js.native
    def randomLogNormal(mu: Double, sigma: Double): js.Function0[Double] = js.native
    /**
      * Returns a function for generating random numbers with a normal (Gaussian) distribution.
      * The expected value of the generated numbers is mu, with the given standard deviation sigma.
      * If mu is not specified, it defaults to 0; if sigma is not specified, it defaults to 1.
      *
      * @param mu Expected value, defaults to 0.
      * @param sigma Standard deviation, defaults to 1.
      */
    def randomNormal(): js.Function0[Double] = js.native
    def randomNormal(mu: Double): js.Function0[Double] = js.native
    def randomNormal(mu: Double, sigma: Double): js.Function0[Double] = js.native
    /**
      * Returns a function for generating random numbers with a uniform distribution).
      * The minimum allowed value of a returned number is min, and the maximum is max.
      * If min is not specified, it defaults to 0; if max is not specified, it defaults to 1.
      *
      * @param min The minimum allowed value of a returned number, defaults to 0.
      * @param max The maximum allowed value of a returned number, defaults to 1.
      */
    def randomUniform(): js.Function0[Double] = js.native
    def randomUniform(min: Double): js.Function0[Double] = js.native
    def randomUniform(min: Double, max: Double): js.Function0[Double] = js.native
    def range(start: Double, stop: Double): js.Array[Double] = js.native
    def range(start: Double, stop: Double, step: Double): js.Array[Double] = js.native
    def range(stop: Double): js.Array[Double] = js.native
    def rgb(color: ColorCommonInstance): RGBColor = js.native
    /**
      * Converts the provided color instance and returns an RGB color. The color instance is converted to the RGB color space using color.rgb.
      * Note that unlike color.rgb this method always returns a new instance, even if color is already an RGB color.
      *
      * @param color A permissible color space instance.
      */
    def rgb(color: ColorSpaceObject): RGBColor = js.native
    /**
      * Parses the specified CSS Color Module Level 3 specifier string, returning an RGB color.
      * If the specifier was not valid, null is returned.
      *
      * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
      */
    def rgb(cssColorSpecifier: String): RGBColor = js.native
    /**
      * Constructs a new RGB color based on the specified channel values and opacity.
      *
      * @param r Red channel value.
      * @param g Green channel value.
      * @param b Blue channel value.
      * @param opacity Optional opacity value, defaults to 1.
      */
    def rgb(r: Double, g: Double, b: Double): RGBColor = js.native
    def rgb(r: Double, g: Double, b: Double, opacity: Double): RGBColor = js.native
    def ribbon(): RibbonGenerator[_, Ribbon, RibbonSubgroup] = js.native
    @JSName("ribbon")
    def ribbon_DatumSubgroupDatum[Datum, SubgroupDatum](): RibbonGenerator[_, Datum, SubgroupDatum] = js.native
    @JSName("ribbon")
    def ribbon_ThisDatumSubgroupDatum[This, Datum, SubgroupDatum](): RibbonGenerator[This, Datum, SubgroupDatum] = js.native
    def rollup[TObject, TKey, TReduce](
      a: js.Iterable[TObject],
      reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
      key: js.Function1[/* value */ TObject, TKey]
    ): Map[TKey, TReduce] = js.native
    def scaleBand(): ScaleBand[String] = js.native
    @JSName("scaleBand")
    def scaleBand_Domain_Anon_ToString[Domain /* <: typingsSlinky.d3DashScale.Anon_ToString */](): ScaleBand[Domain] = js.native
    def scaleDiverging[T](interpolator: js.Function1[/* t */ Double, T]): ScaleDiverging[T] = js.native
    def scaleIdentity(): ScaleIdentity = js.native
    def scaleLinear(): ScaleLinear[Double, Double] = js.native
    @JSName("scaleLinear")
    def scaleLinear_Output[Output](): ScaleLinear[Output, Output] = js.native
    @JSName("scaleLinear")
    def scaleLinear_RangeOutput[Range, Output](): ScaleLinear[Range, Output] = js.native
    def scaleLog(): ScaleLogarithmic[Double, Double] = js.native
    @JSName("scaleLog")
    def scaleLog_Output[Output](): ScaleLogarithmic[Output, Output] = js.native
    @JSName("scaleLog")
    def scaleLog_RangeOutput[Range, Output](): ScaleLogarithmic[Range, Output] = js.native
    def scaleOrdinal[Range](): ScaleOrdinal[String, Range] = js.native
    def scaleOrdinal[Range](range: js.Array[Range]): ScaleOrdinal[String, Range] = js.native
    @JSName("scaleOrdinal")
    def scaleOrdinal_Domain_Anon_ToStringRange[Domain /* <: typingsSlinky.d3DashScale.Anon_ToString */, Range](): ScaleOrdinal[Domain, Range] = js.native
    @JSName("scaleOrdinal")
    def scaleOrdinal_Domain_Anon_ToStringRange[Domain /* <: typingsSlinky.d3DashScale.Anon_ToString */, Range](range: js.Array[Range]): ScaleOrdinal[Domain, Range] = js.native
    def scalePoint(): ScalePoint[String] = js.native
    @JSName("scalePoint")
    def scalePoint_Domain_Anon_ToString[Domain /* <: typingsSlinky.d3DashScale.Anon_ToString */](): ScalePoint[Domain] = js.native
    def scalePow(): ScalePower[Double, Double] = js.native
    @JSName("scalePow")
    def scalePow_Output[Output](): ScalePower[Output, Output] = js.native
    @JSName("scalePow")
    def scalePow_RangeOutput[Range, Output](): ScalePower[Range, Output] = js.native
    def scaleQuantile(): ScaleQuantile[Double] = js.native
    @JSName("scaleQuantile")
    def scaleQuantile_Range[Range](): ScaleQuantile[Range] = js.native
    def scaleQuantize(): ScaleQuantize[Double] = js.native
    @JSName("scaleQuantize")
    def scaleQuantize_Range[Range](): ScaleQuantize[Range] = js.native
    def scaleSequential[Output](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential[Output] = js.native
    def scaleSqrt(): ScalePower[Double, Double] = js.native
    @JSName("scaleSqrt")
    def scaleSqrt_Output[Output](): ScalePower[Output, Output] = js.native
    @JSName("scaleSqrt")
    def scaleSqrt_RangeOutput[Range, Output](): ScalePower[Range, Output] = js.native
    def scaleThreshold(): ScaleThreshold[Double, Double] = js.native
    @JSName("scaleThreshold")
    def scaleThreshold_Domain_UnionDoubleStringDateRange[Domain /* <: Double | String | js.Date */, Range](): ScaleThreshold[Domain, Range] = js.native
    def scaleTime(): ScaleTime[Double, Double] = js.native
    @JSName("scaleTime")
    def scaleTime_Output[Output](): ScaleTime[Output, Output] = js.native
    @JSName("scaleTime")
    def scaleTime_RangeOutput[Range, Output](): ScaleTime[Range, Output] = js.native
    def scaleUtc(): ScaleTime[Double, Double] = js.native
    @JSName("scaleUtc")
    def scaleUtc_Output[Output](): ScaleTime[Output, Output] = js.native
    @JSName("scaleUtc")
    def scaleUtc_RangeOutput[Range, Output](): ScaleTime[Range, Output] = js.native
    def scan(array: js.Iterable[Double]): js.UndefOr[Double] = js.native
    def scan(array: js.Iterable[Double], comparator: js.Function2[/* a */ Double, /* b */ Double, Double]): js.UndefOr[Double] = js.native
    @JSName("scan")
    def scan_T[T](array: js.Iterable[T], comparator: js.Function2[/* a */ T, /* b */ T, Double]): js.UndefOr[Double] = js.native
    def select[OldDatum](): Selection[Null, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
    def select[OldDatum](node: EnterElement): Selection[EnterElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
    def select[OldDatum](node: Document): Selection[org.scalajs.dom.raw.Document, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
    def select[OldDatum](node: Element): Selection[org.scalajs.dom.raw.Element, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
    def select[OldDatum](node: Window): Selection[org.scalajs.dom.raw.Window, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
    def select[GElement /* <: BaseType */, OldDatum](selector: String): Selection[GElement, OldDatum, HTMLElement, _] = js.native
    def selectAll(): Selection[Null, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
    def selectAll[GElement /* <: BaseType */, OldDatum](nodes: js.Array[GElement]): Selection[GElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
    def selectAll[GElement /* <: BaseType */, OldDatum](nodes: typingsSlinky.d3DashSelection.d3DashSelectionMod.ArrayLike[GElement]): Selection[GElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
    def selectAll[GElement /* <: BaseType */, OldDatum](selector: String): Selection[GElement, OldDatum, HTMLElement, _] = js.native
    def selection(): Selection[HTMLElement, _, Null, js.UndefOr[scala.Nothing]] = js.native
    def selector[DescElement /* <: org.scalajs.dom.raw.Element */](selector: String): js.ThisFunction0[/* this */ BaseType, DescElement] = js.native
    def selectorAll[DescElement /* <: org.scalajs.dom.raw.Element */](selector: String): js.ThisFunction0[/* this */ BaseType, NodeListOf[DescElement with Node]] = js.native
    def set(): Set = js.native
    def set(array: js.Array[String | Stringifiable]): Set = js.native
    def set(d3Set: Set): Set = js.native
    def set[T](
      array: js.Array[T],
      key: js.Function3[/* value */ T, /* index */ Double, /* array */ js.Array[T], String]
    ): Set = js.native
    def shuffle(array: Float32Array): scala.scalajs.js.typedarray.Float32Array = js.native
    def shuffle(array: Float32Array, lo: Double): scala.scalajs.js.typedarray.Float32Array = js.native
    def shuffle(array: Float32Array, lo: Double, hi: Double): scala.scalajs.js.typedarray.Float32Array = js.native
    def shuffle(array: Float64Array): scala.scalajs.js.typedarray.Float64Array = js.native
    def shuffle(array: Float64Array, lo: Double): scala.scalajs.js.typedarray.Float64Array = js.native
    def shuffle(array: Float64Array, lo: Double, hi: Double): scala.scalajs.js.typedarray.Float64Array = js.native
    def shuffle(array: Int16Array): scala.scalajs.js.typedarray.Int16Array = js.native
    def shuffle(array: Int16Array, lo: Double): scala.scalajs.js.typedarray.Int16Array = js.native
    def shuffle(array: Int16Array, lo: Double, hi: Double): scala.scalajs.js.typedarray.Int16Array = js.native
    def shuffle(array: Int32Array): scala.scalajs.js.typedarray.Int32Array = js.native
    def shuffle(array: Int32Array, lo: Double): scala.scalajs.js.typedarray.Int32Array = js.native
    def shuffle(array: Int32Array, lo: Double, hi: Double): scala.scalajs.js.typedarray.Int32Array = js.native
    def shuffle(array: Int8Array): scala.scalajs.js.typedarray.Int8Array = js.native
    def shuffle(array: Int8Array, lo: Double): scala.scalajs.js.typedarray.Int8Array = js.native
    def shuffle(array: Int8Array, lo: Double, hi: Double): scala.scalajs.js.typedarray.Int8Array = js.native
    def shuffle(array: Uint16Array): scala.scalajs.js.typedarray.Uint16Array = js.native
    def shuffle(array: Uint16Array, lo: Double): scala.scalajs.js.typedarray.Uint16Array = js.native
    def shuffle(array: Uint16Array, lo: Double, hi: Double): scala.scalajs.js.typedarray.Uint16Array = js.native
    def shuffle(array: Uint32Array): scala.scalajs.js.typedarray.Uint32Array = js.native
    def shuffle(array: Uint32Array, lo: Double): scala.scalajs.js.typedarray.Uint32Array = js.native
    def shuffle(array: Uint32Array, lo: Double, hi: Double): scala.scalajs.js.typedarray.Uint32Array = js.native
    def shuffle(array: Uint8Array): scala.scalajs.js.typedarray.Uint8Array = js.native
    def shuffle(array: Uint8Array, lo: Double): scala.scalajs.js.typedarray.Uint8Array = js.native
    def shuffle(array: Uint8Array, lo: Double, hi: Double): scala.scalajs.js.typedarray.Uint8Array = js.native
    def shuffle(array: Uint8ClampedArray): scala.scalajs.js.typedarray.Uint8ClampedArray = js.native
    def shuffle(array: Uint8ClampedArray, lo: Double): scala.scalajs.js.typedarray.Uint8ClampedArray = js.native
    def shuffle(array: Uint8ClampedArray, lo: Double, hi: Double): scala.scalajs.js.typedarray.Uint8ClampedArray = js.native
    def shuffle[T](array: js.Array[T]): js.Array[T] = js.native
    def shuffle[T](array: js.Array[T], lo: Double): js.Array[T] = js.native
    def shuffle[T](array: js.Array[T], lo: Double, hi: Double): js.Array[T] = js.native
    def stack(): Stack[_, StringDictionary[Double], String] = js.native
    def stackOffsetDiverging(series: Series[_, _], order: js.Array[Double]): Unit = js.native
    def stackOffsetExpand(series: Series[_, _], order: js.Array[Double]): Unit = js.native
    def stackOffsetNone(series: Series[_, _], order: js.Array[Double]): Unit = js.native
    def stackOffsetSilhouette(series: Series[_, _], order: js.Array[Double]): Unit = js.native
    def stackOffsetWiggle(series: Series[_, _], order: js.Array[Double]): Unit = js.native
    def stackOrderAppearance(series: Series[_, _]): js.Array[Double] = js.native
    def stackOrderAscending(series: Series[_, _]): js.Array[Double] = js.native
    def stackOrderDescending(series: Series[_, _]): js.Array[Double] = js.native
    def stackOrderInsideOut(series: Series[_, _]): js.Array[Double] = js.native
    def stackOrderNone(series: Series[_, _]): js.Array[Double] = js.native
    def stackOrderReverse(series: Series[_, _]): js.Array[Double] = js.native
    @JSName("stack")
    def stack_Datum[Datum](): Stack[_, Datum, String] = js.native
    @JSName("stack")
    def stack_DatumKey[Datum, Key](): Stack[_, Datum, Key] = js.native
    @JSName("stack")
    def stack_ThisDatumKey[This, Datum, Key](): Stack[This, Datum, Key] = js.native
    def stratify[Datum](): StratifyOperator[Datum] = js.native
    def style(node: org.scalajs.dom.raw.Element, name: String): String = js.native
    def sum[T /* <: Numeric */](array: Iterable[js.UndefOr[T | Null]]): Double = js.native
    def sum[T](
      array: Iterable[T],
      accessor: js.Function3[
          /* datum */ T, 
          /* index */ Double, 
          /* array */ js.Iterable[T], 
          js.UndefOr[Double | Null]
        ]
    ): Double = js.native
    def svg(url: String): js.Promise[org.scalajs.dom.raw.Document] = js.native
    def svg(url: String, init: RequestInit): js.Promise[org.scalajs.dom.raw.Document] = js.native
    def symbol(): Symbol[_, _] = js.native
    @JSName("symbol")
    def symbol_Datum[Datum](): Symbol[_, Datum] = js.native
    @JSName("symbol")
    def symbol_ThisDatum[This, Datum](): Symbol[This, Datum] = js.native
    def text(url: String): js.Promise[String] = js.native
    def text(url: String, init: RequestInit): js.Promise[String] = js.native
    def thresholdFreedmanDiaconis(values: ArrayLike[js.UndefOr[Double]], min: Double, max: Double): Double = js.native
    def thresholdScott(values: ArrayLike[js.UndefOr[Double]], min: Double, max: Double): Double = js.native
    def thresholdSturges(values: ArrayLike[js.UndefOr[Double]]): Double = js.native
    def tickIncrement(start: Double, stop: Double, count: Double): Double = js.native
    def tickStep(start: Double, stop: Double, count: Double): Double = js.native
    def ticks(start: Double, stop: Double, count: Double): js.Array[Double] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def timeDay(date: js.Date): js.Date = js.native
    def timeDays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def timeDays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    def timeFormat(specifier: String): js.Function1[/* date */ js.Date, String] = js.native
    def timeFormatDefaultLocale(defaultTimeLocale: TimeLocaleDefinition): TimeLocaleObject = js.native
    def timeFormatLocale(timeLocale: TimeLocaleDefinition): TimeLocaleObject = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def timeFriday(date: js.Date): js.Date = js.native
    def timeFridays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def timeFridays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def timeHour(date: js.Date): js.Date = js.native
    def timeHours(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def timeHours(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    def timeInterval(
      floor: js.Function1[/* date */ js.Date, Unit],
      offset: js.Function2[/* date */ js.Date, /* step */ Double, Unit]
    ): TimeInterval = js.native
    def timeInterval(
      floor: js.Function1[/* date */ js.Date, Unit],
      offset: js.Function2[/* date */ js.Date, /* step */ Double, Unit],
      count: js.Function2[/* start */ js.Date, /* end */ js.Date, Double]
    ): CountableTimeInterval = js.native
    def timeInterval(
      floor: js.Function1[/* date */ js.Date, Unit],
      offset: js.Function2[/* date */ js.Date, /* step */ Double, Unit],
      count: js.Function2[/* start */ js.Date, /* end */ js.Date, Double],
      field: js.Function1[/* date */ js.Date, Double]
    ): CountableTimeInterval = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def timeMillisecond(date: js.Date): js.Date = js.native
    def timeMilliseconds(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def timeMilliseconds(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def timeMinute(date: js.Date): js.Date = js.native
    def timeMinutes(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def timeMinutes(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def timeMonday(date: js.Date): js.Date = js.native
    def timeMondays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def timeMondays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def timeMonth(date: js.Date): js.Date = js.native
    def timeMonths(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def timeMonths(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    def timeParse(specifier: String): js.Function1[/* dateString */ String, js.Date | Null] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def timeSaturday(date: js.Date): js.Date = js.native
    def timeSaturdays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def timeSaturdays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def timeSecond(date: js.Date): js.Date = js.native
    def timeSeconds(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def timeSeconds(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def timeSunday(date: js.Date): js.Date = js.native
    def timeSundays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def timeSundays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def timeThursday(date: js.Date): js.Date = js.native
    def timeThursdays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def timeThursdays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def timeTuesday(date: js.Date): js.Date = js.native
    def timeTuesdays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def timeTuesdays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def timeWednesday(date: js.Date): js.Date = js.native
    def timeWednesdays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def timeWednesdays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def timeWeek(date: js.Date): js.Date = js.native
    def timeWeeks(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def timeWeeks(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def timeYear(date: js.Date): js.Date = js.native
    def timeYears(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def timeYears(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    def timeout(callback: js.Function1[/* elapsed */ Double, Unit]): Timer = js.native
    def timeout(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double): Timer = js.native
    def timeout(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double, time: Double): Timer = js.native
    def timer(callback: js.Function1[/* elapsed */ Double, Unit]): Timer = js.native
    def timer(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double): Timer = js.native
    def timer(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double, time: Double): Timer = js.native
    def timerFlush(): Unit = js.native
    def touch(container: ContainerElement, identifier: Double): (js.Tuple2[Double, Double]) | Null = js.native
    def touch(container: ContainerElement, touches: TouchList, identifier: Double): (js.Tuple2[Double, Double]) | Null = js.native
    def touches(container: ContainerElement): js.Array[js.Tuple2[Double, Double]] = js.native
    def touches(container: ContainerElement, touches: org.scalajs.dom.raw.TouchList): js.Array[js.Tuple2[Double, Double]] = js.native
    def transition[OldDatum](): Transition[HTMLElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
    def transition[OldDatum](name: String): Transition[HTMLElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
    def transition[OldDatum](transition: Transition[BaseType, _, BaseType, _]): Transition[HTMLElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
    def transpose[T](matrix: ArrayLike[ArrayLike[T]]): js.Array[js.Array[T]] = js.native
    def tree[Datum](): TreeLayout[Datum] = js.native
    def treemap[Datum](): TreemapLayout[Datum] = js.native
    def treemapBinary(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
    def treemapDice(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
    def treemapResquarify(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
    def treemapSlice(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
    def treemapSliceDice(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
    def treemapSquarify(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
    def tsv[Columns /* <: String */](url: String): js.Promise[DSVRowArray[Columns]] = js.native
    def tsv[Columns /* <: String */](url: String, init: typingsSlinky.std.RequestInit): js.Promise[DSVRowArray[Columns]] = js.native
    def tsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
      url: String,
      init: typingsSlinky.std.RequestInit,
      row: js.Function3[
          /* rawRow */ DSVRowString[Columns], 
          /* index */ Double, 
          /* columns */ js.Array[Columns], 
          js.UndefOr[ParsedRow | Null]
        ]
    ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
    def tsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
      url: String,
      row: js.Function3[
          /* rawRow */ DSVRowString[Columns], 
          /* index */ Double, 
          /* columns */ js.Array[Columns], 
          js.UndefOr[ParsedRow | Null]
        ]
    ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
    def tsvFormat[T /* <: js.Object */](rows: js.Array[T]): String = js.native
    def tsvFormat[T /* <: js.Object */](rows: js.Array[T], columns: js.Array[String]): String = js.native
    def tsvFormatRows(rows: js.Array[js.Array[String]]): String = js.native
    def tsvParse[Columns /* <: String */](tsvString: String): DSVRowArray[Columns] = js.native
    def tsvParse[ParsedRow /* <: js.Object */, Columns /* <: String */](
      tsvString: String,
      row: js.Function3[
          /* rawRow */ DSVRowString[Columns], 
          /* index */ Double, 
          /* columns */ js.Array[Columns], 
          js.UndefOr[ParsedRow | Null]
        ]
    ): DSVParsedArray[ParsedRow] = js.native
    def tsvParseRows(tsvString: String): js.Array[js.Array[String]] = js.native
    def tsvParseRows[ParsedRow /* <: js.Object */](
      tsvString: String,
      row: js.Function2[/* rawRow */ js.Array[String], /* index */ Double, js.UndefOr[ParsedRow | Null]]
    ): js.Array[ParsedRow] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def utcDay(date: js.Date): js.Date = js.native
    def utcDays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def utcDays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    def utcFormat(specifier: String): js.Function1[/* date */ js.Date, String] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def utcFriday(date: js.Date): js.Date = js.native
    def utcFridays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def utcFridays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def utcHour(date: js.Date): js.Date = js.native
    def utcHours(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def utcHours(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def utcMillisecond(date: js.Date): js.Date = js.native
    def utcMilliseconds(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def utcMilliseconds(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def utcMinute(date: js.Date): js.Date = js.native
    def utcMinutes(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def utcMinutes(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def utcMonday(date: js.Date): js.Date = js.native
    def utcMondays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def utcMondays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def utcMonth(date: js.Date): js.Date = js.native
    def utcMonths(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def utcMonths(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    def utcParse(specifier: String): js.Function1[/* dateString */ String, js.Date | Null] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def utcSaturday(date: js.Date): js.Date = js.native
    def utcSaturdays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def utcSaturdays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def utcSecond(date: js.Date): js.Date = js.native
    def utcSeconds(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def utcSeconds(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def utcSunday(date: js.Date): js.Date = js.native
    def utcSundays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def utcSundays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def utcThursday(date: js.Date): js.Date = js.native
    def utcThursdays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def utcThursdays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def utcTuesday(date: js.Date): js.Date = js.native
    def utcTuesdays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def utcTuesdays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def utcWednesday(date: js.Date): js.Date = js.native
    def utcWednesdays(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def utcWednesdays(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def utcWeek(date: js.Date): js.Date = js.native
    def utcWeeks(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def utcWeeks(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    /**
      * Returns a new date representing the latest interval boundary date before or equal to date.
      * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
      *
      * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
      *
      * This function is idempotent: if the specified date is already floored to the current interval,
      * a new date with an identical time is returned.
      * Furthermore, the returned date is the minimum expressible value of the associated interval,
      * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
      *
      * Note that the == and === operators do not compare by value with Date objects,
      * and thus you cannot use them to tell whether the specified date has already been floored.
      * Instead, coerce to a number and then compare.
      *
      * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
      *
      * @param date A date object.
      */
    def utcYear(date: js.Date): js.Date = js.native
    def utcYears(start: js.Date, stop: js.Date): js.Array[js.Date] = js.native
    def utcYears(start: js.Date, stop: js.Date, step: Double): js.Array[js.Date] = js.native
    def values(obj: js.Object): js.Array[_] = js.native
    def values[T](obj: StringDictionary[T]): js.Array[T] = js.native
    def values[T](obj: ArrayLike[T]): js.Array[T] = js.native
    def variance[T /* <: Numeric */](array: Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = js.native
    def variance[T](
      array: Iterable[T],
      accessor: js.Function3[
          /* datum */ T, 
          /* index */ Double, 
          /* array */ js.Iterable[T], 
          js.UndefOr[Double | Null]
        ]
    ): js.UndefOr[Double] = js.native
    def voronoi[T](): VoronoiLayout[T] = js.native
    def window(DOMNode: Document): org.scalajs.dom.raw.Window = js.native
    def window(DOMNode: Element): org.scalajs.dom.raw.Window = js.native
    def window(DOMNode: Window): org.scalajs.dom.raw.Window = js.native
    def xml(url: String): js.Promise[XMLDocument] = js.native
    def xml(url: String, init: RequestInit): js.Promise[XMLDocument] = js.native
    def zip[T](arrays: ArrayLike[T]*): js.Array[js.Array[T]] = js.native
    def zoom[ZoomRefElement /* <: ZoomedElementBaseType */, Datum](): ZoomBehavior[ZoomRefElement, Datum] = js.native
    def zoomTransform(node: ZoomedElementBaseType): ZoomTransform = js.native
  }
  
}

