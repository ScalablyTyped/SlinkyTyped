package typingsSlinky.plottable

import typingsSlinky.plottable.scaleMod.Scale
import typingsSlinky.plottable.scalesMod.IPaddingExceptionsProvider
import typingsSlinky.plottable.scalesMod.ITransformableScale
import typingsSlinky.plottable.tickGeneratorsMod.ITickGenerator
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object quantitativeScaleMod {
  
  @JSImport("plottable/build/src/scales/quantitativeScale", "QuantitativeScale")
  @js.native
  /**
    * A QuantitativeScale is a Scale that maps number-like values to numbers.
    * It is invertible and continuous.
    *
    * @constructor
    */
  class QuantitativeScale[D] ()
    extends Scale[D, Double]
       with ITransformableScale {
    
    /* protected */ def _defaultExtent(): js.Array[D] = js.native
    
    var _domainMax: js.Any = js.native
    
    var _domainMin: js.Any = js.native
    
    /* protected */ def _expandSingleValueDomain(singleValueDomain: js.Array[D]): js.Array[D] = js.native
    
    /* protected */ def _getUnboundedExtent(): js.Array[D] = js.native
    /* protected */ def _getUnboundedExtent(ignoreAttachState: Boolean): js.Array[D] = js.native
    
    /**
      * Given a domain, expands its domain onto "nice" values, e.g. whole
      * numbers.
      */
    /* protected */ def _niceDomain(domain: js.Array[D]): js.Array[D] = js.native
    /* protected */ def _niceDomain(domain: js.Array[D], count: Double): js.Array[D] = js.native
    
    /* private */ def _padDomain(domain: js.Any): js.Any = js.native
    
    var _padProportion: js.Any = js.native
    
    var _paddingExceptionsProviders: js.Any = js.native
    
    var _snappingDomainEnabled: js.Any = js.native
    
    var _tickGenerator: js.Any = js.native
    
    /**
      * Adds a padding exception provider.
      * If one end of the domain is set to an excepted value as a result of autoDomain()-ing,
      * that end of the domain will not be padded.
      *
      * @param {Scales.PaddingExceptionProvider<D>} provider The provider function.
      * @returns {QuantitativeScale} The calling QuantitativeScale.
      */
    def addPaddingExceptionsProvider(provider: IPaddingExceptionsProvider[D]): this.type = js.native
    
    /**
      * Gets the array of tick values generated by the default algorithm.
      */
    def defaultTicks(): js.Array[D] = js.native
    
    /**
      * Gets the upper end of the domain.
      *
      * @return {D}
      */
    def domainMax(): D = js.native
    /**
      * Sets the upper end of the domain.
      *
      * @return {QuantitativeScale} The calling QuantitativeScale.
      */
    def domainMax(domainMax: D): this.type = js.native
    
    /**
      * Gets the lower end of the domain.
      *
      * @return {D}
      */
    def domainMin(): D = js.native
    /**
      * Sets the lower end of the domain.
      *
      * @return {QuantitativeScale} The calling QuantitativeScale.
      */
    def domainMin(domainMin: D): this.type = js.native
    
    /**
      * Computes the domain value corresponding to a supplied range value.
      *
      * @param {number} value: A value from the Scale's range.
      * @returns {D} The domain value corresponding to the supplied range value.
      */
    def invert(value: Double): D = js.native
    
    /**
      * Gets the padding proportion.
      */
    def padProportion(): Double = js.native
    /**
      * Sets the padding porportion.
      * When autoDomain()-ing, the computed domain will be expanded by this proportion,
      * then rounded to human-readable values.
      *
      * @param {number} padProportion The padding proportion. Passing 0 disables padding.
      * @returns {QuantitativeScale} The calling QuantitativeScale.
      */
    def padProportion(padProportion: Double): this.type = js.native
    
    /**
      * Removes the padding exception provider.
      *
      * @param {Scales.PaddingExceptionProvider<D>} provider The provider function.
      * @returns {QuantitativeScale} The calling QuantitativeScale.
      */
    def removePaddingExceptionsProvider(provider: IPaddingExceptionsProvider[D]): this.type = js.native
    
    /**
      * Gets whether or not the scale snaps its domain to nice values.
      */
    def snappingDomainEnabled(): Boolean = js.native
    /**
      * Sets whether or not the scale snaps its domain to nice values.
      */
    def snappingDomainEnabled(snappingDomainEnabled: Boolean): this.type = js.native
    
    /**
      * Gets the TickGenerator.
      */
    def tickGenerator(): ITickGenerator[D] = js.native
    /**
      * Sets the TickGenerator
      *
      * @param {TickGenerator} generator
      * @return {QuantitativeScale} The calling QuantitativeScale.
      */
    def tickGenerator(generator: ITickGenerator[D]): this.type = js.native
  }
  /* static members */
  object QuantitativeScale {
    
    @JSImport("plottable/build/src/scales/quantitativeScale", "QuantitativeScale")
    @js.native
    val ^ : js.Any = js.native
    
    @JSImport("plottable/build/src/scales/quantitativeScale", "QuantitativeScale._DEFAULT_NUM_TICKS")
    @js.native
    def _DEFAULT_NUM_TICKS: Double = js.native
    @scala.inline
    def _DEFAULT_NUM_TICKS_=(x: Double): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("_DEFAULT_NUM_TICKS")(x.asInstanceOf[js.Any])
  }
}
