package typingsSlinky.phaser.Phaser.Cameras.Scene2D.Effects

import typingsSlinky.phaser.CameraRotateCallback
import typingsSlinky.phaser.Phaser.Cameras.Scene2D.Camera
import typingsSlinky.phaser.integer
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

/**
  * A Camera Rotate effect.
  * 
  * This effect will rotate the Camera so that the its viewport finishes at the given angle in radians,
  * over the duration and with the ease specified.
  * 
  * Camera rotation always takes place based on the Camera viewport. By default, rotation happens
  * in the center of the viewport. You can adjust this with the `originX` and `originY` properties.
  * 
  * Rotation influences the rendering of _all_ Game Objects visible by this Camera. However, it does not
  * rotate the Camera viewport itself, which always remains an axis-aligned rectangle.
  * 
  * Only the camera is rotates. None of the objects it is displaying are impacted, i.e. their positions do
  * not change.
  * 
  * The effect will dispatch several events on the Camera itself and you can also specify an `onUpdate` callback,
  * which is invoked each frame for the duration of the effect if required.
  */
@js.native
trait RotateTo extends js.Object {
  
  /**
    * The Camera this effect belongs to.
    */
  val camera: Camera = js.native
  
  /**
    * The direction of the rotation.
    */
  var clockwise: Boolean = js.native
  
  /**
    * The constantly updated value based on the force.
    */
  var current: Double = js.native
  
  /**
    * The destination angle in radians to rotate the camera to.
    */
  var destination: Double = js.native
  
  /**
    * Destroys this effect, releasing it from the Camera.
    */
  def destroy(): Unit = js.native
  
  /**
    * The duration of the effect, in milliseconds.
    */
  val duration: integer = js.native
  
  /**
    * The ease function to use during the Rotate.
    */
  var ease: js.Function = js.native
  
  /**
    * Called internally when the effect completes.
    */
  def effectComplete(): Unit = js.native
  
  /**
    * Is this effect actively running?
    */
  val isRunning: Boolean = js.native
  
  /**
    * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.
    */
  var progress: Double = js.native
  
  /**
    * Resets this camera effect.
    * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.
    */
  def reset(): Unit = js.native
  
  /**
    * The shortest direction to the target rotation.
    */
  var shortestPath: Boolean = js.native
  
  /**
    * The starting angle to rotate the camera from.
    */
  var source: Double = js.native
  
  /**
    * This effect will scroll the Camera so that the center of its viewport finishes at the given angle,
    * over the duration and with the ease specified.
    * @param radians The destination angle in radians to rotate the Camera viewport to. If the angle is positive then the rotation is clockwise else anticlockwise
    * @param shortestPath If shortest path is set to true the camera will rotate in the quickest direction clockwise or anti-clockwise. Default false.
    * @param duration The duration of the effect in milliseconds. Default 1000.
    * @param ease The ease to use for the Rotate. Can be any of the Phaser Easing constants or a custom function. Default 'Linear'.
    * @param force Force the rotation effect to start immediately, even if already running. Default false.
    * @param callback This callback will be invoked every frame for the duration of the effect.
    * It is sent four arguments: A reference to the camera, a progress amount between 0 and 1 indicating how complete the effect is,
    * the current camera scroll x coordinate and the current camera scroll y coordinate.
    * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
    */
  def start(
    radians: Double,
    shortestPath: js.UndefOr[Boolean],
    duration: js.UndefOr[integer],
    ease: js.UndefOr[String | js.Function],
    force: js.UndefOr[Boolean],
    callback: js.UndefOr[CameraRotateCallback],
    context: js.UndefOr[js.Any]
  ): Camera = js.native
  
  /**
    * The main update loop for this effect. Called automatically by the Camera.
    * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
    * @param delta The delta time, in ms, elapsed since the last frame.
    */
  def update(time: integer, delta: Double): Unit = js.native
}
object RotateTo {
  
  @scala.inline
  def apply(
    camera: Camera,
    clockwise: Boolean,
    current: Double,
    destination: Double,
    destroy: () => Unit,
    duration: integer,
    ease: js.Function,
    effectComplete: () => Unit,
    isRunning: Boolean,
    progress: Double,
    reset: () => Unit,
    shortestPath: Boolean,
    source: Double,
    start: (Double, js.UndefOr[Boolean], js.UndefOr[integer], js.UndefOr[String | js.Function], js.UndefOr[Boolean], js.UndefOr[CameraRotateCallback], js.UndefOr[js.Any]) => Camera,
    update: (integer, Double) => Unit
  ): RotateTo = {
    val __obj = js.Dynamic.literal(camera = camera.asInstanceOf[js.Any], clockwise = clockwise.asInstanceOf[js.Any], current = current.asInstanceOf[js.Any], destination = destination.asInstanceOf[js.Any], destroy = js.Any.fromFunction0(destroy), duration = duration.asInstanceOf[js.Any], ease = ease.asInstanceOf[js.Any], effectComplete = js.Any.fromFunction0(effectComplete), isRunning = isRunning.asInstanceOf[js.Any], progress = progress.asInstanceOf[js.Any], reset = js.Any.fromFunction0(reset), shortestPath = shortestPath.asInstanceOf[js.Any], source = source.asInstanceOf[js.Any], start = js.Any.fromFunction7(start), update = js.Any.fromFunction2(update))
    __obj.asInstanceOf[RotateTo]
  }
  
  @scala.inline
  implicit class RotateToOps[Self <: RotateTo] (val x: Self) extends AnyVal {
    
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    
    @scala.inline
    def set(key: String, value: js.Any): Self = {
      x.asInstanceOf[js.Dynamic].updateDynamic(key)(value)
      x
    }
    
    @scala.inline
    def setCamera(value: Camera): Self = this.set("camera", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setClockwise(value: Boolean): Self = this.set("clockwise", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setCurrent(value: Double): Self = this.set("current", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setDestination(value: Double): Self = this.set("destination", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setDestroy(value: () => Unit): Self = this.set("destroy", js.Any.fromFunction0(value))
    
    @scala.inline
    def setDuration(value: integer): Self = this.set("duration", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setEase(value: js.Function): Self = this.set("ease", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setEffectComplete(value: () => Unit): Self = this.set("effectComplete", js.Any.fromFunction0(value))
    
    @scala.inline
    def setIsRunning(value: Boolean): Self = this.set("isRunning", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setProgress(value: Double): Self = this.set("progress", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setReset(value: () => Unit): Self = this.set("reset", js.Any.fromFunction0(value))
    
    @scala.inline
    def setShortestPath(value: Boolean): Self = this.set("shortestPath", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setSource(value: Double): Self = this.set("source", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setStart(
      value: (Double, js.UndefOr[Boolean], js.UndefOr[integer], js.UndefOr[String | js.Function], js.UndefOr[Boolean], js.UndefOr[CameraRotateCallback], js.UndefOr[js.Any]) => Camera
    ): Self = this.set("start", js.Any.fromFunction7(value))
    
    @scala.inline
    def setUpdate(value: (integer, Double) => Unit): Self = this.set("update", js.Any.fromFunction2(value))
  }
}
