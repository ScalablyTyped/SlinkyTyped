package typingsSlinky.phaser.Phaser.Cameras.Scene2D.Effects

import org.scalajs.dom.raw.CanvasRenderingContext2D
import typingsSlinky.phaser.Phaser.Cameras.Scene2D.Camera
import typingsSlinky.phaser.Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline
import typingsSlinky.phaser.Phaser.Types.Cameras.Scene2D.CameraFadeCallback
import typingsSlinky.phaser.integer
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

/**
  * A Camera Fade effect.
  * 
  * This effect will fade the camera viewport to the given color, over the duration specified.
  * 
  * Only the camera viewport is faded. None of the objects it is displaying are impacted, i.e. their colors do
  * not change.
  * 
  * The effect will dispatch several events on the Camera itself and you can also specify an `onUpdate` callback,
  * which is invoked each frame for the duration of the effect, if required.
  */
@js.native
trait Fade extends js.Object {
  /**
    * The Camera this effect belongs to.
    */
  val camera: Camera = js.native
  /**
    * The direction of the fade.
    * `true` = fade out (transparent to color), `false` = fade in (color to transparent)
    */
  val direction: Boolean = js.native
  /**
    * The duration of the effect, in milliseconds.
    */
  val duration: integer = js.native
  /**
    * Has this effect finished running?
    * 
    * This is different from `isRunning` because it remains set to `true` when the effect is over,
    * until the effect is either reset or started again.
    */
  val isComplete: Boolean = js.native
  /**
    * Is this effect actively running?
    */
  val isRunning: Boolean = js.native
  /**
    * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.
    */
  var progress: Double = js.native
  /**
    * Destroys this effect, releasing it from the Camera.
    */
  def destroy(): Unit = js.native
  /**
    * Called internally when the effect completes.
    */
  def effectComplete(): Unit = js.native
  /**
    * Called internally by the Canvas Renderer.
    * @param ctx The Canvas context to render to.
    */
  def postRenderCanvas(ctx: CanvasRenderingContext2D): Boolean = js.native
  /**
    * Called internally by the WebGL Renderer.
    * @param pipeline The WebGL Pipeline to render to.
    * @param getTintFunction A function that will return the gl safe tint colors.
    */
  def postRenderWebGL(pipeline: TextureTintPipeline, getTintFunction: js.Function): Boolean = js.native
  /**
    * Resets this camera effect.
    * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.
    */
  def reset(): Unit = js.native
  /**
    * Fades the Camera to or from the given color over the duration specified.
    * @param direction The direction of the fade. `true` = fade out (transparent to color), `false` = fade in (color to transparent) Default true.
    * @param duration The duration of the effect in milliseconds. Default 1000.
    * @param red The amount to fade the red channel towards. A value between 0 and 255. Default 0.
    * @param green The amount to fade the green channel towards. A value between 0 and 255. Default 0.
    * @param blue The amount to fade the blue channel towards. A value between 0 and 255. Default 0.
    * @param force Force the effect to start immediately, even if already running. Default false.
    * @param callback This callback will be invoked every frame for the duration of the effect.
    * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
    * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
    */
  def start(
    direction: js.UndefOr[Boolean],
    duration: js.UndefOr[integer],
    red: js.UndefOr[integer],
    green: js.UndefOr[integer],
    blue: js.UndefOr[integer],
    force: js.UndefOr[Boolean],
    callback: js.UndefOr[CameraFadeCallback],
    context: js.UndefOr[js.Any]
  ): Camera = js.native
  /**
    * The main update loop for this effect. Called automatically by the Camera.
    * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
    * @param delta The delta time, in ms, elapsed since the last frame.
    */
  def update(time: integer, delta: Double): Unit = js.native
}

object Fade {
  @scala.inline
  def apply(
    camera: Camera,
    destroy: () => Unit,
    direction: Boolean,
    duration: integer,
    effectComplete: () => Unit,
    isComplete: Boolean,
    isRunning: Boolean,
    postRenderCanvas: CanvasRenderingContext2D => Boolean,
    postRenderWebGL: (TextureTintPipeline, js.Function) => Boolean,
    progress: Double,
    reset: () => Unit,
    start: (js.UndefOr[Boolean], js.UndefOr[integer], js.UndefOr[integer], js.UndefOr[integer], js.UndefOr[integer], js.UndefOr[Boolean], js.UndefOr[CameraFadeCallback], js.UndefOr[js.Any]) => Camera,
    update: (integer, Double) => Unit
  ): Fade = {
    val __obj = js.Dynamic.literal(camera = camera.asInstanceOf[js.Any], destroy = js.Any.fromFunction0(destroy), direction = direction.asInstanceOf[js.Any], duration = duration.asInstanceOf[js.Any], effectComplete = js.Any.fromFunction0(effectComplete), isComplete = isComplete.asInstanceOf[js.Any], isRunning = isRunning.asInstanceOf[js.Any], postRenderCanvas = js.Any.fromFunction1(postRenderCanvas), postRenderWebGL = js.Any.fromFunction2(postRenderWebGL), progress = progress.asInstanceOf[js.Any], reset = js.Any.fromFunction0(reset), start = js.Any.fromFunction8(start), update = js.Any.fromFunction2(update))
    __obj.asInstanceOf[Fade]
  }
  @scala.inline
  implicit class FadeOps[Self <: Fade] (val x: Self) extends AnyVal {
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    @scala.inline
    def withCamera(value: Camera): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("camera")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withDestroy(value: () => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("destroy")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withDirection(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("direction")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withDuration(value: integer): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("duration")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withEffectComplete(value: () => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("effectComplete")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withIsComplete(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("isComplete")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withIsRunning(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("isRunning")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withPostRenderCanvas(value: CanvasRenderingContext2D => Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("postRenderCanvas")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withPostRenderWebGL(value: (TextureTintPipeline, js.Function) => Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("postRenderWebGL")(js.Any.fromFunction2(value))
        ret
    }
    @scala.inline
    def withProgress(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("progress")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withReset(value: () => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("reset")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withStart(
      value: (js.UndefOr[Boolean], js.UndefOr[integer], js.UndefOr[integer], js.UndefOr[integer], js.UndefOr[integer], js.UndefOr[Boolean], js.UndefOr[CameraFadeCallback], js.UndefOr[js.Any]) => Camera
    ): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("start")(js.Any.fromFunction8(value))
        ret
    }
    @scala.inline
    def withUpdate(value: (integer, Double) => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("update")(js.Any.fromFunction2(value))
        ret
    }
  }
  
}

