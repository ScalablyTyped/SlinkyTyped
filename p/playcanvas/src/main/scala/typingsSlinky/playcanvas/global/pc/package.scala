package typingsSlinky.playcanvas.global

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

package object pc {
  
  /**
    * Clamps texture coordinate to the range 0 to 1.
    */
  @scala.inline
  def ADDRESS_CLAMP_TO_EDGE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ADDRESS_CLAMP_TO_EDGE").asInstanceOf[scala.Double]
  
  /**
    * Texture coordinate to be set to the fractional part if the integer part is even. If the integer part is odd,
    * then the texture coordinate is set to 1 minus the fractional part.
    */
  @scala.inline
  def ADDRESS_MIRRORED_REPEAT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ADDRESS_MIRRORED_REPEAT").asInstanceOf[scala.Double]
  
  /**
    * Ignores the integer part of texture coordinates, using only the fractional part.
    */
  @scala.inline
  def ADDRESS_REPEAT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ADDRESS_REPEAT").asInstanceOf[scala.Double]
  
  /**
    * Automatically set aspect ratio to current render target's width divided by height.
    */
  @scala.inline
  def ASPECT_AUTO: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASPECT_AUTO").asInstanceOf[scala.Double]
  
  /**
    * Use the manual aspect ratio value.
    */
  @scala.inline
  def ASPECT_MANUAL: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASPECT_MANUAL").asInstanceOf[scala.Double]
  
  /**
    * Asset type name for animation.
    */
  @scala.inline
  def ASSET_ANIMATION: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_ANIMATION").asInstanceOf[java.lang.String]
  
  /**
    * Asset type name for audio.
    */
  @scala.inline
  def ASSET_AUDIO: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_AUDIO").asInstanceOf[java.lang.String]
  
  /**
    * Asset type name for a container.
    */
  @scala.inline
  def ASSET_CONTAINER: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_CONTAINER").asInstanceOf[java.lang.String]
  
  /**
    * Asset type name for CSS.
    */
  @scala.inline
  def ASSET_CSS: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_CSS").asInstanceOf[java.lang.String]
  
  /**
    * Asset type name for cubemap.
    */
  @scala.inline
  def ASSET_CUBEMAP: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_CUBEMAP").asInstanceOf[java.lang.String]
  
  /**
    * Asset type name for HTML.
    */
  @scala.inline
  def ASSET_HTML: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_HTML").asInstanceOf[java.lang.String]
  
  /**
    * Asset type name for image.
    */
  @scala.inline
  def ASSET_IMAGE: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_IMAGE").asInstanceOf[java.lang.String]
  
  /**
    * Asset type name for json.
    */
  @scala.inline
  def ASSET_JSON: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_JSON").asInstanceOf[java.lang.String]
  
  /**
    * Asset type name for material.
    */
  @scala.inline
  def ASSET_MATERIAL: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_MATERIAL").asInstanceOf[java.lang.String]
  
  /**
    * Asset type name for model.
    */
  @scala.inline
  def ASSET_MODEL: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_MODEL").asInstanceOf[java.lang.String]
  
  /**
    * Asset type name for script.
    */
  @scala.inline
  def ASSET_SCRIPT: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_SCRIPT").asInstanceOf[java.lang.String]
  
  /**
    * Asset type name for shader.
    */
  @scala.inline
  def ASSET_SHADER: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_SHADER").asInstanceOf[java.lang.String]
  
  /**
    * Asset type name for text.
    */
  @scala.inline
  def ASSET_TEXT: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_TEXT").asInstanceOf[java.lang.String]
  
  /**
    * Asset type name for texture.
    */
  @scala.inline
  def ASSET_TEXTURE: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_TEXTURE").asInstanceOf[java.lang.String]
  
  /**
    * Single color lightmap.
    */
  @scala.inline
  def BAKE_COLOR: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BAKE_COLOR").asInstanceOf[scala.Double]
  
  /**
    * Single color lightmap + dominant light direction (used for bump/specular).
    */
  @scala.inline
  def BAKE_COLORDIR: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BAKE_COLORDIR").asInstanceOf[scala.Double]
  
  /**
    * Add the results of the source and destination fragment multiplies.
    */
  @scala.inline
  def BLENDEQUATION_ADD: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDEQUATION_ADD").asInstanceOf[scala.Double]
  
  /**
    * Use the largest value. Check app.graphicsDevice.extBlendMinmax for support.
    */
  @scala.inline
  def BLENDEQUATION_MAX: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDEQUATION_MAX").asInstanceOf[scala.Double]
  
  /**
    * Use the smallest value. Check app.graphicsDevice.extBlendMinmax for support.
    */
  @scala.inline
  def BLENDEQUATION_MIN: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDEQUATION_MIN").asInstanceOf[scala.Double]
  
  /**
    * Reverse and subtract the results of the source and destination fragment multiplies.
    */
  @scala.inline
  def BLENDEQUATION_REVERSE_SUBTRACT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDEQUATION_REVERSE_SUBTRACT").asInstanceOf[scala.Double]
  
  /**
    * Subtract the results of the source and destination fragment multiplies.
    */
  @scala.inline
  def BLENDEQUATION_SUBTRACT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDEQUATION_SUBTRACT").asInstanceOf[scala.Double]
  
  /**
    * Multiply all fragment components by the alpha value of the destination fragment.
    */
  @scala.inline
  def BLENDMODE_DST_ALPHA: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_DST_ALPHA").asInstanceOf[scala.Double]
  
  /**
    * Multiply all fragment components by the components of the destination fragment.
    */
  @scala.inline
  def BLENDMODE_DST_COLOR: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_DST_COLOR").asInstanceOf[scala.Double]
  
  /**
    * Multiply all fragment components by one.
    */
  @scala.inline
  def BLENDMODE_ONE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_ONE").asInstanceOf[scala.Double]
  
  /**
    * Multiply all fragment components by one minus the alpha value of the destination fragment.
    */
  @scala.inline
  def BLENDMODE_ONE_MINUS_DST_ALPHA: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_ONE_MINUS_DST_ALPHA").asInstanceOf[scala.Double]
  
  /**
    * Multiply all fragment components by one minus the components of the destination fragment.
    */
  @scala.inline
  def BLENDMODE_ONE_MINUS_DST_COLOR: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_ONE_MINUS_DST_COLOR").asInstanceOf[scala.Double]
  
  /**
    * Multiply all fragment components by one minus the alpha value of the source fragment.
    */
  @scala.inline
  def BLENDMODE_ONE_MINUS_SRC_ALPHA: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_ONE_MINUS_SRC_ALPHA").asInstanceOf[scala.Double]
  
  /**
    * Multiply all fragment components by one minus the components of the source fragment.
    */
  @scala.inline
  def BLENDMODE_ONE_MINUS_SRC_COLOR: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_ONE_MINUS_SRC_COLOR").asInstanceOf[scala.Double]
  
  /**
    * Multiply all fragment components by the alpha value of the source fragment.
    */
  @scala.inline
  def BLENDMODE_SRC_ALPHA: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_SRC_ALPHA").asInstanceOf[scala.Double]
  
  /**
    * Multiply all fragment components by the alpha value of the source fragment.
    */
  @scala.inline
  def BLENDMODE_SRC_ALPHA_SATURATE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_SRC_ALPHA_SATURATE").asInstanceOf[scala.Double]
  
  /**
    * Multiply all fragment components by the components of the source fragment.
    */
  @scala.inline
  def BLENDMODE_SRC_COLOR: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_SRC_COLOR").asInstanceOf[scala.Double]
  
  /**
    * Multiply all fragment components by zero.
    */
  @scala.inline
  def BLENDMODE_ZERO: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_ZERO").asInstanceOf[scala.Double]
  
  /**
    * Add the color of the source fragment to the destination fragment
    * and write the result to the frame buffer.
    */
  @scala.inline
  def BLEND_ADDITIVE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_ADDITIVE").asInstanceOf[scala.Double]
  
  /**
    * Same as pc.BLEND_ADDITIVE except the source RGB is multiplied by the source alpha.
    */
  @scala.inline
  def BLEND_ADDITIVEALPHA: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_ADDITIVEALPHA").asInstanceOf[scala.Double]
  
  /**
    * Maximum color. Check app.graphicsDevice.extBlendMinmax for support.
    */
  @scala.inline
  def BLEND_MAX: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_MAX").asInstanceOf[scala.Double]
  
  /**
    * Minimum color. Check app.graphicsDevice.extBlendMinmax for support.
    */
  @scala.inline
  def BLEND_MIN: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_MIN").asInstanceOf[scala.Double]
  
  /**
    * Multiply the color of the source fragment by the color of the destination
    * fragment and write the result to the frame buffer.
    */
  @scala.inline
  def BLEND_MULTIPLICATIVE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_MULTIPLICATIVE").asInstanceOf[scala.Double]
  
  /**
    * Multiplies colors and doubles the result.
    */
  @scala.inline
  def BLEND_MULTIPLICATIVE2X: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_MULTIPLICATIVE2X").asInstanceOf[scala.Double]
  
  /**
    * Disable blending.
    */
  @scala.inline
  def BLEND_NONE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_NONE").asInstanceOf[scala.Double]
  
  /**
    * Enable simple translucency for materials such as glass. This is
    * equivalent to enabling a source blend mode of pc.BLENDMODE_SRC_ALPHA and a destination
    * blend mode of pc.BLENDMODE_ONE_MINUS_SRC_ALPHA.
    */
  @scala.inline
  def BLEND_NORMAL: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_NORMAL").asInstanceOf[scala.Double]
  
  /**
    * Similar to pc.BLEND_NORMAL expect the source fragment is assumed to have
    * already been multiplied by the source alpha value.
    */
  @scala.inline
  def BLEND_PREMULTIPLIED: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_PREMULTIPLIED").asInstanceOf[scala.Double]
  
  /**
    * Softer version of additive.
    */
  @scala.inline
  def BLEND_SCREEN: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_SCREEN").asInstanceOf[scala.Double]
  
  /**
    * Subtract the color of the source fragment from the destination fragment
    * and write the result to the frame buffer.
    */
  @scala.inline
  def BLEND_SUBTRACTIVE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_SUBTRACTIVE").asInstanceOf[scala.Double]
  
  /**
    * Box filter.
    */
  @scala.inline
  def BLUR_BOX: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLUR_BOX").asInstanceOf[scala.Double]
  
  /**
    * Gaussian filter. May look smoother than box, but requires more samples.
    */
  @scala.inline
  def BLUR_GAUSSIAN: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLUR_GAUSSIAN").asInstanceOf[scala.Double]
  
  /**
    * Rigid body is simulated according to applied forces.
    */
  @scala.inline
  def BODYTYPE_DYNAMIC: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BODYTYPE_DYNAMIC").asInstanceOf[java.lang.String]
  
  /**
    * Rigid body has infinite mass and does not respond to forces but can still be moved by setting their velocity or position.
    */
  @scala.inline
  def BODYTYPE_KINEMATIC: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BODYTYPE_KINEMATIC").asInstanceOf[java.lang.String]
  
  /**
    * Rigid body has infinite mass and cannot move.
    */
  @scala.inline
  def BODYTYPE_STATIC: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BODYTYPE_STATIC").asInstanceOf[java.lang.String]
  
  /**
    * The data store contents will be modified repeatedly and used many times.
    */
  @scala.inline
  def BUFFER_DYNAMIC: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BUFFER_DYNAMIC").asInstanceOf[scala.Double]
  
  /**
    * The data store contents will be modified repeatedly on the GPU and used many times. Optimal for transform feedback usage (WebGL2 only).
    */
  @scala.inline
  def BUFFER_GPUDYNAMIC: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BUFFER_GPUDYNAMIC").asInstanceOf[scala.Double]
  
  /**
    * The data store contents will be modified once and used many times.
    */
  @scala.inline
  def BUFFER_STATIC: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BUFFER_STATIC").asInstanceOf[scala.Double]
  
  /**
    * The data store contents will be modified once and used at most a few times.
    */
  @scala.inline
  def BUFFER_STREAM: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BUFFER_STREAM").asInstanceOf[scala.Double]
  
  /**
    * Specifies different sprites for the hover, pressed and inactive states.
    */
  @scala.inline
  def BUTTON_TRANSITION_MODE_SPRITE_CHANGE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BUTTON_TRANSITION_MODE_SPRITE_CHANGE").asInstanceOf[scala.Double]
  
  /**
    * Specifies different color tints for the hover, pressed and inactive states.
    */
  @scala.inline
  def BUTTON_TRANSITION_MODE_TINT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BUTTON_TRANSITION_MODE_TINT").asInstanceOf[scala.Double]
  
  /**
    * Clear the color buffer.
    */
  @scala.inline
  def CLEARFLAG_COLOR: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CLEARFLAG_COLOR").asInstanceOf[scala.Double]
  
  /**
    * Clear the depth buffer.
    */
  @scala.inline
  def CLEARFLAG_DEPTH: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CLEARFLAG_DEPTH").asInstanceOf[scala.Double]
  
  /**
    * Clear the stencil buffer.
    */
  @scala.inline
  def CLEARFLAG_STENCIL: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CLEARFLAG_STENCIL").asInstanceOf[scala.Double]
  
  /**
    * The negative X face of a cubemap.
    */
  @scala.inline
  def CUBEFACE_NEGX: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CUBEFACE_NEGX").asInstanceOf[scala.Double]
  
  /**
    * The negative Y face of a cubemap.
    */
  @scala.inline
  def CUBEFACE_NEGY: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CUBEFACE_NEGY").asInstanceOf[scala.Double]
  
  /**
    * The negative Z face of a cubemap.
    */
  @scala.inline
  def CUBEFACE_NEGZ: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CUBEFACE_NEGZ").asInstanceOf[scala.Double]
  
  /**
    * The positive X face of a cubemap.
    */
  @scala.inline
  def CUBEFACE_POSX: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CUBEFACE_POSX").asInstanceOf[scala.Double]
  
  /**
    * The positive Y face of a cubemap.
    */
  @scala.inline
  def CUBEFACE_POSY: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CUBEFACE_POSY").asInstanceOf[scala.Double]
  
  /**
    * The positive Z face of a cubemap.
    */
  @scala.inline
  def CUBEFACE_POSZ: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CUBEFACE_POSZ").asInstanceOf[scala.Double]
  
  /**
    * The cube map is box-projected based on a world space axis-aligned bounding box.
    */
  @scala.inline
  def CUBEPROJ_BOX: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CUBEPROJ_BOX").asInstanceOf[scala.Double]
  
  /**
    * The cube map is treated as if it is infinitely far away.
    */
  @scala.inline
  def CUBEPROJ_NONE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CUBEPROJ_NONE").asInstanceOf[scala.Double]
  
  /**
    * Triangles facing away from the view direction are culled.
    */
  @scala.inline
  def CULLFACE_BACK: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CULLFACE_BACK").asInstanceOf[scala.Double]
  
  /**
    * Triangles facing the view direction are culled.
    */
  @scala.inline
  def CULLFACE_FRONT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CULLFACE_FRONT").asInstanceOf[scala.Double]
  
  /**
    * Triangles are culled regardless of their orientation with respect to the view
    * direction. Note that point or line primitives are unaffected by this render state.
    */
  @scala.inline
  def CULLFACE_FRONTANDBACK: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CULLFACE_FRONTANDBACK").asInstanceOf[scala.Double]
  
  /**
    * No triangles are culled.
    */
  @scala.inline
  def CULLFACE_NONE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CULLFACE_NONE").asInstanceOf[scala.Double]
  
  /**
    * A cardinal spline interpolation scheme. This interpolation scheme is deprecated. Use CURVE_SPLINE instead.
    */
  @scala.inline
  def CURVE_CARDINAL: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CURVE_CARDINAL").asInstanceOf[scala.Double]
  
  /**
    * A Catmull-Rom spline interpolation scheme. This interpolation scheme is deprecated. Use CURVE_SPLINE instead.
    */
  @scala.inline
  def CURVE_CATMULL: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CURVE_CATMULL").asInstanceOf[scala.Double]
  
  /**
    * A linear interpolation scheme.
    */
  @scala.inline
  def CURVE_LINEAR: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CURVE_LINEAR").asInstanceOf[scala.Double]
  
  /**
    * A smooth step interpolation scheme.
    */
  @scala.inline
  def CURVE_SMOOTHSTEP: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CURVE_SMOOTHSTEP").asInstanceOf[scala.Double]
  
  /**
    * Cardinal spline interpolation scheme. For Catmull-Rom, specify curve tension 0.5.
    */
  @scala.inline
  def CURVE_SPLINE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CURVE_SPLINE").asInstanceOf[scala.Double]
  
  /**
    * A stepped interpolator, free from the shackles of blending.
    */
  @scala.inline
  def CURVE_STEP: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CURVE_STEP").asInstanceOf[scala.Double]
  
  /**
    * Add together the primary and secondary colors.
    */
  @scala.inline
  def DETAILMODE_ADD: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("DETAILMODE_ADD").asInstanceOf[java.lang.String]
  
  /**
    * Select whichever of the primary and secondary colors is lighter, component-wise.
    */
  @scala.inline
  def DETAILMODE_MAX: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("DETAILMODE_MAX").asInstanceOf[java.lang.String]
  
  /**
    * Select whichever of the primary and secondary colors is darker, component-wise.
    */
  @scala.inline
  def DETAILMODE_MIN: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("DETAILMODE_MIN").asInstanceOf[java.lang.String]
  
  /**
    * Multiply together the primary and secondary colors.
    */
  @scala.inline
  def DETAILMODE_MUL: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("DETAILMODE_MUL").asInstanceOf[java.lang.String]
  
  /**
    * Multiplies or screens the colors, depending on the primary color.
    */
  @scala.inline
  def DETAILMODE_OVERLAY: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("DETAILMODE_OVERLAY").asInstanceOf[java.lang.String]
  
  /**
    * Softer version of {@link pc.DETAILMODE_ADD}.
    */
  @scala.inline
  def DETAILMODE_SCREEN: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("DETAILMODE_SCREEN").asInstanceOf[java.lang.String]
  
  /**
    * Exponential distance model.
    */
  @scala.inline
  def DISTANCE_EXPONENTIAL: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("DISTANCE_EXPONENTIAL").asInstanceOf[java.lang.String]
  
  /**
    * Inverse distance model.
    */
  @scala.inline
  def DISTANCE_INVERSE: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("DISTANCE_INVERSE").asInstanceOf[java.lang.String]
  
  /**
    * Linear distance model.
    */
  @scala.inline
  def DISTANCE_LINEAR: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("DISTANCE_LINEAR").asInstanceOf[java.lang.String]
  
  /**
    * A {@link pc.ElementComponent} that contains child {@link pc.ElementComponent}s.
    */
  @scala.inline
  def ELEMENTTYPE_GROUP: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ELEMENTTYPE_GROUP").asInstanceOf[java.lang.String]
  
  /**
    * A {@link pc.ElementComponent} that displays an image.
    */
  @scala.inline
  def ELEMENTTYPE_IMAGE: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ELEMENTTYPE_IMAGE").asInstanceOf[java.lang.String]
  
  /**
    * A {@link pc.ElementComponent} that displays text.
    */
  @scala.inline
  def ELEMENTTYPE_TEXT: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ELEMENTTYPE_TEXT").asInstanceOf[java.lang.String]
  
  /**
    * Box shape parameterized by emitterExtents. Initial velocity is directed towards local Z axis.
    */
  @scala.inline
  def EMITTERSHAPE_BOX: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EMITTERSHAPE_BOX").asInstanceOf[scala.Double]
  
  /**
    * Sphere shape parameterized by emitterRadius. Initial velocity is directed outwards from the center.
    */
  @scala.inline
  def EMITTERSHAPE_SPHERE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EMITTERSHAPE_SPHERE").asInstanceOf[scala.Double]
  
  /**
    * Name of event fired when a key is pressed.
    */
  @scala.inline
  def EVENT_KEYDOWN: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_KEYDOWN").asInstanceOf[java.lang.String]
  
  /**
    * Name of event fired when a key is released.
    */
  @scala.inline
  def EVENT_KEYUP: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_KEYUP").asInstanceOf[java.lang.String]
  
  /**
    * Name of event fired when a mouse button is pressed.
    */
  @scala.inline
  def EVENT_MOUSEDOWN: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_MOUSEDOWN").asInstanceOf[java.lang.String]
  
  /**
    * Name of event fired when the mouse is moved.
    */
  @scala.inline
  def EVENT_MOUSEMOVE: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_MOUSEMOVE").asInstanceOf[java.lang.String]
  
  /**
    * Name of event fired when a mouse button is released.
    */
  @scala.inline
  def EVENT_MOUSEUP: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_MOUSEUP").asInstanceOf[java.lang.String]
  
  /**
    * Name of event fired when the mouse wheel is rotated.
    */
  @scala.inline
  def EVENT_MOUSEWHEEL: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_MOUSEWHEEL").asInstanceOf[java.lang.String]
  
  /**
    * Name of event fired when a new xr select occurs. For example, primary trigger was pressed.
    */
  @scala.inline
  def EVENT_SELECT: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_SELECT").asInstanceOf[java.lang.String]
  
  /**
    * Name of event fired when xr select ends. For example, a primary trigger is now released.
    */
  @scala.inline
  def EVENT_SELECTEND: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_SELECTEND").asInstanceOf[java.lang.String]
  
  /**
    * Name of event fired when a new xr select starts. For example, primary trigger is now pressed.
    */
  @scala.inline
  def EVENT_SELECTSTART: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_SELECTSTART").asInstanceOf[java.lang.String]
  
  /**
    * Name of event fired when a touch point is interrupted in some way.
    * The exact reasons for canceling a touch can vary from device to device.
    * For example, a modal alert pops up during the interaction; the touch point leaves the document area,
    * or there are more touch points than the device supports, in which case the earliest touch point is canceled.
    */
  @scala.inline
  def EVENT_TOUCHCANCEL: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_TOUCHCANCEL").asInstanceOf[java.lang.String]
  
  /**
    * Name of event fired when touch ends. For example, a finger is lifted off the device.
    */
  @scala.inline
  def EVENT_TOUCHEND: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_TOUCHEND").asInstanceOf[java.lang.String]
  
  /**
    * Name of event fired when a touch moves.
    */
  @scala.inline
  def EVENT_TOUCHMOVE: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_TOUCHMOVE").asInstanceOf[java.lang.String]
  
  /**
    * Name of event fired when a new touch occurs. For example, a finger is placed on the device.
    */
  @scala.inline
  def EVENT_TOUCHSTART: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_TOUCHSTART").asInstanceOf[java.lang.String]
  
  /**
    * When resizing the window the size of the canvas will change to fill the window exactly.
    */
  @scala.inline
  def FILLMODE_FILL_WINDOW: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FILLMODE_FILL_WINDOW").asInstanceOf[java.lang.String]
  
  /**
    * When resizing the window the size of the canvas will change to fill the window as best it can, while maintaining the same aspect ratio.
    */
  @scala.inline
  def FILLMODE_KEEP_ASPECT: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FILLMODE_KEEP_ASPECT").asInstanceOf[java.lang.String]
  
  /**
    * When resizing the window the size of the canvas will not change.
    */
  @scala.inline
  def FILLMODE_NONE: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FILLMODE_NONE").asInstanceOf[java.lang.String]
  
  /**
    * Bilinear filtering.
    */
  @scala.inline
  def FILTER_LINEAR: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FILTER_LINEAR").asInstanceOf[scala.Double]
  
  /**
    * Linearly interpolate both the mipmap levels and between texels.
    */
  @scala.inline
  def FILTER_LINEAR_MIPMAP_LINEAR: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FILTER_LINEAR_MIPMAP_LINEAR").asInstanceOf[scala.Double]
  
  /**
    * Use the nearest neighbor after linearly interpolating between mipmap levels.
    */
  @scala.inline
  def FILTER_LINEAR_MIPMAP_NEAREST: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FILTER_LINEAR_MIPMAP_NEAREST").asInstanceOf[scala.Double]
  
  /**
    * Point sample filtering.
    */
  @scala.inline
  def FILTER_NEAREST: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FILTER_NEAREST").asInstanceOf[scala.Double]
  
  /**
    * Linearly interpolate in the nearest mipmap level.
    */
  @scala.inline
  def FILTER_NEAREST_MIPMAP_LINEAR: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FILTER_NEAREST_MIPMAP_LINEAR").asInstanceOf[scala.Double]
  
  /**
    * Use the nearest neighbor in the nearest mipmap level.
    */
  @scala.inline
  def FILTER_NEAREST_MIPMAP_NEAREST: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FILTER_NEAREST_MIPMAP_NEAREST").asInstanceOf[scala.Double]
  
  /**
    * Apply both STRETCH and SHRINK fitting logic where applicable.
    */
  @scala.inline
  def FITTING_BOTH: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FITTING_BOTH").asInstanceOf[scala.Double]
  
  /**
    * Disable all fitting logic.
    */
  @scala.inline
  def FITTING_NONE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FITTING_NONE").asInstanceOf[scala.Double]
  
  /**
    * Shrink child elements to fit the parent container.
    */
  @scala.inline
  def FITTING_SHRINK: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FITTING_SHRINK").asInstanceOf[scala.Double]
  
  /**
    * Stretch child elements to fit the parent container.
    */
  @scala.inline
  def FITTING_STRETCH: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FITTING_STRETCH").asInstanceOf[scala.Double]
  
  /**
    * Fog rises according to an exponential curve controlled by a density value.
    */
  @scala.inline
  def FOG_EXP: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FOG_EXP").asInstanceOf[java.lang.String]
  
  /**
    * Fog rises according to an exponential curve controlled by a density value.
    */
  @scala.inline
  def FOG_EXP2: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FOG_EXP2").asInstanceOf[java.lang.String]
  
  /**
    * Fog rises linearly from zero to 1 between a start and end depth.
    */
  @scala.inline
  def FOG_LINEAR: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FOG_LINEAR").asInstanceOf[java.lang.String]
  
  /**
    * No fog is applied to the scene.
    */
  @scala.inline
  def FOG_NONE: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FOG_NONE").asInstanceOf[java.lang.String]
  
  /**
    * No Fresnel.
    */
  @scala.inline
  def FRESNEL_NONE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FRESNEL_NONE").asInstanceOf[scala.Double]
  
  /**
    * Schlick's approximation of Fresnel.
    */
  @scala.inline
  def FRESNEL_SCHLICK: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FRESNEL_SCHLICK").asInstanceOf[scala.Double]
  
  /**
    * Always pass.
    */
  @scala.inline
  def FUNC_ALWAYS: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FUNC_ALWAYS").asInstanceOf[scala.Double]
  
  /**
    * Pass if (ref & mask) == (stencil & mask).
    */
  @scala.inline
  def FUNC_EQUAL: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FUNC_EQUAL").asInstanceOf[scala.Double]
  
  /**
    * Pass if (ref & mask) > (stencil & mask).
    */
  @scala.inline
  def FUNC_GREATER: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FUNC_GREATER").asInstanceOf[scala.Double]
  
  /**
    * Pass if (ref & mask) >= (stencil & mask).
    */
  @scala.inline
  def FUNC_GREATEREQUAL: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FUNC_GREATEREQUAL").asInstanceOf[scala.Double]
  
  /**
    * Pass if (ref & mask) < (stencil & mask).
    */
  @scala.inline
  def FUNC_LESS: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FUNC_LESS").asInstanceOf[scala.Double]
  
  /**
    * Pass if (ref & mask) <= (stencil & mask).
    */
  @scala.inline
  def FUNC_LESSEQUAL: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FUNC_LESSEQUAL").asInstanceOf[scala.Double]
  
  /**
    * Never pass.
    */
  @scala.inline
  def FUNC_NEVER: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FUNC_NEVER").asInstanceOf[scala.Double]
  
  /**
    * Pass if (ref & mask) != (stencil & mask).
    */
  @scala.inline
  def FUNC_NOTEQUAL: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FUNC_NOTEQUAL").asInstanceOf[scala.Double]
  
  /**
    * No gamma correction.
    */
  @scala.inline
  def GAMMA_NONE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("GAMMA_NONE").asInstanceOf[scala.Double]
  
  /**
    * Apply sRGB gamma correction.
    */
  @scala.inline
  def GAMMA_SRGB: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("GAMMA_SRGB").asInstanceOf[scala.Double]
  
  /**
    * Apply sRGB (fast) gamma correction.
    */
  @scala.inline
  def GAMMA_SRGBFAST: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("GAMMA_SRGBFAST").asInstanceOf[scala.Double]
  
  /**
    * Apply sRGB (HDR) gamma correction.
    */
  @scala.inline
  def GAMMA_SRGBHDR: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("GAMMA_SRGBHDR").asInstanceOf[scala.Double]
  
  /**
    * 16-bit unsigned vertex indices (0 to 65,535).
    */
  @scala.inline
  def INDEXFORMAT_UINT16: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("INDEXFORMAT_UINT16").asInstanceOf[scala.Double]
  
  /**
    * 32-bit unsigned vertex indices (0 to 4,294,967,295).
    */
  @scala.inline
  def INDEXFORMAT_UINT32: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("INDEXFORMAT_UINT32").asInstanceOf[scala.Double]
  
  /**
    * 8-bit unsigned vertex indices (0 to 255).
    */
  @scala.inline
  def INDEXFORMAT_UINT8: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("INDEXFORMAT_UINT8").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_0: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_0").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_1: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_1").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_2: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_2").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_3: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_3").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_4: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_4").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_5: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_5").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_6: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_6").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_7: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_7").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_8: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_8").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_9: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_9").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_A: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_A").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_ADD: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_ADD").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_ALT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_ALT").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_B: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_B").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_BACKSPACE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_BACKSPACE").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_BACK_SLASH: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_BACK_SLASH").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_C: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_C").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_CAPS_LOCK: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_CAPS_LOCK").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_CLOSE_BRACKET: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_CLOSE_BRACKET").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_COMMA: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_COMMA").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_CONTEXT_MENU: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_CONTEXT_MENU").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_CONTROL: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_CONTROL").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_D: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_D").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_DECIMAL: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_DECIMAL").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_DELETE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_DELETE").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_DIVIDE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_DIVIDE").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_DOWN: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_DOWN").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_E: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_E").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_END: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_END").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_ENTER: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_ENTER").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_EQUAL: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_EQUAL").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_ESCAPE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_ESCAPE").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_F: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_F1: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F1").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_F10: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F10").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_F11: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F11").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_F12: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F12").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_F2: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F2").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_F3: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F3").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_F4: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F4").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_F5: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F5").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_F6: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F6").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_F7: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F7").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_F8: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F8").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_F9: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F9").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_G: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_G").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_H: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_H").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_HOME: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_HOME").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_I: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_I").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_INSERT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_INSERT").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_J: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_J").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_K: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_K").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_L: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_L").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_LEFT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_LEFT").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_M: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_M").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_META: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_META").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_MULTIPLY: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_MULTIPLY").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_N: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_N").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_NUMPAD_0: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_0").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_NUMPAD_1: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_1").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_NUMPAD_2: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_2").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_NUMPAD_3: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_3").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_NUMPAD_4: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_4").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_NUMPAD_5: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_5").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_NUMPAD_6: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_6").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_NUMPAD_7: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_7").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_NUMPAD_8: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_8").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_NUMPAD_9: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_9").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_O: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_O").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_OPEN_BRACKET: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_OPEN_BRACKET").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_P: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_P").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_PAGE_DOWN: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_PAGE_DOWN").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_PAGE_UP: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_PAGE_UP").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_PAUSE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_PAUSE").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_PERIOD: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_PERIOD").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_PRINT_SCREEN: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_PRINT_SCREEN").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_Q: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_Q").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_R: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_R").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_RETURN: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_RETURN").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_RIGHT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_RIGHT").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_S: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_S").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_SEMICOLON: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_SEMICOLON").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_SEPARATOR: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_SEPARATOR").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_SHIFT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_SHIFT").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_SLASH: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_SLASH").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_SPACE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_SPACE").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_SUBTRACT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_SUBTRACT").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_T: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_T").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_TAB: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_TAB").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_U: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_U").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_UP: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_UP").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_V: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_V").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_W: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_W").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_WINDOWS: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_WINDOWS").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_X: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_X").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_Y: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_Y").asInstanceOf[scala.Double]
  
  @scala.inline
  def KEY_Z: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_Z").asInstanceOf[scala.Double]
  
  /**
    * The depth layer.
    */
  @scala.inline
  def LAYERID_DEPTH: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LAYERID_DEPTH").asInstanceOf[scala.Double]
  
  /**
    * The immediate layer.
    */
  @scala.inline
  def LAYERID_IMMEDIATE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LAYERID_IMMEDIATE").asInstanceOf[scala.Double]
  
  /**
    * The skybox layer.
    */
  @scala.inline
  def LAYERID_SKYBOX: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LAYERID_SKYBOX").asInstanceOf[scala.Double]
  
  /**
    * The UI layer.
    */
  @scala.inline
  def LAYERID_UI: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LAYERID_UI").asInstanceOf[scala.Double]
  
  /**
    * The world layer.
    */
  @scala.inline
  def LAYERID_WORLD: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LAYERID_WORLD").asInstanceOf[scala.Double]
  
  /**
    * Inverse squared distance falloff model for light attenuation.
    */
  @scala.inline
  def LIGHTFALLOFF_INVERSESQUARED: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LIGHTFALLOFF_INVERSESQUARED").asInstanceOf[scala.Double]
  
  /**
    * Linear distance falloff model for light attenuation.
    */
  @scala.inline
  def LIGHTFALLOFF_LINEAR: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LIGHTFALLOFF_LINEAR").asInstanceOf[scala.Double]
  
  /**
    * Directional (global) light source.
    */
  @scala.inline
  def LIGHTTYPE_DIRECTIONAL: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LIGHTTYPE_DIRECTIONAL").asInstanceOf[scala.Double]
  
  /**
    * Point (local) light source.
    */
  @scala.inline
  def LIGHTTYPE_POINT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LIGHTTYPE_POINT").asInstanceOf[scala.Double]
  
  /**
    * Spot (local) light source.
    */
  @scala.inline
  def LIGHTTYPE_SPOT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LIGHTTYPE_SPOT").asInstanceOf[scala.Double]
  
  /**
    * The left mouse button.
    */
  @scala.inline
  def MOUSEBUTTON_LEFT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("MOUSEBUTTON_LEFT").asInstanceOf[scala.Double]
  
  /**
    * The middle mouse button.
    */
  @scala.inline
  def MOUSEBUTTON_MIDDLE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("MOUSEBUTTON_MIDDLE").asInstanceOf[scala.Double]
  
  /**
    * No mouse buttons pressed.
    */
  @scala.inline
  def MOUSEBUTTON_NONE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("MOUSEBUTTON_NONE").asInstanceOf[scala.Double]
  
  /**
    * The right mouse button.
    */
  @scala.inline
  def MOUSEBUTTON_RIGHT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("MOUSEBUTTON_RIGHT").asInstanceOf[scala.Double]
  
  /**
    * Horizontal orientation.
    */
  @scala.inline
  def ORIENTATION_HORIZONTAL: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ORIENTATION_HORIZONTAL").asInstanceOf[scala.Double]
  
  /**
    * Vertical orientation.
    */
  @scala.inline
  def ORIENTATION_VERTICAL: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ORIENTATION_VERTICAL").asInstanceOf[scala.Double]
  
  /**
    * Index for pad 1.
    */
  @scala.inline
  def PAD_1: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_1").asInstanceOf[scala.Double]
  
  /**
    * Index for pad 2.
    */
  @scala.inline
  def PAD_2: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_2").asInstanceOf[scala.Double]
  
  /**
    * Index for pad 3.
    */
  @scala.inline
  def PAD_3: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_3").asInstanceOf[scala.Double]
  
  /**
    * Index for pad 4.
    */
  @scala.inline
  def PAD_4: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_4").asInstanceOf[scala.Double]
  
  /**
    * Direction pad down.
    */
  @scala.inline
  def PAD_DOWN: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_DOWN").asInstanceOf[scala.Double]
  
  /**
    * The first face button, from bottom going clockwise.
    */
  @scala.inline
  def PAD_FACE_1: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_FACE_1").asInstanceOf[scala.Double]
  
  /**
    * The second face button, from bottom going clockwise.
    */
  @scala.inline
  def PAD_FACE_2: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_FACE_2").asInstanceOf[scala.Double]
  
  /**
    * The third face button, from bottom going clockwise.
    */
  @scala.inline
  def PAD_FACE_3: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_FACE_3").asInstanceOf[scala.Double]
  
  /**
    * The fourth face button, from bottom going clockwise.
    */
  @scala.inline
  def PAD_FACE_4: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_FACE_4").asInstanceOf[scala.Double]
  
  /**
    * Direction pad left.
    */
  @scala.inline
  def PAD_LEFT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_LEFT").asInstanceOf[scala.Double]
  
  /**
    * The first shoulder button on the left.
    */
  @scala.inline
  def PAD_L_SHOULDER_1: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_L_SHOULDER_1").asInstanceOf[scala.Double]
  
  /**
    * The second shoulder button on the left.
    */
  @scala.inline
  def PAD_L_SHOULDER_2: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_L_SHOULDER_2").asInstanceOf[scala.Double]
  
  /**
    * The button when depressing the left analogue stick.
    */
  @scala.inline
  def PAD_L_STICK_BUTTON: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_L_STICK_BUTTON").asInstanceOf[scala.Double]
  
  /**
    * Horizontal axis on the left analogue stick.
    */
  @scala.inline
  def PAD_L_STICK_X: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_L_STICK_X").asInstanceOf[scala.Double]
  
  /**
    * Vertical axis on the left analogue stick.
    */
  @scala.inline
  def PAD_L_STICK_Y: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_L_STICK_Y").asInstanceOf[scala.Double]
  
  /**
    * Direction pad right.
    */
  @scala.inline
  def PAD_RIGHT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_RIGHT").asInstanceOf[scala.Double]
  
  /**
    * The first shoulder button on the right.
    */
  @scala.inline
  def PAD_R_SHOULDER_1: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_R_SHOULDER_1").asInstanceOf[scala.Double]
  
  /**
    * The second shoulder button on the right.
    */
  @scala.inline
  def PAD_R_SHOULDER_2: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_R_SHOULDER_2").asInstanceOf[scala.Double]
  
  /**
    * The button when depressing the right analogue stick.
    */
  @scala.inline
  def PAD_R_STICK_BUTTON: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_R_STICK_BUTTON").asInstanceOf[scala.Double]
  
  /**
    * Horizontal axis on the right analogue stick.
    */
  @scala.inline
  def PAD_R_STICK_X: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_R_STICK_X").asInstanceOf[scala.Double]
  
  /**
    * Vertical axis on the right analogue stick.
    */
  @scala.inline
  def PAD_R_STICK_Y: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_R_STICK_Y").asInstanceOf[scala.Double]
  
  /**
    * The select button.
    */
  @scala.inline
  def PAD_SELECT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_SELECT").asInstanceOf[scala.Double]
  
  /**
    * The start button.
    */
  @scala.inline
  def PAD_START: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_START").asInstanceOf[scala.Double]
  
  /**
    * Direction pad up.
    */
  @scala.inline
  def PAD_UP: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_UP").asInstanceOf[scala.Double]
  
  /**
    * Vendor specific button.
    */
  @scala.inline
  def PAD_VENDOR: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_VENDOR").asInstanceOf[scala.Double]
  
  /**
    * Similar to previous, but the normal is affected by emitter(entity) transformation.
    */
  @scala.inline
  def PARTICLEORIENTATION_EMITTER: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PARTICLEORIENTATION_EMITTER").asInstanceOf[scala.Double]
  
  /**
    * Particles are facing camera.
    */
  @scala.inline
  def PARTICLEORIENTATION_SCREEN: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PARTICLEORIENTATION_SCREEN").asInstanceOf[scala.Double]
  
  /**
    * User defines world space normal (particleNormal) to set planes orientation.
    */
  @scala.inline
  def PARTICLEORIENTATION_WORLD: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PARTICLEORIENTATION_WORLD").asInstanceOf[scala.Double]
  
  /**
    * Sorting based on distance to the camera. CPU only.
    */
  @scala.inline
  def PARTICLESORT_DISTANCE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PARTICLESORT_DISTANCE").asInstanceOf[scala.Double]
  
  /**
    * Newer particles are drawn first. CPU only.
    */
  @scala.inline
  def PARTICLESORT_NEWER_FIRST: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PARTICLESORT_NEWER_FIRST").asInstanceOf[scala.Double]
  
  /**
    * No sorting, particles are drawn in arbitrary order. Can be simulated on GPU.
    */
  @scala.inline
  def PARTICLESORT_NONE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PARTICLESORT_NONE").asInstanceOf[scala.Double]
  
  /**
    * Older particles are drawn first. CPU only.
    */
  @scala.inline
  def PARTICLESORT_OLDER_FIRST: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PARTICLESORT_OLDER_FIRST").asInstanceOf[scala.Double]
  
  /**
    * ATC compressed format with alpha channel in blocks of 4x4.
    */
  @scala.inline
  def PIXELFORMATASTC4x4: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_ASTC_4x4").asInstanceOf[scala.Double]
  
  /**
    * A floating-point color-only format with 11 bits for red and green channels and 10 bits for the blue channel (WebGL2 only).
    */
  @scala.inline
  def PIXELFORMAT_111110F: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_111110F").asInstanceOf[scala.Double]
  
  /**
    * 8-bit alpha.
    */
  @scala.inline
  def PIXELFORMAT_A8: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_A8").asInstanceOf[scala.Double]
  
  /**
    * ATC compressed format with no alpha channel.
    */
  @scala.inline
  def PIXELFORMAT_ATC_RGB: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_ATC_RGB").asInstanceOf[scala.Double]
  
  /**
    * ATC compressed format with alpha channel.
    */
  @scala.inline
  def PIXELFORMAT_ATC_RGBA: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_ATC_RGBA").asInstanceOf[scala.Double]
  
  /**
    * A readable depth buffer format.
    */
  @scala.inline
  def PIXELFORMAT_DEPTH: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_DEPTH").asInstanceOf[scala.Double]
  
  /**
    * A readable depth/stencil buffer format (WebGL2 only).
    */
  @scala.inline
  def PIXELFORMAT_DEPTHSTENCIL: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_DEPTHSTENCIL").asInstanceOf[scala.Double]
  
  /**
    * Block compressed format storing 16 input pixels in 64 bits of output, consisting of two 16-bit RGB 5:6:5 color values and a 4x4 two bit lookup table.
    */
  @scala.inline
  def PIXELFORMAT_DXT1: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_DXT1").asInstanceOf[scala.Double]
  
  /**
    * Block compressed format storing 16 input pixels (corresponding to a 4x4 pixel block) into 128 bits of output, consisting of 64 bits of alpha channel data (4 bits for each pixel) followed by 64 bits of color data; encoded the same way as DXT1.
    */
  @scala.inline
  def PIXELFORMAT_DXT3: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_DXT3").asInstanceOf[scala.Double]
  
  /**
    * Block compressed format storing 16 input pixels into 128 bits of output, consisting of 64 bits of alpha channel data (two 8 bit alpha values and a 4x4 3 bit lookup table) followed by 64 bits of color data (encoded the same way as DXT1).
    */
  @scala.inline
  def PIXELFORMAT_DXT5: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_DXT5").asInstanceOf[scala.Double]
  
  /**
    * ETC1 compressed format.
    */
  @scala.inline
  def PIXELFORMAT_ETC1: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_ETC1").asInstanceOf[scala.Double]
  
  /**
    * ETC2 (RGB) compressed format.
    */
  @scala.inline
  def PIXELFORMAT_ETC2_RGB: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_ETC2_RGB").asInstanceOf[scala.Double]
  
  /**
    * ETC2 (RGBA) compressed format.
    */
  @scala.inline
  def PIXELFORMAT_ETC2_RGBA: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_ETC2_RGBA").asInstanceOf[scala.Double]
  
  /**
    * 8-bit luminance.
    */
  @scala.inline
  def PIXELFORMAT_L8: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_L8").asInstanceOf[scala.Double]
  
  /**
    * 8-bit luminance with 8-bit alpha.
    */
  @scala.inline
  def PIXELFORMAT_L8_A8: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_L8_A8").asInstanceOf[scala.Double]
  
  /**
    * PVRTC (2BPP RGBA) compressed format.
    */
  @scala.inline
  def PIXELFORMAT_PVRTC_2BPP_RGBA_1: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_PVRTC_2BPP_RGBA_1").asInstanceOf[scala.Double]
  
  /**
    * PVRTC (2BPP RGB) compressed format.
    */
  @scala.inline
  def PIXELFORMAT_PVRTC_2BPP_RGB_1: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_PVRTC_2BPP_RGB_1").asInstanceOf[scala.Double]
  
  /**
    * PVRTC (4BPP RGBA) compressed format.
    */
  @scala.inline
  def PIXELFORMAT_PVRTC_4BPP_RGBA_1: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_PVRTC_4BPP_RGBA_1").asInstanceOf[scala.Double]
  
  /**
    * PVRTC (4BPP RGB) compressed format.
    */
  @scala.inline
  def PIXELFORMAT_PVRTC_4BPP_RGB_1: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_PVRTC_4BPP_RGB_1").asInstanceOf[scala.Double]
  
  /**
    * 32-bit floating point single channel format (WebGL2 only).
    */
  @scala.inline
  def PIXELFORMAT_R32F: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_R32F").asInstanceOf[scala.Double]
  
  /**
    * 16-bit RGBA (4-bits for red channel, 4 for green, 4 for blue with 4-bit alpha).
    */
  @scala.inline
  def PIXELFORMAT_R4_G4_B4_A4: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_R4_G4_B4_A4").asInstanceOf[scala.Double]
  
  /**
    * 16-bit RGBA (5-bits for red channel, 5 for green, 5 for blue with 1-bit alpha).
    */
  @scala.inline
  def PIXELFORMAT_R5_G5_B5_A1: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_R5_G5_B5_A1").asInstanceOf[scala.Double]
  
  /**
    * 16-bit RGB (5-bits for red channel, 6 for green and 5 for blue).
    */
  @scala.inline
  def PIXELFORMAT_R5_G6_B5: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_R5_G6_B5").asInstanceOf[scala.Double]
  
  /**
    * 24-bit RGB (8-bits for red channel, 8 for green and 8 for blue).
    */
  @scala.inline
  def PIXELFORMAT_R8_G8_B8: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_R8_G8_B8").asInstanceOf[scala.Double]
  
  /**
    * 32-bit RGBA (8-bits for red channel, 8 for green, 8 for blue with 8-bit alpha).
    */
  @scala.inline
  def PIXELFORMAT_R8_G8_B8_A8: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_R8_G8_B8_A8").asInstanceOf[scala.Double]
  
  /**
    * 16-bit floating point RGB (16-bit float for each red, green and blue channels).
    */
  @scala.inline
  def PIXELFORMAT_RGB16F: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_RGB16F").asInstanceOf[scala.Double]
  
  /**
    * 32-bit floating point RGB (32-bit float for each red, green and blue channels).
    */
  @scala.inline
  def PIXELFORMAT_RGB32F: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_RGB32F").asInstanceOf[scala.Double]
  
  /**
    * 16-bit floating point RGBA (16-bit float for each red, green, blue and alpha channels).
    */
  @scala.inline
  def PIXELFORMAT_RGBA16F: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_RGBA16F").asInstanceOf[scala.Double]
  
  /**
    * 32-bit floating point RGBA (32-bit float for each red, green, blue and alpha channels).
    */
  @scala.inline
  def PIXELFORMAT_RGBA32F: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_RGBA32F").asInstanceOf[scala.Double]
  
  /**
    * Color-only sRGB format (WebGL2 only).
    */
  @scala.inline
  def PIXELFORMAT_SRGB: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_SRGB").asInstanceOf[scala.Double]
  
  /**
    * Color sRGB format with additional alpha channel (WebGL2 only).
    */
  @scala.inline
  def PIXELFORMAT_SRGBA: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_SRGBA").asInstanceOf[scala.Double]
  
  /**
    * List of points that are linked sequentially by line segments, with a closing line segment between the last and first points.
    */
  @scala.inline
  def PRIMITIVE_LINELOOP: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PRIMITIVE_LINELOOP").asInstanceOf[scala.Double]
  
  /**
    * Discrete list of line segments.
    */
  @scala.inline
  def PRIMITIVE_LINES: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PRIMITIVE_LINES").asInstanceOf[scala.Double]
  
  /**
    * List of points that are linked sequentially by line segments.
    */
  @scala.inline
  def PRIMITIVE_LINESTRIP: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PRIMITIVE_LINESTRIP").asInstanceOf[scala.Double]
  
  /**
    * List of distinct points.
    */
  @scala.inline
  def PRIMITIVE_POINTS: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PRIMITIVE_POINTS").asInstanceOf[scala.Double]
  
  /**
    * Discrete list of triangles.
    */
  @scala.inline
  def PRIMITIVE_TRIANGLES: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PRIMITIVE_TRIANGLES").asInstanceOf[scala.Double]
  
  /**
    * Connected fan of triangles where the first vertex forms triangles with the following pairs of vertices.
    */
  @scala.inline
  def PRIMITIVE_TRIFAN: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PRIMITIVE_TRIFAN").asInstanceOf[scala.Double]
  
  /**
    * Connected strip of triangles where a specified vertex forms a triangle using the previous two.
    */
  @scala.inline
  def PRIMITIVE_TRISTRIP: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PRIMITIVE_TRISTRIP").asInstanceOf[scala.Double]
  
  /**
    * An orthographic camera projection where the frustum shape is essentially a cuboid.
    */
  @scala.inline
  def PROJECTION_ORTHOGRAPHIC: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PROJECTION_ORTHOGRAPHIC").asInstanceOf[scala.Double]
  
  /**
    * A perspective camera projection where the frustum shape is essentially pyramidal.
    */
  @scala.inline
  def PROJECTION_PERSPECTIVE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PROJECTION_PERSPECTIVE").asInstanceOf[scala.Double]
  
  /**
    * Render mesh instance as points.
    */
  @scala.inline
  def RENDERSTYLE_POINTS: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("RENDERSTYLE_POINTS").asInstanceOf[scala.Double]
  
  /**
    * Render mesh instance as solid geometry.
    */
  @scala.inline
  def RENDERSTYLE_SOLID: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("RENDERSTYLE_SOLID").asInstanceOf[scala.Double]
  
  /**
    * Render mesh instance as wireframe.
    */
  @scala.inline
  def RENDERSTYLE_WIREFRAME: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("RENDERSTYLE_WIREFRAME").asInstanceOf[scala.Double]
  
  /**
    * When the canvas is resized the resolution of the canvas will change to match the size of the canvas.
    */
  @scala.inline
  def RESOLUTION_AUTO: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("RESOLUTION_AUTO").asInstanceOf[java.lang.String]
  
  /**
    * When the canvas is resized the resolution of the canvas will remain at the same value and the output will just be scaled to fit the canvas.
    */
  @scala.inline
  def RESOLUTION_FIXED: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("RESOLUTION_FIXED").asInstanceOf[java.lang.String]
  
  /**
    * Scale the {@link pc.ScreenComponent} when the application's resolution is different than the ScreenComponent's referenceResolution.
    */
  @scala.inline
  def SCALEMODE_BLEND: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SCALEMODE_BLEND").asInstanceOf[java.lang.String]
  
  /**
    * Always use the application's resolution as the resolution for the {@link pc.ScreenComponent}.
    */
  @scala.inline
  def SCALEMODE_NONE: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SCALEMODE_NONE").asInstanceOf[java.lang.String]
  
  /**
    * The scrollbar will be visible all the time.
    */
  @scala.inline
  def SCROLLBAR_VISIBILITY_SHOW_ALWAYS: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SCROLLBAR_VISIBILITY_SHOW_ALWAYS").asInstanceOf[scala.Double]
  
  /**
    * The scrollbar will be visible only when content exceeds the size of the viewport.
    */
  @scala.inline
  def SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED").asInstanceOf[scala.Double]
  
  /**
    * Content scrolls past its bounds and then gently bounces back.
    */
  @scala.inline
  def SCROLL_MODE_BOUNCE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SCROLL_MODE_BOUNCE").asInstanceOf[scala.Double]
  
  /**
    * Content does not scroll any further than its bounds.
    */
  @scala.inline
  def SCROLL_MODE_CLAMP: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SCROLL_MODE_CLAMP").asInstanceOf[scala.Double]
  
  /**
    * Content can scroll forever.
    */
  @scala.inline
  def SCROLL_MODE_INFINITE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SCROLL_MODE_INFINITE").asInstanceOf[scala.Double]
  
  /**
    * Vertex attribute with a user defined semantic.
    */
  @scala.inline
  def SEMANTIC_ATTR0: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR0").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute with a user defined semantic.
    */
  @scala.inline
  def SEMANTIC_ATTR1: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR1").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute with a user defined semantic.
    */
  @scala.inline
  def SEMANTIC_ATTR10: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR10").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute with a user defined semantic.
    */
  @scala.inline
  def SEMANTIC_ATTR11: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR11").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute with a user defined semantic.
    */
  @scala.inline
  def SEMANTIC_ATTR12: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR12").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute with a user defined semantic.
    */
  @scala.inline
  def SEMANTIC_ATTR13: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR13").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute with a user defined semantic.
    */
  @scala.inline
  def SEMANTIC_ATTR14: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR14").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute with a user defined semantic.
    */
  @scala.inline
  def SEMANTIC_ATTR15: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR15").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute with a user defined semantic.
    */
  @scala.inline
  def SEMANTIC_ATTR2: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR2").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute with a user defined semantic.
    */
  @scala.inline
  def SEMANTIC_ATTR3: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR3").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute with a user defined semantic.
    */
  @scala.inline
  def SEMANTIC_ATTR4: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR4").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute with a user defined semantic.
    */
  @scala.inline
  def SEMANTIC_ATTR5: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR5").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute with a user defined semantic.
    */
  @scala.inline
  def SEMANTIC_ATTR6: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR6").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute with a user defined semantic.
    */
  @scala.inline
  def SEMANTIC_ATTR7: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR7").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute with a user defined semantic.
    */
  @scala.inline
  def SEMANTIC_ATTR8: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR8").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute with a user defined semantic.
    */
  @scala.inline
  def SEMANTIC_ATTR9: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR9").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute to be treated as skin blend indices.
    */
  @scala.inline
  def SEMANTIC_BLENDINDICES: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_BLENDINDICES").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute to be treated as skin blend weights.
    */
  @scala.inline
  def SEMANTIC_BLENDWEIGHT: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_BLENDWEIGHT").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute to be treated as a color.
    */
  @scala.inline
  def SEMANTIC_COLOR: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_COLOR").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute to be treated as a normal.
    */
  @scala.inline
  def SEMANTIC_NORMAL: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_NORMAL").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute to be treated as a position.
    */
  @scala.inline
  def SEMANTIC_POSITION: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_POSITION").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute to be treated as a tangent.
    */
  @scala.inline
  def SEMANTIC_TANGENT: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_TANGENT").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute to be treated as a texture coordinate (set 0).
    */
  @scala.inline
  def SEMANTIC_TEXCOORD0: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_TEXCOORD0").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute to be treated as a texture coordinate (set 1).
    */
  @scala.inline
  def SEMANTIC_TEXCOORD1: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_TEXCOORD1").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute to be treated as a texture coordinate (set 2).
    */
  @scala.inline
  def SEMANTIC_TEXCOORD2: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_TEXCOORD2").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute to be treated as a texture coordinate (set 3).
    */
  @scala.inline
  def SEMANTIC_TEXCOORD3: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_TEXCOORD3").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute to be treated as a texture coordinate (set 4).
    */
  @scala.inline
  def SEMANTIC_TEXCOORD4: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_TEXCOORD4").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute to be treated as a texture coordinate (set 5).
    */
  @scala.inline
  def SEMANTIC_TEXCOORD5: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_TEXCOORD5").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute to be treated as a texture coordinate (set 6).
    */
  @scala.inline
  def SEMANTIC_TEXCOORD6: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_TEXCOORD6").asInstanceOf[java.lang.String]
  
  /**
    * Vertex attribute to be treated as a texture coordinate (set 7).
    */
  @scala.inline
  def SEMANTIC_TEXCOORD7: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_TEXCOORD7").asInstanceOf[java.lang.String]
  
  /**
    * Render RGBA-encoded depth value.
    */
  @scala.inline
  def SHADER_DEPTH: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADER_DEPTH").asInstanceOf[scala.Double]
  
  /**
    * Render shaded materials with gamma correction and tonemapping.
    */
  @scala.inline
  def SHADER_FORWARD: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADER_FORWARD").asInstanceOf[scala.Double]
  
  /**
    * Render shaded materials without gamma correction and tonemapping.
    */
  @scala.inline
  def SHADER_FORWARDHDR: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADER_FORWARDHDR").asInstanceOf[scala.Double]
  
  /**
    * The shadow map is not to be updated.
    */
  @scala.inline
  def SHADOWUPDATE_NONE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADOWUPDATE_NONE").asInstanceOf[scala.Double]
  
  /**
    * The shadow map is regenerated every frame.
    */
  @scala.inline
  def SHADOWUPDATE_REALTIME: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADOWUPDATE_REALTIME").asInstanceOf[scala.Double]
  
  /**
    * The shadow map is regenerated this frame and not on subsequent frames.
    */
  @scala.inline
  def SHADOWUPDATE_THISFRAME: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADOWUPDATE_THISFRAME").asInstanceOf[scala.Double]
  
  /**
    * Render depth (color-packed on WebGL 1.0), can be used for PCF 3x3 sampling.
    */
  @scala.inline
  def SHADOW_PCF3: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADOW_PCF3").asInstanceOf[scala.Double]
  
  /**
    * Render depth buffer only, can be used for hardware-accelerated PCF 5x5 sampling. Requires WebGL2. Falls back to pc.SHADOW_PCF3 on WebGL 1.0.
    */
  @scala.inline
  def SHADOW_PCF5: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADOW_PCF5").asInstanceOf[scala.Double]
  
  /**
    * Render 16-bit exponential variance shadow map. Requires OES_texture_half_float extension. Falls back to pc.SHADOW_VSM8, if not supported.
    */
  @scala.inline
  def SHADOW_VSM16: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADOW_VSM16").asInstanceOf[scala.Double]
  
  /**
    * Render 32-bit exponential variance shadow map. Requires OES_texture_float extension. Falls back to pc.SHADOW_VSM16, if not supported.
    */
  @scala.inline
  def SHADOW_VSM32: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADOW_VSM32").asInstanceOf[scala.Double]
  
  /**
    * Render packed variance shadow map. All shadow receivers must also cast shadows for this mode to work correctly.
    */
  @scala.inline
  def SHADOW_VSM8: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADOW_VSM8").asInstanceOf[scala.Double]
  
  /**
    * Mesh instances are sorted back to front. This is the way to properly render many semi-transparent objects on different depth, one is blended on top of another.
    */
  @scala.inline
  def SORTMODE_BACK2FRONT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SORTMODE_BACK2FRONT").asInstanceOf[scala.Double]
  
  /**
    * Mesh instances are sorted front to back. Depending on GPU and the scene, this option may give better performance than pc.SORTMODE_MATERIALMESH due to reduced overdraw.
    */
  @scala.inline
  def SORTMODE_FRONT2BACK: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SORTMODE_FRONT2BACK").asInstanceOf[scala.Double]
  
  /**
    * Mesh instances are sorted based on {@link pc.MeshInstance#drawOrder}.
    */
  @scala.inline
  def SORTMODE_MANUAL: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SORTMODE_MANUAL").asInstanceOf[scala.Double]
  
  /**
    * Mesh instances are sorted to minimize switching between materials and meshes to improve rendering performance.
    */
  @scala.inline
  def SORTMODE_MATERIALMESH: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SORTMODE_MATERIALMESH").asInstanceOf[scala.Double]
  
  /**
    * No sorting is applied. Mesh instances are rendered in the same order they were added to a layer.
    */
  @scala.inline
  def SORTMODE_NONE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SORTMODE_NONE").asInstanceOf[scala.Double]
  
  /**
    * Use AO directly to occlude specular.
    */
  @scala.inline
  def SPECOCC_AO: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPECOCC_AO").asInstanceOf[scala.Double]
  
  /**
    * Modify AO based on material glossiness/view angle to occlude specular.
    */
  @scala.inline
  def SPECOCC_GLOSSDEPENDENT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPECOCC_GLOSSDEPENDENT").asInstanceOf[scala.Double]
  
  /**
    * No specular occlusion.
    */
  @scala.inline
  def SPECOCC_NONE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPECOCC_NONE").asInstanceOf[scala.Double]
  
  /**
    * Energy-conserving Blinn-Phong.
    */
  @scala.inline
  def SPECULAR_BLINN: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPECULAR_BLINN").asInstanceOf[scala.Double]
  
  /**
    * Phong without energy conservation. You should only use it as a backwards compatibility with older projects.
    */
  @scala.inline
  def SPECULAR_PHONG: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPECULAR_PHONG").asInstanceOf[scala.Double]
  
  /**
    * A {@link pc.SpriteComponent} that renders sprite animations.
    */
  @scala.inline
  def SPRITETYPE_ANIMATED: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPRITETYPE_ANIMATED").asInstanceOf[java.lang.String]
  
  /**
    * A {@link pc.SpriteComponent} that displays a single frame from a sprite asset.
    */
  @scala.inline
  def SPRITETYPE_SIMPLE: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPRITETYPE_SIMPLE").asInstanceOf[java.lang.String]
  
  /**
    * This mode renders a sprite as a simple quad.
    */
  @scala.inline
  def SPRITE_RENDERMODE_SIMPLE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPRITE_RENDERMODE_SIMPLE").asInstanceOf[scala.Double]
  
  /**
    * This mode renders a sprite using 9-slicing in 'sliced' mode. Sliced mode stretches the
    * top and bottom regions of the sprite horizontally, the left and right regions vertically and the middle region
    * both horizontally and vertically.
    */
  @scala.inline
  def SPRITE_RENDERMODE_SLICED: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPRITE_RENDERMODE_SLICED").asInstanceOf[scala.Double]
  
  /**
    * This mode renders a sprite using 9-slicing in 'tiled' mode. Tiled mode tiles the
    * top and bottom regions of the sprite horizontally, the left and right regions vertically and the middle region
    * both horizontally and vertically.
    */
  @scala.inline
  def SPRITE_RENDERMODE_TILED: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPRITE_RENDERMODE_TILED").asInstanceOf[scala.Double]
  
  /**
    * Decrement the value.
    */
  @scala.inline
  def STENCILOP_DECREMENT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("STENCILOP_DECREMENT").asInstanceOf[scala.Double]
  
  /**
    * Decrement the value but wrap it to a maximum representable value if the current value is 0.
    */
  @scala.inline
  def STENCILOP_DECREMENTWRAP: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("STENCILOP_DECREMENTWRAP").asInstanceOf[scala.Double]
  
  /**
    * Increment the value.
    */
  @scala.inline
  def STENCILOP_INCREMENT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("STENCILOP_INCREMENT").asInstanceOf[scala.Double]
  
  /**
    * Increment the value but wrap it to zero when it's larger than a maximum representable value.
    */
  @scala.inline
  def STENCILOP_INCREMENTWRAP: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("STENCILOP_INCREMENTWRAP").asInstanceOf[scala.Double]
  
  /**
    * Invert the value bitwise.
    */
  @scala.inline
  def STENCILOP_INVERT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("STENCILOP_INVERT").asInstanceOf[scala.Double]
  
  /**
    * Don't change the stencil buffer value.
    */
  @scala.inline
  def STENCILOP_KEEP: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("STENCILOP_KEEP").asInstanceOf[scala.Double]
  
  /**
    * Replace value with the reference value (see {@link pc.GraphicsDevice#setStencilFunc}).
    */
  @scala.inline
  def STENCILOP_REPLACE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("STENCILOP_REPLACE").asInstanceOf[scala.Double]
  
  /**
    * Set value to zero.
    */
  @scala.inline
  def STENCILOP_ZERO: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("STENCILOP_ZERO").asInstanceOf[scala.Double]
  
  /**
    * Read only. Any changes to the locked mip level's pixels will not update the texture.
    */
  @scala.inline
  def TEXTURELOCK_READ: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TEXTURELOCK_READ").asInstanceOf[scala.Double]
  
  /**
    * Write only. The contents of the specified mip level will be entirely replaced.
    */
  @scala.inline
  def TEXTURELOCK_WRITE: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TEXTURELOCK_WRITE").asInstanceOf[scala.Double]
  
  /**
    * Texture is a default type.
    */
  @scala.inline
  def TEXTURETYPE_DEFAULT: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TEXTURETYPE_DEFAULT").asInstanceOf[java.lang.String]
  
  /**
    * Texture stores high dynamic range data in RGBE format
    */
  @scala.inline
  def TEXTURETYPE_RGBE: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TEXTURETYPE_RGBE").asInstanceOf[java.lang.String]
  
  /**
    * Texture stores high dynamic range data in RGBM format
    */
  @scala.inline
  def TEXTURETYPE_RGBM: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TEXTURETYPE_RGBM").asInstanceOf[java.lang.String]
  
  /**
    * Texture stores normalmap data swizzled in GGGR format. This is used for tangent space normal
    * maps. The R component is stored in alpha and G is stored in RGB. This packing can result in higher quality
    * when the texture data is compressed.
    */
  @scala.inline
  def TEXTURETYPE_SWIZZLEGGGR: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TEXTURETYPE_SWIZZLEGGGR").asInstanceOf[java.lang.String]
  
  /**
    * ACES filmic tonemapping curve.
    */
  @scala.inline
  def TONEMAP_ACES: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TONEMAP_ACES").asInstanceOf[scala.Double]
  
  /**
    * ACES v2 filmic tonemapping curve.
    */
  @scala.inline
  def TONEMAP_ACES2: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TONEMAP_ACES2").asInstanceOf[scala.Double]
  
  /**
    * Filmic tonemapping curve.
    */
  @scala.inline
  def TONEMAP_FILMIC: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TONEMAP_FILMIC").asInstanceOf[scala.Double]
  
  /**
    * Hejl filmic tonemapping curve.
    */
  @scala.inline
  def TONEMAP_HEJL: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TONEMAP_HEJL").asInstanceOf[scala.Double]
  
  /**
    * Linear tonemapping.
    */
  @scala.inline
  def TONEMAP_LINEAR: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TONEMAP_LINEAR").asInstanceOf[scala.Double]
  
  /**
    * Floating point vertex element type.
    */
  @scala.inline
  def TYPE_FLOAT32: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TYPE_FLOAT32").asInstanceOf[scala.Double]
  
  /**
    * Signed short vertex element type.
    */
  @scala.inline
  def TYPE_INT16: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TYPE_INT16").asInstanceOf[scala.Double]
  
  /**
    * Signed integer vertex element type.
    */
  @scala.inline
  def TYPE_INT32: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TYPE_INT32").asInstanceOf[scala.Double]
  
  /**
    * Signed byte vertex element type.
    */
  @scala.inline
  def TYPE_INT8: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TYPE_INT8").asInstanceOf[scala.Double]
  
  /**
    * Unsigned short vertex element type.
    */
  @scala.inline
  def TYPE_UINT16: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TYPE_UINT16").asInstanceOf[scala.Double]
  
  /**
    * Unsigned integer vertex element type.
    */
  @scala.inline
  def TYPE_UINT32: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TYPE_UINT32").asInstanceOf[scala.Double]
  
  /**
    * Unsigned byte vertex element type.
    */
  @scala.inline
  def TYPE_UINT8: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TYPE_UINT8").asInstanceOf[scala.Double]
  
  /**
    * Center of view.
    */
  @scala.inline
  def VIEW_CENTER: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("VIEW_CENTER").asInstanceOf[scala.Double]
  
  /**
    * Left of view. Only used in stereo rendering.
    */
  @scala.inline
  def VIEW_LEFT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("VIEW_LEFT").asInstanceOf[scala.Double]
  
  /**
    * Right of view. Only used in stereo rendering.
    */
  @scala.inline
  def VIEW_RIGHT: scala.Double = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("VIEW_RIGHT").asInstanceOf[scala.Double]
  
  /**
    * Left - indicates that input source is meant to be held in left hand.
    */
  @scala.inline
  def XRHAND_LEFT: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRHAND_LEFT").asInstanceOf[java.lang.String]
  
  /**
    * None - input source is not meant to be held in hands.
    */
  @scala.inline
  def XRHAND_NONE: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRHAND_NONE").asInstanceOf[java.lang.String]
  
  /**
    * Right - indicates that input source is meant to be held in right hand.
    */
  @scala.inline
  def XRHAND_RIGHT: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRHAND_RIGHT").asInstanceOf[java.lang.String]
  
  /**
    * Bounded Floor - represents a tracking space with its native origin at the floor, where the user
    * is expected to move within a pre-established boundary. Tracking in a bounded-floor reference space is optimized
    * for keeping the native origin and bounds geometry stable relative to the user’s environment.
    */
  @scala.inline
  def XRSPACE_BOUNDEDFLOOR: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRSPACE_BOUNDEDFLOOR").asInstanceOf[java.lang.String]
  
  /**
    * Local - represents a tracking space with a native origin near the viewer at the time of creation.
    * The exact position and orientation will be initialized based on the conventions of the underlying platform.
    * When using this reference space the user is not expected to move beyond their initial position much, if at all,
    * and tracking is optimized for that purpose. For devices with 6DoF tracking, local reference spaces should
    * emphasize keeping the origin stable relative to the user’s environment.
    */
  @scala.inline
  def XRSPACE_LOCAL: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRSPACE_LOCAL").asInstanceOf[java.lang.String]
  
  /**
    * Local Floor - represents a tracking space with a native origin at the floor in a safe position for
    * the user to stand. The y axis equals 0 at floor level, with the x and z position and orientation initialized
    * based on the conventions of the underlying platform. Floor level value might be estimated by the underlying
    * platform. When using this reference space, the user is not expected to move beyond their initial position much,
    * if at all, and tracking is optimized for that purpose. For devices with 6DoF tracking, local-floor reference
    * spaces should emphasize keeping the origin stable relative to the user’s environment.
    */
  @scala.inline
  def XRSPACE_LOCALFLOOR: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRSPACE_LOCALFLOOR").asInstanceOf[java.lang.String]
  
  /**
    * Unbounded - represents a tracking space where the user is expected to move freely around their
    * environment, potentially even long distances from their starting point. Tracking in an unbounded reference space
    * is optimized for stability around the user’s current position, and as such the native origin may drift over time.
    */
  @scala.inline
  def XRSPACE_UNBOUNDED: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRSPACE_UNBOUNDED").asInstanceOf[java.lang.String]
  
  /**
    * Viewer - always supported space with some basic tracking capabilities.
    */
  @scala.inline
  def XRSPACE_VIEWER: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRSPACE_VIEWER").asInstanceOf[java.lang.String]
  
  /**
    * Gaze - indicates the target ray will originate at the viewer and follow the direction it is facing. (This is commonly referred to as a "gaze input" device in the context of head-mounted displays.)
    */
  @scala.inline
  def XRTARGETRAY_GAZE: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRTARGETRAY_GAZE").asInstanceOf[java.lang.String]
  
  /**
    * Tracked Pointer - indicates that the target ray originates from either a handheld device or other hand-tracking mechanism and represents that the user is using their hands or the held device for pointing.
    */
  @scala.inline
  def XRTARGETRAY_POINTER: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRTARGETRAY_POINTER").asInstanceOf[java.lang.String]
  
  /**
    * Screen - indicates that the input source was an interaction with the canvas element associated with an inline session’s output context, such as a mouse click or touch event.
    */
  @scala.inline
  def XRTARGETRAY_SCREEN: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRTARGETRAY_SCREEN").asInstanceOf[java.lang.String]
  
  /**
    * Mesh - indicates that the hit test results will be computed based on the meshes detected by the underlying Augmented Reality system.
    */
  @scala.inline
  def XRTRACKABLE_MESH: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRTRACKABLE_MESH").asInstanceOf[java.lang.String]
  
  /**
    * Plane - indicates that the hit test results will be computed based on the planes detected by the underlying Augmented Reality system.
    */
  @scala.inline
  def XRTRACKABLE_PLANE: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRTRACKABLE_PLANE").asInstanceOf[java.lang.String]
  
  /**
    * Point - indicates that the hit test results will be computed based on the feature points detected by the underlying Augmented Reality system.
    */
  @scala.inline
  def XRTRACKABLE_POINT: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRTRACKABLE_POINT").asInstanceOf[java.lang.String]
  
  /**
    * Immersive AR - session that provides exclusive access to VR/AR device that is intended to be blended
    * with real-world environment.
    */
  @scala.inline
  def XRTYPE_AR: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRTYPE_AR").asInstanceOf[java.lang.String]
  
  /**
    * Inline - always available type of session. It has limited features availability and is rendered
    * into HTML element.
    */
  @scala.inline
  def XRTYPE_INLINE: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRTYPE_INLINE").asInstanceOf[java.lang.String]
  
  /**
    * Immersive VR - session that provides exclusive access to VR device with best available tracking
    * features.
    */
  @scala.inline
  def XRTYPE_VR: java.lang.String = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRTYPE_VR").asInstanceOf[java.lang.String]
  
  /**
    * Generates normal information from the specified positions and
    * triangle indices. See {@link pc.createMesh}.
    * @example
    * var normals = pc.calculateNormals(positions, indices);
    * var tangents = pc.calculateTangents(positions, normals, uvs, indices);
    * var mesh = pc.createMesh(positions, normals, tangents, uvs, indices);
    * @param positions - An array of 3-dimensional vertex positions.
    * @param indices - An array of triangle indices.
    * @returns An array of 3-dimensional vertex normals.
    */
  @scala.inline
  def calculateNormals(positions: js.Array[scala.Double], indices: js.Array[scala.Double]): js.Array[scala.Double] = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("calculateNormals")(positions.asInstanceOf[js.Any], indices.asInstanceOf[js.Any])).asInstanceOf[js.Array[scala.Double]]
  
  /**
    * Generates tangent information from the specified positions,
    * normals, texture coordinates and triangle indices. See {@link pc.createMesh}.
    * @example
    * var tangents = pc.calculateTangents(positions, normals, uvs, indices);
    * var mesh = pc.createMesh(positions, normals, tangents, uvs, indices);
    * @param positions - An array of 3-dimensional vertex positions.
    * @param normals - An array of 3-dimensional vertex normals.
    * @param uvs - An array of 2-dimensional vertex texture coordinates.
    * @param indices - An array of triangle indices.
    * @returns An array of 3-dimensional vertex tangents.
    */
  @scala.inline
  def calculateTangents(
    positions: js.Array[scala.Double],
    normals: js.Array[scala.Double],
    uvs: js.Array[scala.Double],
    indices: js.Array[scala.Double]
  ): js.Array[scala.Double] = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("calculateTangents")(positions.asInstanceOf[js.Any], normals.asInstanceOf[js.Any], uvs.asInstanceOf[js.Any], indices.asInstanceOf[js.Any])).asInstanceOf[js.Array[scala.Double]]
  
  /**
    * Creates a procedural box-shaped mesh.
    *
    * The size, shape and tesselation properties of the box can be controlled via function parameters. By
    * default, the function will create a box centered on the object space origin with a width, length and
    * height of 1.0 unit and 10 segments in either axis (50 triangles per face).
    *
    * Note that the box is created with UVs in the range of 0 to 1 on each face. Additionally, tangent
    * information is generated into the vertex buffer of the box's mesh.
    * @param device - The graphics device used to manage the mesh.
    * @param [opts] - An object that specifies optional inputs for the function as follows:
    * @param [opts.halfExtents] - The half dimensions of the box in each axis (defaults to [0.5, 0.5, 0.5]).
    * @param [opts.widthSegments] - The number of divisions along the X axis of the box (defaults to 1).
    * @param [opts.lengthSegments] - The number of divisions along the Z axis of the box (defaults to 1).
    * @param [opts.heightSegments] - The number of divisions along the Y axis of the box (defaults to 1).
    * @returns A new box-shaped mesh.
    */
  @scala.inline
  def createBox(device: typingsSlinky.playcanvas.pc.GraphicsDevice): typingsSlinky.playcanvas.pc.Mesh = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createBox")(device.asInstanceOf[js.Any]).asInstanceOf[typingsSlinky.playcanvas.pc.Mesh]
  @scala.inline
  def createBox(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    opts: typingsSlinky.playcanvas.anon.HeightSegments
  ): typingsSlinky.playcanvas.pc.Mesh = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createBox")(device.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[typingsSlinky.playcanvas.pc.Mesh]
  
  /**
    * Creates a procedural capsule-shaped mesh.
    *
    * The size, shape and tesselation properties of the capsule can be controlled via function
    * parameters. By default, the function will create a capsule standing vertically centered
    * on the XZ-plane with a radius of 0.25, a height of 1.0, 1 height segment and 10 cap
    * segments.
    *
    * Note that the capsule is created with UVs in the range of 0 to 1. Additionally, tangent information
    * is generated into the vertex buffer of the capsule's mesh.
    * @param device - The graphics device used to manage the mesh.
    * @param [opts] - An object that specifies optional inputs for the function as follows:
    * @param [opts.radius] - The radius of the tube forming the body of the capsule (defaults to 0.3).
    * @param [opts.height] - The length of the body of the capsule from tip to tip (defaults to 1.0).
    * @param [opts.heightSegments] - The number of divisions along the tubular length of the capsule (defaults to 1).
    * @param [opts.sides] - The number of divisions around the tubular body of the capsule (defaults to 20).
    * @returns A new cylinder-shaped mesh.
    */
  @scala.inline
  def createCapsule(device: typingsSlinky.playcanvas.pc.GraphicsDevice): typingsSlinky.playcanvas.pc.Mesh = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createCapsule")(device.asInstanceOf[js.Any]).asInstanceOf[typingsSlinky.playcanvas.pc.Mesh]
  @scala.inline
  def createCapsule(device: typingsSlinky.playcanvas.pc.GraphicsDevice, opts: typingsSlinky.playcanvas.anon.Height): typingsSlinky.playcanvas.pc.Mesh = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createCapsule")(device.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[typingsSlinky.playcanvas.pc.Mesh]
  
  /**
    * Creates a procedural cone-shaped mesh.
    *
    * The size, shape and tesselation properties of the cone can be controlled via function
    * parameters. By default, the function will create a cone standing vertically centered
    * on the XZ-plane with a base radius of 0.5, a height of 1.0, 5 height segments and 20
    * cap segments.
    *
    * Note that the cone is created with UVs in the range of 0 to 1. Additionally, tangent
    * information is generated into the vertex buffer of the cone's mesh.
    * @param device - The graphics device used to manage the mesh.
    * @param [opts] - An object that specifies optional inputs for the function as follows:
    * @param [opts.baseRadius] - The base radius of the cone (defaults to 0.5).
    * @param [opts.peakRadius] - The peak radius of the cone (defaults to 0.0).
    * @param [opts.height] - The length of the body of the cone (defaults to 1.0).
    * @param [opts.heightSegments] - The number of divisions along the length of the cone (defaults to 5).
    * @param [opts.capSegments] - The number of divisions around the tubular body of the cone (defaults to 18).
    * @returns A new cone-shaped mesh.
    */
  @scala.inline
  def createCone(device: typingsSlinky.playcanvas.pc.GraphicsDevice): typingsSlinky.playcanvas.pc.Mesh = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createCone")(device.asInstanceOf[js.Any]).asInstanceOf[typingsSlinky.playcanvas.pc.Mesh]
  @scala.inline
  def createCone(device: typingsSlinky.playcanvas.pc.GraphicsDevice, opts: typingsSlinky.playcanvas.anon.BaseRadius): typingsSlinky.playcanvas.pc.Mesh = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createCone")(device.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[typingsSlinky.playcanvas.pc.Mesh]
  
  /**
    * Creates a procedural cylinder-shaped mesh.
    *
    * The size, shape and tesselation properties of the cylinder can be controlled via function parameters.
    * By default, the function will create a cylinder standing vertically centered on the XZ-plane with a radius
    * of 0.5, a height of 1.0, 1 height segment and 20 cap segments.
    *
    * Note that the cylinder is created with UVs in the range of 0 to 1. Additionally, tangent information
    * is generated into the vertex buffer of the cylinder's mesh.
    * @param device - The graphics device used to manage the mesh.
    * @param [opts] - An object that specifies optional inputs for the function as follows:
    * @param [opts.radius] - The radius of the tube forming the body of the cylinder (defaults to 0.5).
    * @param [opts.height] - The length of the body of the cylinder (defaults to 1.0).
    * @param [opts.heightSegments] - The number of divisions along the length of the cylinder (defaults to 5).
    * @param [opts.capSegments] - The number of divisions around the tubular body of the cylinder (defaults to 20).
    * @returns A new cylinder-shaped mesh.
    */
  @scala.inline
  def createCylinder(device: typingsSlinky.playcanvas.pc.GraphicsDevice): typingsSlinky.playcanvas.pc.Mesh = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createCylinder")(device.asInstanceOf[js.Any]).asInstanceOf[typingsSlinky.playcanvas.pc.Mesh]
  @scala.inline
  def createCylinder(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    opts: typingsSlinky.playcanvas.anon.CapSegments
  ): typingsSlinky.playcanvas.pc.Mesh = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createCylinder")(device.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[typingsSlinky.playcanvas.pc.Mesh]
  
  /**
    * Creates a new mesh object from the supplied vertex information and topology.
    * @example
    * // Create a simple, indexed triangle (with texture coordinates and vertex normals)
    * var mesh = pc.createMesh(graphicsDevice, [0, 0, 0, 1, 0, 0, 0, 1, 0], {
    *     normals: [0, 0, 1, 0, 0, 1, 0, 0, 1],
    *     uvs: [0, 0, 1, 0, 0, 1],
    *     indices: [0, 1, 2]
    * });
    * @param device - The graphics device used to manage the mesh.
    * @param positions - An array of 3-dimensional vertex positions.
    * @param [opts] - An object that specifies optional inputs for the function as follows:
    * @param [opts.normals] - An array of 3-dimensional vertex normals.
    * @param [opts.tangents] - An array of 3-dimensional vertex tangents.
    * @param [opts.colors] - An array of 4-dimensional vertex colors where each
    * component is an integer in the range 0 to 255.
    * @param [opts.uvs] - An array of 2-dimensional vertex texture coordinates.
    * @param [opts.uvs1] - Same as opts.uvs, but for additional UV set
    * @param [opts.blendIndices] - An array of 4-dimensional bone indices where each
    * component is an integer in the range 0 to 255.
    * @param [opts.blendWeights] - An array of 4-dimensional bone weights where each
    * component is in the range 0 to 1 and the sum of the weights should equal 1.
    * @param [opts.indices] - An array of triangle indices.
    * @returns A new Mesh constructed from the supplied vertex and triangle data.
    */
  @scala.inline
  def createMesh(device: typingsSlinky.playcanvas.pc.GraphicsDevice, positions: js.Array[scala.Double]): typingsSlinky.playcanvas.pc.Mesh = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createMesh")(device.asInstanceOf[js.Any], positions.asInstanceOf[js.Any])).asInstanceOf[typingsSlinky.playcanvas.pc.Mesh]
  @scala.inline
  def createMesh(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    positions: js.Array[scala.Double],
    opts: typingsSlinky.playcanvas.anon.BlendIndices
  ): typingsSlinky.playcanvas.pc.Mesh = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createMesh")(device.asInstanceOf[js.Any], positions.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[typingsSlinky.playcanvas.pc.Mesh]
  
  /**
    * Creates a procedural plane-shaped mesh.
    *
    * The size and tesselation properties of the plane can be controlled via function
    * parameters. By default, the function will create a plane centered on the object
    * space origin with a width and length of 1.0 and 5 segments in either axis (50
    * triangles). The normal vector of the plane is aligned along the positive Y axis.
    *
    * Note that the plane is created with UVs in the range of 0 to 1. Additionally, tangent
    * information is generated into the vertex buffer of the plane's mesh.
    * @param device - The graphics device used to manage the mesh.
    * @param [opts] - An object that specifies optional inputs for the function as follows:
    * @param [opts.halfExtents] - The half dimensions of the plane in the X and Z axes (defaults to [0.5, 0.5]).
    * @param [opts.widthSegments] - The number of divisions along the X axis of the plane (defaults to 5).
    * @param [opts.lengthSegments] - The number of divisions along the Z axis of the plane (defaults to 5).
    * @returns A new plane-shaped mesh.
    */
  @scala.inline
  def createPlane(device: typingsSlinky.playcanvas.pc.GraphicsDevice): typingsSlinky.playcanvas.pc.Mesh = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createPlane")(device.asInstanceOf[js.Any]).asInstanceOf[typingsSlinky.playcanvas.pc.Mesh]
  @scala.inline
  def createPlane(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    opts: typingsSlinky.playcanvas.anon.HalfExtents
  ): typingsSlinky.playcanvas.pc.Mesh = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createPlane")(device.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[typingsSlinky.playcanvas.pc.Mesh]
  
  /**
    * Create and register a new {@link pc.ScriptType}.
    * It returns new class type (constructor function), which is auto-registered to {@link pc.ScriptRegistry} using it's name.
    * This is the main interface to create Script Types, to define custom logic using JavaScript, that is used to create interaction for entities.
    * @example
    * var Turning = pc.createScript('turn');
    *
    * // define `speed` attribute that is available in Editor UI
    * Turning.attributes.add('speed', {
    *     type: 'number',
    *     default: 180,
    *     placeholder: 'deg/s'
    * });
    *
    * // runs every tick
    * Turning.prototype.update = function (dt) {
    *     this.entity.rotate(0, this.speed * dt, 0);
    * };
    * @param name - Unique Name of a Script Type.
    * If a Script Type with the same name has already been registered and the new one has a `swap` method defined in its prototype,
    * then it will perform hot swapping of existing Script Instances on entities using this new Script Type.
    * Note: There is a reserved list of names that cannot be used, such as list below as well as some starting from `_` (underscore):
    * system, entity, create, destroy, swap, move, scripts, onEnable, onDisable, onPostStateChange, has, on, off, fire, once, hasEvent.
    * @param [app] - Optional application handler, to choose which {@link pc.ScriptRegistry} to add a script to.
    * By default it will use `pc.Application.getApplication()` to get current {@link pc.Application}.
    * @returns A class type (constructor function) that inherits {@link pc.ScriptType},
    * which the developer is meant to further extend by adding attributes and prototype methods.
    */
  @scala.inline
  def createScript(name: java.lang.String): typingsSlinky.playcanvas.anon.TypeofScriptType with (org.scalablytyped.runtime.Instantiable1[
    /* args */ typingsSlinky.playcanvas.anon.App, 
    typingsSlinky.playcanvas.pc.ScriptType
  ]) = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createScript")(name.asInstanceOf[js.Any]).asInstanceOf[typingsSlinky.playcanvas.anon.TypeofScriptType with (org.scalablytyped.runtime.Instantiable1[
    /* args */ typingsSlinky.playcanvas.anon.App, 
    typingsSlinky.playcanvas.pc.ScriptType
  ])]
  @scala.inline
  def createScript(name: java.lang.String, app: typingsSlinky.playcanvas.pc.Application): typingsSlinky.playcanvas.anon.TypeofScriptType with (org.scalablytyped.runtime.Instantiable1[
    /* args */ typingsSlinky.playcanvas.anon.App, 
    typingsSlinky.playcanvas.pc.ScriptType
  ]) = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createScript")(name.asInstanceOf[js.Any], app.asInstanceOf[js.Any])).asInstanceOf[typingsSlinky.playcanvas.anon.TypeofScriptType with (org.scalablytyped.runtime.Instantiable1[
    /* args */ typingsSlinky.playcanvas.anon.App, 
    typingsSlinky.playcanvas.pc.ScriptType
  ])]
  
  /**
    * Creates a procedural sphere-shaped mesh.
    *
    * The size and tesselation properties of the sphere can be controlled via function
    * parameters. By default, the function will create a sphere centered on the object
    * space origin with a radius of 0.5 and 16 segments in both longitude and latitude.
    *
    * Note that the sphere is created with UVs in the range of 0 to 1. Additionally, tangent
    * information is generated into the vertex buffer of the sphere's mesh.
    * @param device - The graphics device used to manage the mesh.
    * @param [opts] - An object that specifies optional inputs for the function as follows:
    * @param [opts.radius] - The radius of the sphere (defaults to 0.5).
    * @param [opts.segments] - The number of divisions along the longitudinal
    * and latitudinal axes of the sphere (defaults to 16).
    * @returns A new sphere-shaped mesh.
    */
  @scala.inline
  def createSphere(device: typingsSlinky.playcanvas.pc.GraphicsDevice): typingsSlinky.playcanvas.pc.Mesh = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createSphere")(device.asInstanceOf[js.Any]).asInstanceOf[typingsSlinky.playcanvas.pc.Mesh]
  @scala.inline
  def createSphere(device: typingsSlinky.playcanvas.pc.GraphicsDevice, opts: typingsSlinky.playcanvas.anon.Radius): typingsSlinky.playcanvas.pc.Mesh = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createSphere")(device.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[typingsSlinky.playcanvas.pc.Mesh]
  
  /**
    * Creates a &lt;style&gt; DOM element from a string that contains CSS.
    * @example
    * var css = 'body {height: 100;}';
    * var style = pc.createStyle(css);
    * document.head.appendChild(style);
    * @param cssString - A string that contains valid CSS.
    * @returns The style DOM element.
    */
  @scala.inline
  def createStyle(cssString: java.lang.String): org.scalajs.dom.raw.Element = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createStyle")(cssString.asInstanceOf[js.Any]).asInstanceOf[org.scalajs.dom.raw.Element]
  
  /**
    * Creates a procedural torus-shaped mesh.
    *
    * The size, shape and tesselation properties of the torus can be controlled via function parameters.
    * By default, the function will create a torus in the XZ-plane with a tube radius of 0.2, a ring radius
    * of 0.3, 20 segments and 30 sides.
    *
    * Note that the torus is created with UVs in the range of 0 to 1. Additionally, tangent information
    * is generated into the vertex buffer of the torus's mesh.
    * @param device - The graphics device used to manage the mesh.
    * @param [opts] - An object that specifies optional inputs for the function as follows:
    * @param [opts.tubeRadius] - The radius of the tube forming the body of the torus (defaults to 0.2).
    * @param [opts.ringRadius] - The radius from the centre of the torus to the centre of the tube (defaults to 0.3).
    * @param [opts.segments] - The number of radial divisions forming cross-sections of the torus ring (defaults to 20).
    * @param [opts.sides] - The number of divisions around the tubular body of the torus ring (defaults to 30).
    * @returns A new torus-shaped mesh.
    */
  @scala.inline
  def createTorus(device: typingsSlinky.playcanvas.pc.GraphicsDevice): typingsSlinky.playcanvas.pc.Mesh = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createTorus")(device.asInstanceOf[js.Any]).asInstanceOf[typingsSlinky.playcanvas.pc.Mesh]
  @scala.inline
  def createTorus(device: typingsSlinky.playcanvas.pc.GraphicsDevice, opts: typingsSlinky.playcanvas.anon.RingRadius): typingsSlinky.playcanvas.pc.Mesh = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createTorus")(device.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[typingsSlinky.playcanvas.pc.Mesh]
  
  /**
    * Draw a screen-space rectangle in a render target. Primarily meant to be used in custom post effects based on {@link pc.PostEffect}.
    * @param device - The graphics device of the application.
    * @param target - The output render target.
    * @param vertexBuffer - The vertex buffer for the rectangle mesh. When calling from a custom post effect, pass the field {@link pc.PostEffect#vertexBuffer}.
    * @param shader - The shader to be used for drawing the rectangle. When calling from a custom post effect, pass the field {@link pc.PostEffect#shader}.
    * @param [rect] - The normalized screen-space position (rect.x, rect.y) and size (rect.z, rect.w) of the rectangle. Default is [0, 0, 1, 1].
    */
  @scala.inline
  def drawFullscreenQuad(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    vertexBuffer: typingsSlinky.playcanvas.pc.VertexBuffer,
    shader: typingsSlinky.playcanvas.pc.Shader
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawFullscreenQuad")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], vertexBuffer.asInstanceOf[js.Any], shader.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawFullscreenQuad(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    vertexBuffer: typingsSlinky.playcanvas.pc.VertexBuffer,
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: typingsSlinky.playcanvas.pc.Vec4
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawFullscreenQuad")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], vertexBuffer.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  
  @scala.inline
  def drawQuadWithShader(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    target: js.UndefOr[scala.Nothing],
    shader: typingsSlinky.playcanvas.pc.Shader
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawQuadWithShader(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    target: js.UndefOr[scala.Nothing],
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: js.UndefOr[scala.Nothing],
    scissorRect: js.UndefOr[scala.Nothing],
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawQuadWithShader(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    target: js.UndefOr[scala.Nothing],
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: js.UndefOr[scala.Nothing],
    scissorRect: typingsSlinky.playcanvas.pc.Vec4
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawQuadWithShader(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    target: js.UndefOr[scala.Nothing],
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: js.UndefOr[scala.Nothing],
    scissorRect: typingsSlinky.playcanvas.pc.Vec4,
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawQuadWithShader(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    target: js.UndefOr[scala.Nothing],
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: typingsSlinky.playcanvas.pc.Vec4
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawQuadWithShader(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    target: js.UndefOr[scala.Nothing],
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: typingsSlinky.playcanvas.pc.Vec4,
    scissorRect: js.UndefOr[scala.Nothing],
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawQuadWithShader(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    target: js.UndefOr[scala.Nothing],
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: typingsSlinky.playcanvas.pc.Vec4,
    scissorRect: typingsSlinky.playcanvas.pc.Vec4
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawQuadWithShader(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    target: js.UndefOr[scala.Nothing],
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: typingsSlinky.playcanvas.pc.Vec4,
    scissorRect: typingsSlinky.playcanvas.pc.Vec4,
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  /**
    * Draws a screen-space quad using a specific shader. Mostly used by post-effects.
    * @param device - The graphics device used to draw the quad.
    * @param target - The destination render target. If undefined, target is the frame buffer.
    * @param shader - The shader used for rendering the quad. Vertex shader should contain `attribute vec2 vertex_position`.
    * @param [rect] - The viewport rectangle of the quad, in pixels. Defaults to fullscreen (`0, 0, target.width, target.height`).
    * @param [scissorRect] - The scissor rectangle of the quad, in pixels. Defaults to fullscreen (`0, 0, target.width, target.height`).
    * @param [useBlend] - True to enable blending. Defaults to false, disabling blending.
    */
  @scala.inline
  def drawQuadWithShader(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: typingsSlinky.playcanvas.pc.Shader
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawQuadWithShader(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: js.UndefOr[scala.Nothing],
    scissorRect: js.UndefOr[scala.Nothing],
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawQuadWithShader(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: js.UndefOr[scala.Nothing],
    scissorRect: typingsSlinky.playcanvas.pc.Vec4
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawQuadWithShader(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: js.UndefOr[scala.Nothing],
    scissorRect: typingsSlinky.playcanvas.pc.Vec4,
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawQuadWithShader(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: typingsSlinky.playcanvas.pc.Vec4
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawQuadWithShader(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: typingsSlinky.playcanvas.pc.Vec4,
    scissorRect: js.UndefOr[scala.Nothing],
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawQuadWithShader(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: typingsSlinky.playcanvas.pc.Vec4,
    scissorRect: typingsSlinky.playcanvas.pc.Vec4
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawQuadWithShader(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: typingsSlinky.playcanvas.pc.Vec4,
    scissorRect: typingsSlinky.playcanvas.pc.Vec4,
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  
  /**
    * Draws a texture in screen-space. Mostly used by post-effects.
    * @param device - The graphics device used to draw the texture.
    * @param texture - The source texture to be drawn. Accessible as `uniform sampler2D source` in shader.
    * @param [target] - The destination render target. Defaults to the frame buffer.
    * @param [shader] - The shader used for rendering the texture. Defaults to `pc.GraphicsDevice#getCopyShader()`.
    * @param [rect] - The viewport rectangle to use for the texture, in pixels. Defaults to fullscreen (`0, 0, target.width, target.height`).
    * @param [scissorRect] - The scissor rectangle to use for the texture, in pixels. Defaults to fullscreen (`0, 0, target.width, target.height`).
    * @param [useBlend] - True to enable blending. Defaults to false, disabling blending.
    */
  @scala.inline
  def drawTexture(device: typingsSlinky.playcanvas.pc.GraphicsDevice, texture: typingsSlinky.playcanvas.pc.Texture): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: js.UndefOr[scala.Nothing],
    shader: js.UndefOr[scala.Nothing],
    rect: js.UndefOr[scala.Nothing],
    scissorRect: js.UndefOr[scala.Nothing],
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: js.UndefOr[scala.Nothing],
    shader: js.UndefOr[scala.Nothing],
    rect: js.UndefOr[scala.Nothing],
    scissorRect: typingsSlinky.playcanvas.pc.Vec4
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: js.UndefOr[scala.Nothing],
    shader: js.UndefOr[scala.Nothing],
    rect: js.UndefOr[scala.Nothing],
    scissorRect: typingsSlinky.playcanvas.pc.Vec4,
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: js.UndefOr[scala.Nothing],
    shader: js.UndefOr[scala.Nothing],
    rect: typingsSlinky.playcanvas.pc.Vec4
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: js.UndefOr[scala.Nothing],
    shader: js.UndefOr[scala.Nothing],
    rect: typingsSlinky.playcanvas.pc.Vec4,
    scissorRect: js.UndefOr[scala.Nothing],
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: js.UndefOr[scala.Nothing],
    shader: js.UndefOr[scala.Nothing],
    rect: typingsSlinky.playcanvas.pc.Vec4,
    scissorRect: typingsSlinky.playcanvas.pc.Vec4
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: js.UndefOr[scala.Nothing],
    shader: js.UndefOr[scala.Nothing],
    rect: typingsSlinky.playcanvas.pc.Vec4,
    scissorRect: typingsSlinky.playcanvas.pc.Vec4,
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: js.UndefOr[scala.Nothing],
    shader: typingsSlinky.playcanvas.pc.Shader
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: js.UndefOr[scala.Nothing],
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: js.UndefOr[scala.Nothing],
    scissorRect: js.UndefOr[scala.Nothing],
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: js.UndefOr[scala.Nothing],
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: js.UndefOr[scala.Nothing],
    scissorRect: typingsSlinky.playcanvas.pc.Vec4
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: js.UndefOr[scala.Nothing],
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: js.UndefOr[scala.Nothing],
    scissorRect: typingsSlinky.playcanvas.pc.Vec4,
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: js.UndefOr[scala.Nothing],
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: typingsSlinky.playcanvas.pc.Vec4
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: js.UndefOr[scala.Nothing],
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: typingsSlinky.playcanvas.pc.Vec4,
    scissorRect: js.UndefOr[scala.Nothing],
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: js.UndefOr[scala.Nothing],
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: typingsSlinky.playcanvas.pc.Vec4,
    scissorRect: typingsSlinky.playcanvas.pc.Vec4
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: js.UndefOr[scala.Nothing],
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: typingsSlinky.playcanvas.pc.Vec4,
    scissorRect: typingsSlinky.playcanvas.pc.Vec4,
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.RenderTarget
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: js.UndefOr[scala.Nothing],
    rect: js.UndefOr[scala.Nothing],
    scissorRect: js.UndefOr[scala.Nothing],
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: js.UndefOr[scala.Nothing],
    rect: js.UndefOr[scala.Nothing],
    scissorRect: typingsSlinky.playcanvas.pc.Vec4
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: js.UndefOr[scala.Nothing],
    rect: js.UndefOr[scala.Nothing],
    scissorRect: typingsSlinky.playcanvas.pc.Vec4,
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: js.UndefOr[scala.Nothing],
    rect: typingsSlinky.playcanvas.pc.Vec4
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: js.UndefOr[scala.Nothing],
    rect: typingsSlinky.playcanvas.pc.Vec4,
    scissorRect: js.UndefOr[scala.Nothing],
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: js.UndefOr[scala.Nothing],
    rect: typingsSlinky.playcanvas.pc.Vec4,
    scissorRect: typingsSlinky.playcanvas.pc.Vec4
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: js.UndefOr[scala.Nothing],
    rect: typingsSlinky.playcanvas.pc.Vec4,
    scissorRect: typingsSlinky.playcanvas.pc.Vec4,
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: typingsSlinky.playcanvas.pc.Shader
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: js.UndefOr[scala.Nothing],
    scissorRect: js.UndefOr[scala.Nothing],
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: js.UndefOr[scala.Nothing],
    scissorRect: typingsSlinky.playcanvas.pc.Vec4
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: js.UndefOr[scala.Nothing],
    scissorRect: typingsSlinky.playcanvas.pc.Vec4,
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: typingsSlinky.playcanvas.pc.Vec4
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: typingsSlinky.playcanvas.pc.Vec4,
    scissorRect: js.UndefOr[scala.Nothing],
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: typingsSlinky.playcanvas.pc.Vec4,
    scissorRect: typingsSlinky.playcanvas.pc.Vec4
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def drawTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    texture: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.RenderTarget,
    shader: typingsSlinky.playcanvas.pc.Shader,
    rect: typingsSlinky.playcanvas.pc.Vec4,
    scissorRect: typingsSlinky.playcanvas.pc.Vec4,
    useBlend: scala.Boolean
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  
  /**
    * Similar to {@link pc.getTargetCoords} for the MouseEvents.
    * This function takes a browser Touch object and returns the co-ordinates of the
    * touch relative to the target element.
    * @param touch - The browser Touch object.
    * @returns The co-ordinates of the touch relative to the touch.target element. In the format {x, y}.
    */
  @scala.inline
  def getTouchTargetCoords(touch: typingsSlinky.playcanvas.pc.Touch): js.Any = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("getTouchTargetCoords")(touch.asInstanceOf[js.Any]).asInstanceOf[js.Any]
  
  /**
    * Prefilter a cubemap for use by a {@link pc.StandardMaterial} as an environment map. Should only be used for cubemaps that can't be prefiltered ahead of time (in the editor).
    * @param options - The options for how the cubemap is prefiltered.
    */
  @scala.inline
  def prefilterCubemap(options: js.Any): scala.Unit = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("prefilterCubemap")(options.asInstanceOf[js.Any]).asInstanceOf[scala.Unit]
  
  /**
    * Register a existing class type as a Script Type to {@link pc.ScriptRegistry}.
    * Useful when defining a ES6 script class that extends {@link pc.ScriptType} (see example).
    * @example
    * // define a ES6 script class
    * class PlayerController extends pc.ScriptType {
    *
    *     initialize() {
    *         // called once on initialize
    *     }
    *
    *     update(dt) {
    *         // called each tick
    *     }
    * }
    *
    * // register the class as a script
    * pc.registerScript(PlayerController);
    *
    * // declare script attributes (Must be after pc.registerScript())
    * PlayerController.attributes.add('attribute1', {type: 'number'});
    * @param script - The existing class type (constructor function) to be registered as a Script Type.
    * Class must extend {@link pc.ScriptType} (see example). Please note: A class created using {@link pc.createScript} is auto-registered,
    * and should therefore not be pass into {@link pc.registerScript} (which would result in swapping out all related script instances).
    * @param [name] - Optional unique name of the Script Type. By default it will use the same name as the existing class.
    * If a Script Type with the same name has already been registered and the new one has a `swap` method defined in its prototype,
    * then it will perform hot swapping of existing Script Instances on entities using this new Script Type.
    * Note: There is a reserved list of names that cannot be used, such as list below as well as some starting from `_` (underscore):
    * system, entity, create, destroy, swap, move, scripts, onEnable, onDisable, onPostStateChange, has, on, off, fire, once, hasEvent.
    * @param [app] - Optional application handler, to choose which {@link pc.ScriptRegistry} to register the script type to.
    * By default it will use `pc.Application.getApplication()` to get current {@link pc.Application}.
    */
  @scala.inline
  def registerScript(
    script: typingsSlinky.playcanvas.anon.TypeofScriptType with (org.scalablytyped.runtime.Instantiable1[
      /* args */ typingsSlinky.playcanvas.anon.App, 
      typingsSlinky.playcanvas.pc.ScriptType
    ])
  ): scala.Unit = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("registerScript")(script.asInstanceOf[js.Any]).asInstanceOf[scala.Unit]
  @scala.inline
  def registerScript(
    script: typingsSlinky.playcanvas.anon.TypeofScriptType with (org.scalablytyped.runtime.Instantiable1[
      /* args */ typingsSlinky.playcanvas.anon.App, 
      typingsSlinky.playcanvas.pc.ScriptType
    ]),
    name: js.UndefOr[scala.Nothing],
    app: typingsSlinky.playcanvas.pc.Application
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("registerScript")(script.asInstanceOf[js.Any], name.asInstanceOf[js.Any], app.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def registerScript(
    script: typingsSlinky.playcanvas.anon.TypeofScriptType with (org.scalablytyped.runtime.Instantiable1[
      /* args */ typingsSlinky.playcanvas.anon.App, 
      typingsSlinky.playcanvas.pc.ScriptType
    ]),
    name: java.lang.String
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("registerScript")(script.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def registerScript(
    script: typingsSlinky.playcanvas.anon.TypeofScriptType with (org.scalablytyped.runtime.Instantiable1[
      /* args */ typingsSlinky.playcanvas.anon.App, 
      typingsSlinky.playcanvas.pc.ScriptType
    ]),
    name: java.lang.String,
    app: typingsSlinky.playcanvas.pc.Application
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("registerScript")(script.asInstanceOf[js.Any], name.asInstanceOf[js.Any], app.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  
  /**
    * This function reprojects textures between cubemap and equirectangular formats. The
    * function can read and write textures with pixel data in RGBE, RGBM, linear and sRGB formats. When
    * specularPower is specified it will perform a phong-weighted convolution of the source (for generating
    * a gloss maps).
    * @param device - The graphics device
    * @param source - The source texture
    * @param target - The target texture
    * @param [specularPower] - optional specular power. When specular power is specified,
    * the source is convolved by a phong-weighted kernel raised to the specified power. Otherwise
    * the function performs a standard resample.
    * @param [numSamples] - optional number of samples (default is 1024).
    */
  @scala.inline
  def reprojectTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    source: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.Texture
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("reprojectTexture")(device.asInstanceOf[js.Any], source.asInstanceOf[js.Any], target.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def reprojectTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    source: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.Texture,
    specularPower: js.UndefOr[scala.Nothing],
    numSamples: scala.Double
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("reprojectTexture")(device.asInstanceOf[js.Any], source.asInstanceOf[js.Any], target.asInstanceOf[js.Any], specularPower.asInstanceOf[js.Any], numSamples.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def reprojectTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    source: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.Texture,
    specularPower: scala.Double
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("reprojectTexture")(device.asInstanceOf[js.Any], source.asInstanceOf[js.Any], target.asInstanceOf[js.Any], specularPower.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def reprojectTexture(
    device: typingsSlinky.playcanvas.pc.GraphicsDevice,
    source: typingsSlinky.playcanvas.pc.Texture,
    target: typingsSlinky.playcanvas.pc.Texture,
    specularPower: scala.Double,
    numSamples: scala.Double
  ): scala.Unit = (typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("reprojectTexture")(device.asInstanceOf[js.Any], source.asInstanceOf[js.Any], target.asInstanceOf[js.Any], specularPower.asInstanceOf[js.Any], numSamples.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  
  /**
    * Object containing all default shader chunks used by shader generators.
    */
  @scala.inline
  def shaderChunks: js.Any = typingsSlinky.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("shaderChunks").asInstanceOf[js.Any]
}
