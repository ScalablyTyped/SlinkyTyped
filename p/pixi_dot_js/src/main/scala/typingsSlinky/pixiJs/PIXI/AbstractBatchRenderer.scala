package typingsSlinky.pixiJs.PIXI

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

/**
  * Renderer dedicated to drawing and batching sprites.
  *
  * This is the default batch renderer. It buffers objects
  * with texture-based geometries and renders them in
  * batches. It uploads multiple textures to the GPU to
  * reduce to the number of draw calls.
  *
  * @class
  * @protected
  * @memberof PIXI
  * @extends PIXI.ObjectRenderer
  */
@js.native
trait AbstractBatchRenderer extends ObjectRenderer {
  /**
    * Maximum number of textures that can be uploaded to
    * the GPU under the current context. It is initialized
    * properly in `this.contextChange`.
    *
    * @member {number} PIXI.AbstractBatchRenderer#MAX_TEXTURES
    * @see PIXI.AbstractBatchRenderer#contextChange
    * @readonly
    */
  val MAX_TEXTURES: Double = js.native
  /**
    * This shader is generated by `this.shaderGenerator`.
    *
    * It is generated specifically to handle the required
    * number of textures being batched together.
    *
    * @member {PIXI.Shader} PIXI.AbstractBatchRenderer#_shader
    * @protected
    */
  var _shader: Shader = js.native
  /**
    * The class that represents the geometry of objects
    * that are going to be batched with this.
    *
    * @member {object} PIXI.AbstractBatchRenderer#geometryClass
    * @default PIXI.BatchGeometry
    * @protected
    */
  var geometryClass: js.Any = js.native
  /**
    * This is used to generate a shader that can
    * color each vertex based on a `aTextureId`
    * attribute that points to an texture in `uSampler`.
    *
    * This enables the objects with different textures
    * to be drawn in the same draw call.
    *
    * You can customize your shader by creating your
    * custom shader generator.
    *
    * @member {PIXI.BatchShaderGenerator} PIXI.AbstractBatchRenderer#shaderGenerator
    * @protected
    */
  var shaderGenerator: BatchShaderGenerator = js.native
  /**
    * The number of bufferable objects before a flush
    * occurs automatically.
    *
    * @member {number} PIXI.AbstractBatchRenderer#size
    * @default settings.SPRITE_BATCH_SIZE * 4
    */
  var size: Double = js.native
  /**
    * The WebGL state in which this renderer will work.
    *
    * @member {PIXI.State} PIXI.AbstractBatchRenderer#state
    * @readonly
    */
  val state: State = js.native
  /**
    * Size of data being buffered per vertex in the
    * attribute buffers (in floats). By default, the
    * batch-renderer plugin uses 6:
    *
    * | aVertexPosition | 2 |
    * |-----------------|---|
    * | aTextureCoords  | 2 |
    * | aColor          | 1 |
    * | aTextureId      | 1 |
    *
    * @member {number} PIXI.AbstractBatchRenderer#vertexSize
    * @readonly
    */
  val vertexSize: Double = js.native
  /**
    * Bind textures for current rendering
    *
    * @param {PIXI.BatchTextureArray} texArray
    */
  def bindAndClearTexArray(texArray: BatchTextureArray): Unit = js.native
  /**
    * Populating drawcalls for rendering
    *
    * @param {PIXI.BatchTextureArray} texArray
    * @param {number} start
    * @param {number} finish
    */
  def buildDrawCalls(texArray: BatchTextureArray, start: Double, finish: Double): Unit = js.native
  /**
    * Handles the `contextChange` signal.
    *
    * It calculates `this.MAX_TEXTURES` and allocating the
    * packed-geometry object pool.
    */
  def contextChange(): Unit = js.native
  /**
    * Makes sure that static and dynamic flush pooled objects have correct dimensions
    */
  def initFlushBuffers(): Unit = js.native
  /**
    * Handles the `prerender` signal.
    *
    * It ensures that flushes start from the first geometry
    * object again.
    */
  def onPrerender(): Unit = js.native
  /**
    * Takes the four batching parameters of `element`, interleaves
    * and pushes them into the batching attribute/index buffers given.
    *
    * It uses these properties: `vertexData` `uvs`, `textureId` and
    * `indicies`. It also uses the "tint" of the base-texture, if
    * present.
    *
    * @param {PIXI.Sprite} element - element being rendered
    * @param {PIXI.ViewableBuffer} attributeBuffer - attribute buffer.
    * @param {Uint16Array} indexBuffer - index buffer
    * @param {number} aIndex - number of floats already in the attribute buffer
    * @param {number} iIndex - number of indices already in `indexBuffer`
    */
  def packInterleavedGeometry(
    element: Sprite,
    attributeBuffer: ViewableBuffer,
    indexBuffer: js.typedarray.Uint16Array,
    aIndex: Double,
    iIndex: Double
  ): Unit = js.native
}

object AbstractBatchRenderer {
  @scala.inline
  def apply(
    MAX_TEXTURES: Double,
    _shader: Shader,
    bindAndClearTexArray: BatchTextureArray => Unit,
    buildDrawCalls: (BatchTextureArray, Double, Double) => Unit,
    contextChange: () => Unit,
    destroy: () => Unit,
    flush: () => Unit,
    geometryClass: js.Any,
    initFlushBuffers: () => Unit,
    onPrerender: () => Unit,
    packInterleavedGeometry: (Sprite, ViewableBuffer, js.typedarray.Uint16Array, Double, Double) => Unit,
    render: DisplayObject => Unit,
    renderer: Renderer,
    shaderGenerator: BatchShaderGenerator,
    size: Double,
    start: () => Unit,
    state: State,
    stop: () => Unit,
    vertexSize: Double
  ): AbstractBatchRenderer = {
    val __obj = js.Dynamic.literal(MAX_TEXTURES = MAX_TEXTURES.asInstanceOf[js.Any], _shader = _shader.asInstanceOf[js.Any], bindAndClearTexArray = js.Any.fromFunction1(bindAndClearTexArray), buildDrawCalls = js.Any.fromFunction3(buildDrawCalls), contextChange = js.Any.fromFunction0(contextChange), destroy = js.Any.fromFunction0(destroy), flush = js.Any.fromFunction0(flush), geometryClass = geometryClass.asInstanceOf[js.Any], initFlushBuffers = js.Any.fromFunction0(initFlushBuffers), onPrerender = js.Any.fromFunction0(onPrerender), packInterleavedGeometry = js.Any.fromFunction5(packInterleavedGeometry), render = js.Any.fromFunction1(render), renderer = renderer.asInstanceOf[js.Any], shaderGenerator = shaderGenerator.asInstanceOf[js.Any], size = size.asInstanceOf[js.Any], start = js.Any.fromFunction0(start), state = state.asInstanceOf[js.Any], stop = js.Any.fromFunction0(stop), vertexSize = vertexSize.asInstanceOf[js.Any])
    __obj.asInstanceOf[AbstractBatchRenderer]
  }
  @scala.inline
  implicit class AbstractBatchRendererOps[Self <: AbstractBatchRenderer] (val x: Self) extends AnyVal {
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    @scala.inline
    def withMAX_TEXTURES(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("MAX_TEXTURES")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def with_shader(value: Shader): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("_shader")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withBindAndClearTexArray(value: BatchTextureArray => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("bindAndClearTexArray")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withBuildDrawCalls(value: (BatchTextureArray, Double, Double) => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("buildDrawCalls")(js.Any.fromFunction3(value))
        ret
    }
    @scala.inline
    def withContextChange(value: () => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("contextChange")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withGeometryClass(value: js.Any): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("geometryClass")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withInitFlushBuffers(value: () => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("initFlushBuffers")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withOnPrerender(value: () => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("onPrerender")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withPackInterleavedGeometry(value: (Sprite, ViewableBuffer, js.typedarray.Uint16Array, Double, Double) => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("packInterleavedGeometry")(js.Any.fromFunction5(value))
        ret
    }
    @scala.inline
    def withShaderGenerator(value: BatchShaderGenerator): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("shaderGenerator")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withSize(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("size")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withState(value: State): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("state")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withVertexSize(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("vertexSize")(value.asInstanceOf[js.Any])
        ret
    }
  }
  
}

