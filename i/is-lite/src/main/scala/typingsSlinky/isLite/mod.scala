package typingsSlinky.isLite

import org.scalablytyped.runtime.Instantiable1
import org.scalablytyped.runtime.StringDictionary
import typingsSlinky.isLite.isLiteStrings.Array
import typingsSlinky.isLite.isLiteStrings.AsyncFunction
import typingsSlinky.isLite.isLiteStrings.Date
import typingsSlinky.isLite.isLiteStrings.Error
import typingsSlinky.isLite.isLiteStrings.Function
import typingsSlinky.isLite.isLiteStrings.Generator
import typingsSlinky.isLite.isLiteStrings.GeneratorFunction
import typingsSlinky.isLite.isLiteStrings.Iterable
import typingsSlinky.isLite.isLiteStrings.Map
import typingsSlinky.isLite.isLiteStrings.Object
import typingsSlinky.isLite.isLiteStrings.Promise
import typingsSlinky.isLite.isLiteStrings.RegExp
import typingsSlinky.isLite.isLiteStrings.Set
import typingsSlinky.isLite.isLiteStrings.WeakMap
import typingsSlinky.isLite.isLiteStrings.WeakSet
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  object default {
    
    @JSImport("is-lite", JSImport.Default)
    @js.native
    def apply(value: js.Any): Types = js.native
    
    @JSImport("is-lite", "default.array")
    @js.native
    def array(arg: js.Any): /* is std.Array<any> */ Boolean = js.native
    
    @JSImport("is-lite", "default.arrayOf")
    @js.native
    def arrayOf(target: js.Array[_], predicate: js.Function1[/* v */ js.Any, Boolean]): Boolean = js.native
    
    @JSImport("is-lite", "default.asyncFunction")
    @js.native
    def asyncFunction(value: js.Any): /* is std.Function */ Boolean = js.native
    
    @JSImport("is-lite", "default.boolean")
    @js.native
    def boolean(value: js.Any): /* is boolean */ Boolean = js.native
    
    @JSImport("is-lite", "default.date")
    @js.native
    def date(value: js.Any): /* is std.Date */ Boolean = js.native
    
    @JSImport("is-lite", "default.defined")
    @js.native
    def defined(value: js.Any): Boolean = js.native
    
    @JSImport("is-lite", "default.domElement")
    @js.native
    def domElement(value: js.Any): /* is std.Element */ Boolean = js.native
    
    @JSImport("is-lite", "default.empty")
    @js.native
    def empty(value: js.Any): Boolean = js.native
    
    @JSImport("is-lite", "default.error")
    @js.native
    def error(value: js.Any): /* is std.Error */ Boolean = js.native
    
    @JSImport("is-lite", "default.function")
    @js.native
    def function(value: js.Any): /* is std.Function */ Boolean = js.native
    
    @JSImport("is-lite", "default.generator")
    @js.native
    def generator(value: js.Any): /* is std.Generator<unknown, any, unknown> */ Boolean = js.native
    
    @JSImport("is-lite", "default.generatorFunction")
    @js.native
    def generatorFunction(value: js.Any): /* is std.GeneratorFunction */ Boolean = js.native
    
    @JSImport("is-lite", "default.instanceOf")
    @js.native
    def instanceOf[T](instance: js.Any, class_ : Class[T]): /* is T */ Boolean = js.native
    
    @JSImport("is-lite", "default.iterable")
    @js.native
    def iterable(value: js.Any): /* is std.IterableIterator<unknown> */ Boolean = js.native
    
    @JSImport("is-lite", "default.map")
    @js.native
    def map(value: js.Any): /* is std.Map<unknown, unknown> */ Boolean = js.native
    
    @JSImport("is-lite", "default.nan")
    @js.native
    def nan(value: js.Any): Boolean = js.native
    
    @JSImport("is-lite", "default.nullOrUndefined")
    @js.native
    def nullOrUndefined(value: js.Any): Boolean = js.native
    
    @JSImport("is-lite", "default.number")
    @js.native
    def number(value: js.Any): /* is number */ Boolean = js.native
    
    @JSImport("is-lite", "default.numericString")
    @js.native
    def numericString(value: js.Any): /* is string */ Boolean = js.native
    
    @JSImport("is-lite", "default.oneOf")
    @js.native
    def oneOf(target: js.Array[_], value: js.Any): Boolean = js.native
    
    @JSImport("is-lite", "default.plainObject")
    @js.native
    def plainObject(value: js.Any): /* is is-lite.is-lite.IPlainObject */ Boolean = js.native
    
    @JSImport("is-lite", "default.promise")
    @js.native
    def promise(value: js.Any): /* is std.Promise<unknown> */ Boolean = js.native
    
    @JSImport("is-lite", "default.propertyOf")
    @js.native
    def propertyOf(target: js.Object, key: String): Boolean = js.native
    @JSImport("is-lite", "default.propertyOf")
    @js.native
    def propertyOf(target: js.Object, key: String, predicate: js.Function1[/* v */ js.Any, Boolean]): Boolean = js.native
    
    @JSImport("is-lite", "default.regexp")
    @js.native
    def regexp(value: js.Any): /* is std.RegExp */ Boolean = js.native
    
    @JSImport("is-lite", "default.set")
    @js.native
    def set(value: js.Any): /* is std.Set<object> */ Boolean = js.native
    
    @JSImport("is-lite", "default.string")
    @js.native
    def string(value: js.Any): /* is string */ Boolean = js.native
    
    @JSImport("is-lite", "default.symbol")
    @js.native
    def symbol(value: js.Any): /* is symbol */ Boolean = js.native
    
    @JSImport("is-lite", "default.undefined")
    @js.native
    def undefined(value: js.Any): /* is undefined */ Boolean = js.native
    
    @JSImport("is-lite", "default.weakMap")
    @js.native
    def weakMap(value: js.Any): /* is std.WeakMap<object, unknown> */ Boolean = js.native
    
    @JSImport("is-lite", "default.weakSet")
    @js.native
    def weakSet(value: js.Any): /* is std.WeakSet<object> */ Boolean = js.native
    
    @JSImport("is-lite", "default.null")
    @js.native
    def `null`(value: js.Any): /* is null */ Boolean = js.native
    
    @JSImport("is-lite", "default.object")
    @js.native
    def `object`(value: js.Any): /* is object */ Boolean = js.native
  }
  
  @JSImport("is-lite", "getObjectType")
  @js.native
  def getObjectType(value: js.Any): String = js.native
  
  type Class[T] = Instantiable1[/* args (repeated) */ js.Any, T]
  
  type IPlainObject = StringDictionary[js.Any]
  
  /* Rewritten from type alias, can be one of: 
    - typingsSlinky.isLite.isLiteStrings.Array
    - typingsSlinky.isLite.isLiteStrings.AsyncFunction
    - typingsSlinky.isLite.isLiteStrings.bigint
    - typingsSlinky.isLite.isLiteStrings.boolean
    - typingsSlinky.isLite.isLiteStrings.Date
    - typingsSlinky.isLite.isLiteStrings.Error
    - typingsSlinky.isLite.isLiteStrings.Function
    - typingsSlinky.isLite.isLiteStrings.Generator
    - typingsSlinky.isLite.isLiteStrings.GeneratorFunction
    - typingsSlinky.isLite.isLiteStrings.Iterable
    - typingsSlinky.isLite.isLiteStrings.Map
    - typingsSlinky.isLite.isLiteStrings.`null`
    - typingsSlinky.isLite.isLiteStrings.number
    - typingsSlinky.isLite.isLiteStrings.Object
    - typingsSlinky.isLite.isLiteStrings.Promise
    - typingsSlinky.isLite.isLiteStrings.RegExp
    - typingsSlinky.isLite.isLiteStrings.Set
    - typingsSlinky.isLite.isLiteStrings.string
    - typingsSlinky.isLite.isLiteStrings.symbol
    - typingsSlinky.isLite.isLiteStrings.undefined
    - typingsSlinky.isLite.isLiteStrings.WeakMap
    - typingsSlinky.isLite.isLiteStrings.WeakSet
  */
  trait Types extends StObject
  object Types {
    
    @scala.inline
    def array: Array = "Array".asInstanceOf[Array]
    
    @scala.inline
    def asyncFunction: AsyncFunction = "AsyncFunction".asInstanceOf[AsyncFunction]
    
    @scala.inline
    def bigint: typingsSlinky.isLite.isLiteStrings.bigint = "bigint".asInstanceOf[typingsSlinky.isLite.isLiteStrings.bigint]
    
    @scala.inline
    def boolean: typingsSlinky.isLite.isLiteStrings.boolean = "boolean".asInstanceOf[typingsSlinky.isLite.isLiteStrings.boolean]
    
    @scala.inline
    def date: Date = "Date".asInstanceOf[Date]
    
    @scala.inline
    def error: Error = "Error".asInstanceOf[Error]
    
    @scala.inline
    def function: Function = "Function".asInstanceOf[Function]
    
    @scala.inline
    def generator: Generator = "Generator".asInstanceOf[Generator]
    
    @scala.inline
    def generatorFunction: GeneratorFunction = "GeneratorFunction".asInstanceOf[GeneratorFunction]
    
    @scala.inline
    def iterable: Iterable = "Iterable".asInstanceOf[Iterable]
    
    @scala.inline
    def map: Map = "Map".asInstanceOf[Map]
    
    @scala.inline
    def `null`: typingsSlinky.isLite.isLiteStrings.`null` = "null".asInstanceOf[typingsSlinky.isLite.isLiteStrings.`null`]
    
    @scala.inline
    def number: typingsSlinky.isLite.isLiteStrings.number = "number".asInstanceOf[typingsSlinky.isLite.isLiteStrings.number]
    
    @scala.inline
    def `object`: Object = "Object".asInstanceOf[Object]
    
    @scala.inline
    def promise: Promise = "Promise".asInstanceOf[Promise]
    
    @scala.inline
    def regExp: RegExp = "RegExp".asInstanceOf[RegExp]
    
    @scala.inline
    def set: Set = "Set".asInstanceOf[Set]
    
    @scala.inline
    def string: typingsSlinky.isLite.isLiteStrings.string = "string".asInstanceOf[typingsSlinky.isLite.isLiteStrings.string]
    
    @scala.inline
    def symbol: typingsSlinky.isLite.isLiteStrings.symbol = "symbol".asInstanceOf[typingsSlinky.isLite.isLiteStrings.symbol]
    
    @scala.inline
    def undefined: typingsSlinky.isLite.isLiteStrings.undefined = "undefined".asInstanceOf[typingsSlinky.isLite.isLiteStrings.undefined]
    
    @scala.inline
    def weakMap: WeakMap = "WeakMap".asInstanceOf[WeakMap]
    
    @scala.inline
    def weakSet: WeakSet = "WeakSet".asInstanceOf[WeakSet]
  }
}
