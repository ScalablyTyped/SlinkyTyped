package typingsSlinky.mixpanel

import org.scalablytyped.runtime.StringDictionary
import org.scalajs.dom.raw.Element
import typingsSlinky.mixpanel.Mixpanel.Config
import typingsSlinky.mixpanel.Mixpanel.People
import typingsSlinky.mixpanel.Mixpanel.Query
import typingsSlinky.mixpanel.mixpanelStrings.cookie
import typingsSlinky.mixpanel.mixpanelStrings.localStorage
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

@js.native
trait Mixpanel extends StObject {
  
  /**
    * Create an alias, which Mixpanel will use to link two distinct_ids going forward (not retroactively).
    * Multiple aliases can map to the same original ID, but not vice-versa. Aliases can also be chained - the
    * following is a valid scenario:
    *
    *     mixpanel.alias('new_id', 'existing_id');
    *     ...
    *     mixpanel.alias('newer_id', 'new_id');
    *
    * If the original ID is not passed in, we will use the current distinct_id - probably the auto-generated GUID.
    *
    * ### Notes:
    *
    * The best practice is to call `alias()` when a unique ID is first created for a user
    * (e.g., when a user first registers for an account and provides an email address).
    * `alias()` should never be called more than once for a given user, except to
    * chain a newer ID to a previously new ID, as described above.
    *
    * @param alias A unique identifier that you want to use for this user in the future.
    * @param currentId The current identifier being used for this user.
    */
  def alias(alias: String): Unit = js.native
  def alias(alias: String, currentId: String): Unit = js.native
  
  /**
    * Disable events on the Mixpanel object. If passed no arguments,
    * this function disables tracking of any event. If passed an
    * array of event names, those events will be disabled, but other
    * events will continue to be tracked.
    *
    * Note: this function does not stop other mixpanel functions from
    * firing, such as `register()` or `people.set()`.
    *
    * @param events An array of event names to disable
    */
  def disable(): Unit = js.native
  def disable(events: js.Array[String]): Unit = js.native
  
  /**
    * Returns the current config object for the library.
    */
  def get_config(): Config = js.native
  
  /**
    * Returns the current distinct id of the user. This is either the id automatically
    * generated by the library or the id that has been passed by a call to `identify()`.
    *
    * ### Notes:
    *
    * `get_distinct_id()` can only be called after the Mixpanel library has finished loading.
    * `init()` has a loaded function available to handle this automatically. For example:
    *
    *     // set distinct_id after the mixpanel library has loaded
    *     mixpanel.init('YOUR PROJECT TOKEN', {
    *         loaded: function(mixpanel) {
    *             distinct_id = mixpanel.get_distinct_id();
    *         }
    *     });
    */
  def get_distinct_id(): String = js.native
  
  /**
    * Returns the value of the super property named property_name. If no such
    * property is set, `get_property()` will return the undefined value.
    *
    * ### Notes:
    *
    * `get_property()` can only be called after the Mixpanel library has finished loading.
    * `init()` has a loaded function available to handle this automatically. For example:
    *
    *     // grab value for 'user_id' after the mixpanel library has loaded
    *     mixpanel.init('YOUR PROJECT TOKEN', {
    *         loaded: function(mixpanel) {
    *             user_id = mixpanel.get_property('user_id');
    *         }
    *     });
    *
    * @param propertyName The name of the super property you want to retrieve
    */
  def get_property(propertyName: String): js.Any = js.native
  
  /**
    * Identify a user with a unique ID. All subsequent
    * actions caused by this user will be tied to this unique ID. This
    * property is used to track unique visitors. If the method is
    * never called, then unique visitors will be identified by a UUID
    * generated the first time they visit the site.
    *
    * ### Notes:
    *
    * You can call this function to overwrite a previously set
    * unique ID for the current user. Mixpanel cannot translate
    * between IDs at this time, so when you change a user's ID
    * they will appear to be a new user.
    *
    * `identify()` should not be called to link anonymous activity to
    * subsequent activity when a unique ID is first assigned.
    * Use `alias()` when a unique ID is first assigned (registration), and
    * use `identify()` to identify the user with that unique ID on an ongoing
    * basis (e.g., each time a user logs in after registering).
    * Do not call `identify()` at the same time as `alias()`.
    *
    * @param unique_id A string that uniquely identifies a user. If not provided, the distinct_id currently in the persistent store (cookie or localStorage) will be used.
    */
  def identify(): Unit = js.native
  def identify(uniqueId: String): Unit = js.native
  
  /**
    * This function initializes a new instance of the Mixpanel tracking object.
    * All new instances are added to the main mixpanel object as sub properties (such as
    * mixpanel.library_name) and also returned by this function. To define a
    * second instance on the page, you would call:
    *
    *     mixpanel.init('new token', { your: 'config' }, 'library_name');
    *
    * and use it like so:
    *
    *     mixpanel.library_name.track(...);
    *
    * @param token Your Mixpanel API token
    * @param config A dictionary of config options to override
    * @param libraryName The name for the new mixpanel instance that you want created
    */
  def init(token: String): Mixpanel = js.native
  def init(token: String, config: js.UndefOr[scala.Nothing], libraryName: String): Mixpanel = js.native
  def init(token: String, config: Config): Mixpanel = js.native
  def init(token: String, config: Config, libraryName: String): Mixpanel = js.native
  
  var people: People = js.native
  
  /**
    * `push()` keeps the standard async-array-push
    * behavior around after the lib is loaded.
    * This is only useful for external integrations that
    * do not wish to rely on our convenience methods
    * (created in the snippet).
    *
    * ### Usage:
    *     mixpanel.push(['register', { a: 'b' }]);
    *
    * @param item A [function_name, args...] array to be executed
    */
  def push(item: js.Array[_]): Unit = js.native
  
  /**
    * Register a set of super properties, which are included with all
    * events. This will overwrite previous super property values.
    *
    * ### Usage:
    *
    *     // register 'Gender' as a super property
    *     mixpanel.register({'Gender': 'Female'});
    *
    *     // register several super properties when a user signs up
    *     mixpanel.register({
    *         'Email': 'jdoe@example.com',
    *         'Account Type': 'Free'
    *     });
    *
    * @param properties An associative array of properties to store about the user
    * @param days How many days since the user's last visit to store the super properties
    */
  def register(properties: StringDictionary[js.Any]): Unit = js.native
  def register(properties: StringDictionary[js.Any], days: Double): Unit = js.native
  
  /**
    * Register a set of super properties only once. This will not
    * overwrite previous super property values, unlike `register()`.
    *
    * ### Usage:
    *
    *     // register a super property for the first time only
    *     mixpanel.register_once({
    *         'First Login Date': new Date().toISOString()
    *     });
    *
    * ### Notes:
    *
    * If default_value is specified, current super properties
    * with that value will be overwritten.
    *
    * @param properties An associative array of properties to store about the user
    * @param defaultValue Value to override if already set in super properties (ex: 'False') Default: 'None'
    * @param days How many days since the users last visit to store the super properties
    */
  def register_once(properties: StringDictionary[js.Any]): Unit = js.native
  def register_once(properties: StringDictionary[js.Any], defaultValue: js.UndefOr[scala.Nothing], days: Double): Unit = js.native
  def register_once(properties: StringDictionary[js.Any], defaultValue: String): Unit = js.native
  def register_once(properties: StringDictionary[js.Any], defaultValue: String, days: Double): Unit = js.native
  
  /**
    * Clears super properties and generates a new random `distinct_id` for this instance.
    * Useful for clearing data when a user logs out.
    */
  def reset(): Unit = js.native
  
  /**
    * Update the configuration of a mixpanel library instance.
    *
    * @param config A dictionary of new configuration values to update
    */
  def set_config(config: Config): Unit = js.native
  
  /**
    * Time an event by including the time between this call and a
    * later `track` call for the same event in the properties sent
    * with the event.
    *
    * ### Usage:
    *
    *     // time an event named 'Registered'
    *     mixpanel.time_event('Registered');
    *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});
    *
    * When called for a particular event name, the next track call for that event
    * name will include the elapsed time between the `time_event` and `track`
    * calls. This value is stored as seconds in the `$duration` property.
    *
    * @param eventName The name of the event.
    */
  def time_event(eventName: String): Unit = js.native
  
  /**
    * Track an event. This is the most important and
    * frequently used Mixpanel function.
    *
    * ### Usage:
    *
    *     // track an event named 'Registered'
    *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});
    *
    * To track link clicks or form submissions, see `track_links()` or `track_forms()`.
    *
    * @param eventName The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.
    * @param properties A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.
    * @param callback If provided, the callback function will be called after tracking the event.
    */
  def track(eventName: String): Unit = js.native
  def track(eventName: String, properties: js.UndefOr[scala.Nothing], callback: js.Function0[Unit]): Unit = js.native
  def track(eventName: String, properties: StringDictionary[js.Any]): Unit = js.native
  def track(eventName: String, properties: StringDictionary[js.Any], callback: js.Function0[Unit]): Unit = js.native
  
  /**
    * Track form submissions. Selector must be a valid query.
    *
    * ### Usage:
    *
    *     // track submission for form id 'register'
    *     mixpanel.track_forms('#register', 'Created Account');
    *
    * ### Notes:
    *
    * This function will wait up to 300 ms for the mixpanel
    * servers to respond, if they have not responded by that time
    * it will head to the link without ensuring that your event
    * has been tracked.  To configure this timeout please see the
    * `set_config()` documentation below.
    *
    * If you pass a function in as the properties argument, the
    * function will receive the `DOMElement` that triggered the
    * event as an argument.  You are expected to return an object
    * from the function; any properties defined on this object
    * will be sent to mixpanel as event properties.
    *
    * @param querySelector A valid DOM query, element or jQuery-esque list
    * @param eventName The name of the event to track
    * @param properties This can be a set of properties, or a function that returns a set of properties after being passed a DOMElement
    */
  def track_forms(querySelector: Query, eventName: String): Unit = js.native
  def track_forms(querySelector: Query, eventName: String, properties: StringDictionary[js.Any]): Unit = js.native
  
  /**
    * Track clicks on a set of document elements. Selector must be a
    * valid query. Elements must exist on the page at the time `track_links` is called.
    *
    * ### Usage:
    *
    *     // track click for link id #nav
    *     mixpanel.track_links('#nav', 'Clicked Nav Link');
    *
    * ### Notes:
    *
    * This function will wait up to 300 ms for the Mixpanel
    * servers to respond. If they have not responded by that time
    * it will head to the link without ensuring that your event
    * has been tracked.  To configure this timeout please see the
    * `set_config()` documentation below.
    *
    * If you pass a function in as the properties argument, the
    * function will receive the DOMElement that triggered the
    * event as an argument.  You are expected to return an object
    * from the function; any properties defined on this object
    * will be sent to mixpanel as event properties.
    *
    * @param querySelector A valid DOM query, element or jQuery-esque list
    * @param eventName The name of the event to track
    * @param properties A properties object or function that returns a dictionary of properties when passed a DOMElement
    */
  def track_links(querySelector: Query, eventName: String): Unit = js.native
  def track_links(querySelector: Query, eventName: String, properties: StringDictionary[js.Any]): Unit = js.native
  
  /**
    * Delete a super property stored with the current user.
    *
    * @param propertyName The name of the super property to remove
    */
  def unregister(propertyName: String): Unit = js.native
}
object Mixpanel {
  
  @js.native
  trait Config extends StObject {
    
    /**
      * @default HTTP_PROTOCOL + 'api.mixpanel.com'
      */
    var api_host: js.UndefOr[String] = js.native
    
    /**
      * @default HTTP_PROTOCOL + 'mixpanel.com'
      */
    var app_host: js.UndefOr[String] = js.native
    
    /**
      * @default true
      */
    var autotrack: js.UndefOr[Boolean] = js.native
    
    /**
      * @default HTTP_PROTOCOL + 'cdn.mxpnl.com'
      */
    var cdn: js.UndefOr[String] = js.native
    
    /**
      * Super properties cookie expiration (in days)
      *
      * @default 365
      */
    var cookie_expiration: js.UndefOr[Double] = js.native
    
    /**
      * @deprecated Use `persistence_name` instead
      * @default ''
      */
    var cookie_name: js.UndefOr[String] = js.native
    
    /**
      * Super properties span subdomains
      *
      * @default true
      */
    var cross_subdomain_cookie: js.UndefOr[Boolean] = js.native
    
    /**
      * Debug mode
      *
      * @default false
      */
    var debug: js.UndefOr[Boolean] = js.native
    
    /**
      * @deprecated Use `disable_persistence` instead
      * @default false
      */
    var disable_cookie: js.UndefOr[Boolean] = js.native
    
    /**
      * If this is true, the mixpanel cookie or localStorage entry
      * will be deleted, and no user persistence will take place
      *
      * @default false
      */
    var disable_persistence: js.UndefOr[Boolean] = js.native
    
    /**
      * @default false
      */
    var img: js.UndefOr[Boolean] = js.native
    
    /**
      * If this is true, Mixpanel will automatically determine City,
      * Region and Country data using the IP address of the client
      *
      * @default true
      */
    var ip: js.UndefOr[Boolean] = js.native
    
    /**
      * @default function() {}
      */
    var loaded: js.UndefOr[js.Function1[/* lib */ Mixpanel, Unit]] = js.native
    
    /**
      * Type of persistent store for super properties
      *
      * If set to 'localStorage', any existing mixpanel cookie
      * value with the same `persistence_name` will be transferred
      * to localStorage and deleted.
      *
      * @default 'cookie'
      */
    var persistence: js.UndefOr[localStorage | cookie] = js.native
    
    /**
      * Name for super properties persistent store
      *
      * @default ''
      */
    var persistence_name: js.UndefOr[String] = js.native
    
    /**
      * Names of (super) properties which should never be sent
      * with track() calls
      *
      * @default []
      */
    var property_blacklist: js.UndefOr[js.Array[String]] = js.native
    
    /**
      * @default true
      */
    var save_referrer: js.UndefOr[Boolean] = js.native
    
    /**
      * If this is true, mixpanel cookies will be marked as secure,
      * meaning they will only be transmitted over https
      *
      * @default false
      */
    var secure_cookie: js.UndefOr[Boolean] = js.native
    
    /**
      * @default true
      */
    var store_google: js.UndefOr[Boolean] = js.native
    
    /**
      * @default false
      */
    var test: js.UndefOr[Boolean] = js.native
    
    /**
      * The amount of time track_links will wait for Mixpanel's
      * servers to respond
      *
      * @default 300
      */
    var track_links_timeout: js.UndefOr[Double] = js.native
    
    /**
      * Should we track a page view on page load
      *
      * @default true
      */
    var track_pageview: js.UndefOr[Boolean] = js.native
    
    /**
      * If you set upgrade to be true, the library will check for
      * a cookie from our old js library and import super
      * properties from it, then the old cookie is deleted
      * The upgrade config option only works in the initialization,
      * so make sure you set it when you create the library.
      *
      * @default false
      */
    var upgrade: js.UndefOr[Boolean] = js.native
    
    /**
      * @default false
      */
    var verbose: js.UndefOr[Boolean] = js.native
  }
  object Config {
    
    @scala.inline
    def apply(): Config = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[Config]
    }
    
    @scala.inline
    implicit class ConfigMutableBuilder[Self <: Config] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setApi_host(value: String): Self = StObject.set(x, "api_host", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setApi_hostUndefined: Self = StObject.set(x, "api_host", js.undefined)
      
      @scala.inline
      def setApp_host(value: String): Self = StObject.set(x, "app_host", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setApp_hostUndefined: Self = StObject.set(x, "app_host", js.undefined)
      
      @scala.inline
      def setAutotrack(value: Boolean): Self = StObject.set(x, "autotrack", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAutotrackUndefined: Self = StObject.set(x, "autotrack", js.undefined)
      
      @scala.inline
      def setCdn(value: String): Self = StObject.set(x, "cdn", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCdnUndefined: Self = StObject.set(x, "cdn", js.undefined)
      
      @scala.inline
      def setCookie_expiration(value: Double): Self = StObject.set(x, "cookie_expiration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCookie_expirationUndefined: Self = StObject.set(x, "cookie_expiration", js.undefined)
      
      @scala.inline
      def setCookie_name(value: String): Self = StObject.set(x, "cookie_name", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCookie_nameUndefined: Self = StObject.set(x, "cookie_name", js.undefined)
      
      @scala.inline
      def setCross_subdomain_cookie(value: Boolean): Self = StObject.set(x, "cross_subdomain_cookie", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCross_subdomain_cookieUndefined: Self = StObject.set(x, "cross_subdomain_cookie", js.undefined)
      
      @scala.inline
      def setDebug(value: Boolean): Self = StObject.set(x, "debug", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDebugUndefined: Self = StObject.set(x, "debug", js.undefined)
      
      @scala.inline
      def setDisable_cookie(value: Boolean): Self = StObject.set(x, "disable_cookie", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDisable_cookieUndefined: Self = StObject.set(x, "disable_cookie", js.undefined)
      
      @scala.inline
      def setDisable_persistence(value: Boolean): Self = StObject.set(x, "disable_persistence", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDisable_persistenceUndefined: Self = StObject.set(x, "disable_persistence", js.undefined)
      
      @scala.inline
      def setImg(value: Boolean): Self = StObject.set(x, "img", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImgUndefined: Self = StObject.set(x, "img", js.undefined)
      
      @scala.inline
      def setIp(value: Boolean): Self = StObject.set(x, "ip", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setIpUndefined: Self = StObject.set(x, "ip", js.undefined)
      
      @scala.inline
      def setLoaded(value: /* lib */ Mixpanel => Unit): Self = StObject.set(x, "loaded", js.Any.fromFunction1(value))
      
      @scala.inline
      def setLoadedUndefined: Self = StObject.set(x, "loaded", js.undefined)
      
      @scala.inline
      def setPersistence(value: localStorage | cookie): Self = StObject.set(x, "persistence", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPersistenceUndefined: Self = StObject.set(x, "persistence", js.undefined)
      
      @scala.inline
      def setPersistence_name(value: String): Self = StObject.set(x, "persistence_name", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPersistence_nameUndefined: Self = StObject.set(x, "persistence_name", js.undefined)
      
      @scala.inline
      def setProperty_blacklist(value: js.Array[String]): Self = StObject.set(x, "property_blacklist", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setProperty_blacklistUndefined: Self = StObject.set(x, "property_blacklist", js.undefined)
      
      @scala.inline
      def setProperty_blacklistVarargs(value: String*): Self = StObject.set(x, "property_blacklist", js.Array(value :_*))
      
      @scala.inline
      def setSave_referrer(value: Boolean): Self = StObject.set(x, "save_referrer", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSave_referrerUndefined: Self = StObject.set(x, "save_referrer", js.undefined)
      
      @scala.inline
      def setSecure_cookie(value: Boolean): Self = StObject.set(x, "secure_cookie", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSecure_cookieUndefined: Self = StObject.set(x, "secure_cookie", js.undefined)
      
      @scala.inline
      def setStore_google(value: Boolean): Self = StObject.set(x, "store_google", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setStore_googleUndefined: Self = StObject.set(x, "store_google", js.undefined)
      
      @scala.inline
      def setTest(value: Boolean): Self = StObject.set(x, "test", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTestUndefined: Self = StObject.set(x, "test", js.undefined)
      
      @scala.inline
      def setTrack_links_timeout(value: Double): Self = StObject.set(x, "track_links_timeout", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTrack_links_timeoutUndefined: Self = StObject.set(x, "track_links_timeout", js.undefined)
      
      @scala.inline
      def setTrack_pageview(value: Boolean): Self = StObject.set(x, "track_pageview", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTrack_pageviewUndefined: Self = StObject.set(x, "track_pageview", js.undefined)
      
      @scala.inline
      def setUpgrade(value: Boolean): Self = StObject.set(x, "upgrade", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUpgradeUndefined: Self = StObject.set(x, "upgrade", js.undefined)
      
      @scala.inline
      def setVerbose(value: Boolean): Self = StObject.set(x, "verbose", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setVerboseUndefined: Self = StObject.set(x, "verbose", js.undefined)
    }
  }
  
  @js.native
  trait People extends StObject {
    
    def append(keys: StringDictionary[js.Any]): Unit = js.native
    def append(keys: StringDictionary[js.Any], callback: js.Function0[Unit]): Unit = js.native
    /**
      * Append a value to a list-valued people analytics property.
      *
      * ### Usage:
      *
      *     // append a value to a list, creating it if needed
      *     mixpanel.people.append('pages_visited', 'homepage');
      *
      *     // like mixpanel.people.set(), you can append multiple
      *     // properties at once:
      *     mixpanel.people.append({
      *         list1: 'bob',
      *         list2: 123
      *     });
      *
      * @param prop If a string, this is the name of the property. If an object, this is an associative array of names and values.
      * @param value An item to append to the list
      * @param callback If provided, the callback will be called after the tracking event
      */
    def append(prop: String, value: js.Any): Unit = js.native
    def append(prop: String, value: js.Any, callback: js.Function0[Unit]): Unit = js.native
    
    /**
      * Permanently clear all revenue report transactions from the
      * current user's people analytics profile.
      *
      * ### Usage:
      *
      *     mixpanel.people.clear_charges();
      *
      * @param callback If provided, the callback will be called after the tracking event
      */
    def clear_charges(): Unit = js.native
    def clear_charges(callback: js.Function0[Unit]): Unit = js.native
    
    /**
      * Permanently deletes the current people analytics profile from
      * Mixpanel (using the current `distinct_id`).
      *
      * ### Usage:
      *
      *     // remove the all data you have stored about the current user
      *     mixpanel.people.delete_user();
      *
      */
    def delete_user(): Unit = js.native
    
    def increment(keys: StringDictionary[Double]): Unit = js.native
    def increment(keys: StringDictionary[Double], callback: js.Function0[Unit]): Unit = js.native
    /**
      * Increment/decrement numeric people analytics properties.
      *
      * ### Usage:
      *
      *     mixpanel.people.increment('page_views', 1);
      *
      *     // or, for convenience, if you're just incrementing a counter by
      *     // 1, you can simply do
      *     mixpanel.people.increment('page_views');
      *
      *     // to decrement a counter, pass a negative number
      *     mixpanel.people.increment('credits_left', -1);
      *
      *     // like mixpanel.people.set(), you can increment multiple
      *     // properties at once:
      *     mixpanel.people.increment({
      *         counter1: 1,
      *         counter2: 6
      *     });
      *
      * @param prop If a string, this is the name of the property. If an object, this is an associative array of names and numeric values.
      * @param value An amount to increment the given property
      * @param callback If provided, the callback will be called after the tracking event
      */
    def increment(prop: String): Unit = js.native
    def increment(prop: String, value: js.UndefOr[scala.Nothing], callback: js.Function0[Unit]): Unit = js.native
    def increment(prop: String, value: Double): Unit = js.native
    def increment(prop: String, value: Double, callback: js.Function0[Unit]): Unit = js.native
    
    def set(keys: StringDictionary[js.Any]): Unit = js.native
    def set(keys: StringDictionary[js.Any], callback: js.Function0[Unit]): Unit = js.native
    /**
      * Set properties on a user record.
      *
      * ### Usage:
      *
      *     mixpanel.people.set('gender', 'm');
      *
      *     // or set multiple properties at once
      *     mixpanel.people.set({
      *         'Company': 'Acme',
      *         'Plan': 'Premium',
      *         'Upgrade date': new Date()
      *     });
      *     // properties can be strings, integers, dates, or lists
      *
      * @param prop If a string, this is the name of the property. If an object, this is an associative array of names and values.
      * @param value A value to set on the given property name
      * @param callback If provided, the callback will be called after the tracking event
      */
    def set(prop: String, value: js.Any): Unit = js.native
    def set(prop: String, value: js.Any, callback: js.Function0[Unit]): Unit = js.native
    
    def set_once(keys: StringDictionary[js.Any]): Unit = js.native
    def set_once(keys: StringDictionary[js.Any], callback: js.Function0[Unit]): Unit = js.native
    /**
      * Set properties on a user record, only if they do not yet exist.
      * This will not overwrite previous people property values, unlike
      * `people.set()`.
      *
      * ### Usage:
      *
      *     mixpanel.people.set_once('First Login Date', new Date());
      *
      *     // or set multiple properties at once
      *     mixpanel.people.set_once({
      *         'First Login Date': new Date(),
      *         'Starting Plan': 'Premium'
      *     });
      *
      *     // properties can be strings, integers or dates
      *
      * @param prop If a string, this is the name of the property. If an object, this is an associative array of names and values.
      * @param value A value to set on the given property name
      * @param callback If provided, the callback will be called after the tracking event
      */
    def set_once(prop: String, value: js.Any): Unit = js.native
    def set_once(prop: String, value: js.Any, callback: js.Function0[Unit]): Unit = js.native
    
    /**
      * Record that you have charged the current user a certain amount
      * of money. Charges recorded with `track_charge()` will appear in the
      * Mixpanel revenue report.
      *
      * ### Usage:
      *
      *     // charge a user $50
      *     mixpanel.people.track_charge(50);
      *
      *     // charge a user $30.50 on the 2nd of january
      *     mixpanel.people.track_charge(30.50, {
      *         '$time': new Date('jan 1 2012')
      *     });
      *
      * @param amount The amount of money charged to the current user
      * @param properties An associative array of properties associated with the charge
      * @param callback If provided, the callback will be called when the server responds
      */
    def track_charge(amount: Double): Unit = js.native
    def track_charge(amount: Double, properties: js.UndefOr[scala.Nothing], callback: js.Function0[Unit]): Unit = js.native
    def track_charge(amount: Double, properties: StringDictionary[js.Any]): Unit = js.native
    def track_charge(amount: Double, properties: StringDictionary[js.Any], callback: js.Function0[Unit]): Unit = js.native
    
    def union(keys: StringDictionary[js.Any]): Unit = js.native
    def union(keys: StringDictionary[js.Any], callback: js.Function0[Unit]): Unit = js.native
    /**
      * Merge a given list with a list-valued people analytics property,
      * excluding duplicate values.
      *
      * ### Usage:
      *
      *     // merge a value to a list, creating it if needed
      *     mixpanel.people.union('pages_visited', 'homepage');
      *
      *     // like mixpanel.people.set(), you can append multiple
      *     // properties at once:
      *     mixpanel.people.union({
      *         list1: 'bob',
      *         list2: 123
      *     });
      *
      *     // like mixpanel.people.append(), you can append multiple
      *     // values to the same list:
      *     mixpanel.people.union({
      *         list1: ['bob', 'billy']
      *     });
      *
      * @param prop If a string, this is the name of the property. If an object, this is an associative array of names and values.
      * @param value Value / values to merge with the given property
      * @param callback If provided, the callback will be called after the tracking event
      */
    def union(prop: String, values: js.Any): Unit = js.native
    def union(prop: String, values: js.Any, callback: js.Function0[Unit]): Unit = js.native
    
    /**
      * Unset properties on a user record (permanently removes the properties and their values from a profile).
      *
      * ### Usage:
      *
      *     mixpanel.people.unset('gender');
      *
      *     // or unset multiple properties at once
      *     mixpanel.people.unset(['gender', 'Company']);
      *
      * @param prop If a string, this is the name of the property. If an array, this is a list of property names.
      * @param callback If provided, the callback will be called after the tracking event
      */
    def unset(prop: String): Unit = js.native
    def unset(prop: String, callback: js.Function0[Unit]): Unit = js.native
    def unset(prop: js.Array[String]): Unit = js.native
    def unset(prop: js.Array[String], callback: js.Function0[Unit]): Unit = js.native
  }
  
  type Query = String | Element | js.Array[Element]
}
