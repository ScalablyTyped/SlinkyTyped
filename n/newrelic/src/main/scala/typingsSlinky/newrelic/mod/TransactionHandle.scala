package typingsSlinky.newrelic.mod

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

@js.native
trait TransactionHandle extends js.Object {
  
  /**
    * Used to instrument the called service for inclusion in a distributed trace.
    *
    * Links the spans in a trace by accepting a payload generated by `insertDistributedTraceHeaders`
    * or generated by some other W3C Trace Context compliant tracer. This method accepts the headers
    * of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to
    * New Relic distributed trace headers.
    *
    * Check the docs for valid transport types. If an invalid type is provided, it will fall back to "Unknown".
    */
  def acceptDistributedTraceHeaders(transportType: String, headers: DistributedTraceHeaders): Unit = js.native
  
  /**
    * Parses incoming distributed trace header payload.
    * @deprecated - use acceptDistributedTraceHeaders instead
    */
  def acceptDistributedTracePayload(payload: DistributedTracePayload): Unit = js.native
  
  /**
    * Creates a distributed trace payload.
    * @deprecated - use insertDistributedTraceHeaders instead
    */
  def createDistributedTracePayload(): DistributedTracePayload = js.native
  
  /**
    * End the transaction.
    */
  def end(): Unit = js.native
  def end(callback: js.Function0[_]): Unit = js.native
  
  /**
    * Mark the transaction to be ignored.
    */
  def ignore(): Unit = js.native
  
  /**
    * Modifies the headers map that is passed in by adding W3C Trace Context headers
    * and New Relic Distributed Trace headers.
    */
  def insertDistributedTraceHeaders(headers: DistributedTraceHeaders): Unit = js.native
  
  /**
    * Return whether this Transaction is being sampled
    */
  def isSampled(): Boolean = js.native
}
