package typingsSlinky.firmata.mod

import typingsSlinky.firmata.anon.Address
import typingsSlinky.firmata.anon.Baud
import typingsSlinky.firmata.anon.Delay
import typingsSlinky.node.eventsMod.EventEmitter
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

/**
  * Most of these are generated by observing https://github.com/firmata/firmata.js/blob/v0.15.0/lib/firmata.js.
  *
  * This is a starting point that appeared to work fine for months within a project of my company, but I give no
  * guarantee that it cannot be improved.
  */
@js.native
trait Board extends EventEmitter {
  
  var HIGH: PIN_STATE = js.native
  
  var I2C_MODES: I2cModes = js.native
  
  var LOW: PIN_STATE = js.native
  
  var MODES: PinModes = js.native
  
  var SERIAL_MODES: SerialModes = js.native
  
  var SERIAL_PIN_TYPES: SerialPinTypes = js.native
  
  var SERIAL_PORT_IDs: SerialPortIds = js.native
  
  var STEPPER: StepperConstants = js.native
  
  // TODO untested/incomplete --- TWW
  /* protected */ def _sendOneWireRequest(
    pin: Double,
    subcommand: js.Any,
    device: js.Any,
    numBytesToRead: js.Any,
    correlationId: js.Any,
    delay: Double,
    dataToWrite: js.Any,
    event: js.Any,
    callback: js.Function0[Unit]
  ): Unit = js.native
  
  // TODO untested/incomplete --- TWW
  /* protected */ def _sendOneWireSearch(`type`: js.Any, event: js.Any, pin: Double, callback: js.Function0[Unit]): Unit = js.native
  
  var analogPins: js.Array[Double] = js.native
  
  def analogRead(pin: Double, callback: js.Function1[/* value */ Double, Unit]): Unit = js.native
  
  def analogWrite(pin: Double, value: Double): Unit = js.native
  
  def digitalRead(pin: Double, callback: js.Function1[/* val */ PIN_STATE, Unit]): Unit = js.native
  
  def digitalWrite(pin: Double, `val`: PIN_STATE): Unit = js.native
  
  var firmware: Firmware = js.native
  
  def getSamplingInterval(): Double = js.native
  
  // TODO untested --- TWW
  def i2cConfig(options: Double): Unit = js.native
  def i2cConfig(options: Delay): Unit = js.native
  
  def i2cRead(address: Double, bytesToRead: Double, callback: js.Function1[/* data */ js.Array[Double], Unit]): Unit = js.native
  // TODO untested --- TWW
  def i2cRead(
    address: Double,
    register: Double,
    bytesToRead: Double,
    callback: js.Function1[/* data */ js.Array[Double], Unit]
  ): Unit = js.native
  
  def i2cReadOnce(address: Double, bytesToRead: Double, callback: js.Function1[/* data */ js.Array[Double], Unit]): Unit = js.native
  // TODO untested --- TWW
  def i2cReadOnce(
    address: Double,
    register: Double,
    bytesToRead: Double,
    callback: js.Function1[/* data */ js.Array[Double], Unit]
  ): Unit = js.native
  
  // TODO untested --- TWW
  def i2cStop(options: Double): Unit = js.native
  def i2cStop(options: Address): Unit = js.native
  
  def i2cWrite(address: Double, data: js.Array[Double]): Unit = js.native
  // TODO untested --- TWW
  def i2cWrite(address: Double, register: Double, inBytes: js.Array[Double]): Unit = js.native
  
  // TODO untested --- TWW
  def i2cWriteReg(address: Double, register: Double, byte: Double): Unit = js.native
  
  def pinMode(pin: Double, mode: PIN_MODE): Unit = js.native
  
  // TODO untested/incomplete --- TWW
  def pingRead(opts: js.Any, callback: js.Function0[Unit]): Unit = js.native
  
  var pins: js.Array[Pins] = js.native
  
  var ports: js.Array[Double] = js.native
  
  def pwmWrite(pin: Double, value: Double): Unit = js.native
  
  def queryAnalogMapping(callback: js.Function0[Unit]): Unit = js.native
  
  def queryCapabilities(callback: js.Function0[Unit]): Unit = js.native
  
  def queryFirmware(callback: js.Function0[Unit]): Unit = js.native
  
  def queryPinState(pin: Double, callback: js.Function0[Unit]): Unit = js.native
  
  def reportAnalogPin(pin: Double, value: REPORTING): Unit = js.native
  
  def reportDigitalPin(pin: Double, value: REPORTING): Unit = js.native
  
  def reportVersion(callback: js.Function0[Unit]): Unit = js.native
  
  def reset(): Unit = js.native
  
  // TODO untested --- TWW
  def sendI2CConfig(delay: Double): Unit = js.native
  
  // TODO untested --- TWW
  def sendI2CReadRequest(address: Double, numBytes: Double, callback: js.Function0[Unit]): Unit = js.native
  
  // TODO untested --- TWW
  def sendI2CWriteRequest(slaveAddress: Double, bytes: js.Array[Double]): Unit = js.native
  
  // TODO untested --- TWW
  def sendOneWireAlarmsSearch(pin: Double, callback: js.Function0[Unit]): Unit = js.native
  
  // TODO untested --- TWW
  def sendOneWireConfig(pin: Double, enableParasiticPower: Boolean): Unit = js.native
  
  // TODO untested --- TWW
  def sendOneWireDelay(pin: Double, delay: Double): Unit = js.native
  
  // TODO untested --- TWW
  def sendOneWireRead(pin: Double, device: Double, numBytesToRead: Double, callback: js.Function0[Unit]): Unit = js.native
  
  // TODO untested --- TWW
  def sendOneWireReset(pin: Double): Unit = js.native
  
  // TODO untested --- TWW
  def sendOneWireSearch(pin: Double, callback: js.Function0[Unit]): Unit = js.native
  
  def sendOneWireWrite(pin: Double, device: Double, data: js.Array[Double]): Unit = js.native
  // TODO untested --- TWW
  def sendOneWireWrite(pin: Double, device: Double, data: Double): Unit = js.native
  
  def sendOneWireWriteAndRead(
    pin: Double,
    device: Double,
    data: js.Array[Double],
    numBytesToRead: Double,
    callback: js.Function2[/* error */ js.UndefOr[js.Error], /* data */ js.UndefOr[Double], Unit]
  ): Unit = js.native
  // TODO untested --- TWW
  def sendOneWireWriteAndRead(
    pin: Double,
    device: Double,
    data: Double,
    numBytesToRead: Double,
    callback: js.Function2[/* error */ js.UndefOr[js.Error], /* data */ js.UndefOr[Double], Unit]
  ): Unit = js.native
  
  // TODO untested --- TWW
  def sendString(str: String): Unit = js.native
  
  // TODO untested --- TWW
  def serialClose(portId: SERIAL_PORT_ID): Unit = js.native
  
  // TODO untested --- TWW
  def serialConfig(options: Baud): Unit = js.native
  
  // TODO untested --- TWW
  def serialFlush(portId: SERIAL_PORT_ID): Unit = js.native
  
  // TODO untested --- TWW
  def serialListen(portId: SERIAL_PORT_ID): Unit = js.native
  
  // TODO untested --- TWW
  def serialRead(portId: SERIAL_PORT_ID, maxBytesToRead: Double, callback: js.Function0[Unit]): Unit = js.native
  
  // TODO untested --- TWW
  def serialStop(portId: SERIAL_PORT_ID): Unit = js.native
  
  // TODO untested --- TWW
  def serialWrite(portId: SERIAL_PORT_ID, inBytes: js.Array[Double]): Unit = js.native
  
  def servoConfig(pin: Double, min: Double, max: Double): Unit = js.native
  
  def servoWrite(pin: Double, value: Double): Unit = js.native
  
  def setSamplingInterval(interval: Double): Unit = js.native
  
  var settings: Settings = js.native
  
  def stepperConfig(
    deviceNum: Double,
    `type`: Double,
    stepsPerRev: Double,
    dirOrMotor1Pin: Double,
    stepOrMotor2Pin: Double
  ): Unit = js.native
  def stepperConfig(
    deviceNum: Double,
    `type`: Double,
    stepsPerRev: Double,
    dirOrMotor1Pin: Double,
    stepOrMotor2Pin: Double,
    motor3Pin: js.UndefOr[scala.Nothing],
    motor4Pin: Double
  ): Unit = js.native
  def stepperConfig(
    deviceNum: Double,
    `type`: Double,
    stepsPerRev: Double,
    dirOrMotor1Pin: Double,
    stepOrMotor2Pin: Double,
    motor3Pin: Double
  ): Unit = js.native
  def stepperConfig(
    deviceNum: Double,
    `type`: Double,
    stepsPerRev: Double,
    dirOrMotor1Pin: Double,
    stepOrMotor2Pin: Double,
    motor3Pin: Double,
    motor4Pin: Double
  ): Unit = js.native
  
  def stepperStep(
    deviceNum: Double,
    direction: STEPPER_DIRECTION,
    steps: Double,
    speed: Double,
    accel: js.Function1[/* bool */ js.UndefOr[Boolean], Unit]
  ): Unit = js.native
  def stepperStep(
    deviceNum: Double,
    direction: STEPPER_DIRECTION,
    steps: Double,
    speed: Double,
    accel: js.Function1[/* bool */ js.UndefOr[Boolean], Unit],
    decel: js.UndefOr[scala.Nothing],
    callback: js.Function1[/* bool */ js.UndefOr[Boolean], Unit]
  ): Unit = js.native
  def stepperStep(
    deviceNum: Double,
    direction: STEPPER_DIRECTION,
    steps: Double,
    speed: Double,
    accel: js.Function1[/* bool */ js.UndefOr[Boolean], Unit],
    decel: Double
  ): Unit = js.native
  def stepperStep(
    deviceNum: Double,
    direction: STEPPER_DIRECTION,
    steps: Double,
    speed: Double,
    accel: js.Function1[/* bool */ js.UndefOr[Boolean], Unit],
    decel: Double,
    callback: js.Function1[/* bool */ js.UndefOr[Boolean], Unit]
  ): Unit = js.native
  def stepperStep(deviceNum: Double, direction: STEPPER_DIRECTION, steps: Double, speed: Double, accel: Double): Unit = js.native
  def stepperStep(
    deviceNum: Double,
    direction: STEPPER_DIRECTION,
    steps: Double,
    speed: Double,
    accel: Double,
    decel: js.UndefOr[scala.Nothing],
    callback: js.Function1[/* bool */ js.UndefOr[Boolean], Unit]
  ): Unit = js.native
  def stepperStep(
    deviceNum: Double,
    direction: STEPPER_DIRECTION,
    steps: Double,
    speed: Double,
    accel: Double,
    decel: Double
  ): Unit = js.native
  def stepperStep(
    deviceNum: Double,
    direction: STEPPER_DIRECTION,
    steps: Double,
    speed: Double,
    accel: Double,
    decel: Double,
    callback: js.Function1[/* bool */ js.UndefOr[Boolean], Unit]
  ): Unit = js.native
  
  // TODO untested --- TWW
  def sysexCommand(message: js.Array[Double]): Unit = js.native
  
  // TODO untested --- TWW
  def sysexResponse(commandByte: Double, handler: js.Function1[/* data */ js.Array[Double], Unit]): Unit = js.native
  
  var transport: typingsSlinky.serialport.mod.^ = js.native
  
  var version: Version = js.native
}
