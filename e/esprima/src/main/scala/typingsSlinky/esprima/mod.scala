package typingsSlinky.esprima

import typingsSlinky.esprima.esprimaStrings.ArrayExpression
import typingsSlinky.esprima.esprimaStrings.ArrayPattern
import typingsSlinky.esprima.esprimaStrings.ArrowFunctionExpression
import typingsSlinky.esprima.esprimaStrings.AssignmentExpression
import typingsSlinky.esprima.esprimaStrings.AssignmentPattern
import typingsSlinky.esprima.esprimaStrings.AwaitExpression
import typingsSlinky.esprima.esprimaStrings.BinaryExpression
import typingsSlinky.esprima.esprimaStrings.BlockStatement
import typingsSlinky.esprima.esprimaStrings.BreakStatement
import typingsSlinky.esprima.esprimaStrings.CallExpression
import typingsSlinky.esprima.esprimaStrings.CatchClause
import typingsSlinky.esprima.esprimaStrings.ClassBody
import typingsSlinky.esprima.esprimaStrings.ClassDeclaration
import typingsSlinky.esprima.esprimaStrings.ClassExpression
import typingsSlinky.esprima.esprimaStrings.ConditionalExpression
import typingsSlinky.esprima.esprimaStrings.ContinueStatement
import typingsSlinky.esprima.esprimaStrings.DebuggerStatement
import typingsSlinky.esprima.esprimaStrings.DoWhileStatement
import typingsSlinky.esprima.esprimaStrings.EmptyStatement
import typingsSlinky.esprima.esprimaStrings.ExportAllDeclaration
import typingsSlinky.esprima.esprimaStrings.ExportDefaultDeclaration
import typingsSlinky.esprima.esprimaStrings.ExportNamedDeclaration
import typingsSlinky.esprima.esprimaStrings.ExportSpecifier
import typingsSlinky.esprima.esprimaStrings.ExpressionStatement
import typingsSlinky.esprima.esprimaStrings.ForInStatement
import typingsSlinky.esprima.esprimaStrings.ForOfStatement
import typingsSlinky.esprima.esprimaStrings.ForStatement
import typingsSlinky.esprima.esprimaStrings.FunctionDeclaration
import typingsSlinky.esprima.esprimaStrings.FunctionExpression
import typingsSlinky.esprima.esprimaStrings.Identifier
import typingsSlinky.esprima.esprimaStrings.IfStatement
import typingsSlinky.esprima.esprimaStrings.Import
import typingsSlinky.esprima.esprimaStrings.ImportDeclaration
import typingsSlinky.esprima.esprimaStrings.ImportDefaultSpecifier
import typingsSlinky.esprima.esprimaStrings.ImportNamespaceSpecifier
import typingsSlinky.esprima.esprimaStrings.ImportSpecifier
import typingsSlinky.esprima.esprimaStrings.LabeledStatement
import typingsSlinky.esprima.esprimaStrings.Literal
import typingsSlinky.esprima.esprimaStrings.LogicalExpression
import typingsSlinky.esprima.esprimaStrings.MemberExpression
import typingsSlinky.esprima.esprimaStrings.MetaProperty
import typingsSlinky.esprima.esprimaStrings.MethodDefinition
import typingsSlinky.esprima.esprimaStrings.NewExpression
import typingsSlinky.esprima.esprimaStrings.ObjectExpression
import typingsSlinky.esprima.esprimaStrings.ObjectPattern
import typingsSlinky.esprima.esprimaStrings.Property
import typingsSlinky.esprima.esprimaStrings.RestElement
import typingsSlinky.esprima.esprimaStrings.ReturnStatement
import typingsSlinky.esprima.esprimaStrings.SequenceExpression
import typingsSlinky.esprima.esprimaStrings.SpreadElement
import typingsSlinky.esprima.esprimaStrings.Super
import typingsSlinky.esprima.esprimaStrings.SwitchCase
import typingsSlinky.esprima.esprimaStrings.SwitchStatement
import typingsSlinky.esprima.esprimaStrings.TaggedTemplateExpression
import typingsSlinky.esprima.esprimaStrings.TemplateElement
import typingsSlinky.esprima.esprimaStrings.TemplateLiteral
import typingsSlinky.esprima.esprimaStrings.ThisExpression
import typingsSlinky.esprima.esprimaStrings.ThrowStatement
import typingsSlinky.esprima.esprimaStrings.TryStatement
import typingsSlinky.esprima.esprimaStrings.UnaryExpression
import typingsSlinky.esprima.esprimaStrings.UpdateExpression
import typingsSlinky.esprima.esprimaStrings.VariableDeclaration
import typingsSlinky.esprima.esprimaStrings.VariableDeclarator
import typingsSlinky.esprima.esprimaStrings.WhileStatement
import typingsSlinky.esprima.esprimaStrings.WithStatement
import typingsSlinky.esprima.esprimaStrings.YieldExpression
import typingsSlinky.estree.estreeStrings.module
import typingsSlinky.estree.estreeStrings.script
import typingsSlinky.estree.mod.Directive
import typingsSlinky.estree.mod.ModuleDeclaration
import typingsSlinky.estree.mod.Node
import typingsSlinky.estree.mod.Statement
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  object Syntax {
    
    @JSImport("esprima", "Syntax")
    @js.native
    val ^ : js.Any = js.native
    
    @JSImport("esprima", "Syntax.ArrayExpression")
    @js.native
    def ArrayExpression: typingsSlinky.esprima.esprimaStrings.ArrayExpression = js.native
    @scala.inline
    def ArrayExpression_=(x: ArrayExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ArrayExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ArrayPattern")
    @js.native
    def ArrayPattern: typingsSlinky.esprima.esprimaStrings.ArrayPattern = js.native
    @scala.inline
    def ArrayPattern_=(x: ArrayPattern): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ArrayPattern")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ArrowFunctionExpression")
    @js.native
    def ArrowFunctionExpression: typingsSlinky.esprima.esprimaStrings.ArrowFunctionExpression = js.native
    @scala.inline
    def ArrowFunctionExpression_=(x: ArrowFunctionExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ArrowFunctionExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.AssignmentExpression")
    @js.native
    def AssignmentExpression: typingsSlinky.esprima.esprimaStrings.AssignmentExpression = js.native
    @scala.inline
    def AssignmentExpression_=(x: AssignmentExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AssignmentExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.AssignmentPattern")
    @js.native
    def AssignmentPattern: typingsSlinky.esprima.esprimaStrings.AssignmentPattern = js.native
    @scala.inline
    def AssignmentPattern_=(x: AssignmentPattern): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AssignmentPattern")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.AwaitExpression")
    @js.native
    def AwaitExpression: typingsSlinky.esprima.esprimaStrings.AwaitExpression = js.native
    @scala.inline
    def AwaitExpression_=(x: AwaitExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AwaitExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.BinaryExpression")
    @js.native
    def BinaryExpression: typingsSlinky.esprima.esprimaStrings.BinaryExpression = js.native
    @scala.inline
    def BinaryExpression_=(x: BinaryExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("BinaryExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.BlockStatement")
    @js.native
    def BlockStatement: typingsSlinky.esprima.esprimaStrings.BlockStatement = js.native
    @scala.inline
    def BlockStatement_=(x: BlockStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("BlockStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.BreakStatement")
    @js.native
    def BreakStatement: typingsSlinky.esprima.esprimaStrings.BreakStatement = js.native
    @scala.inline
    def BreakStatement_=(x: BreakStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("BreakStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.CallExpression")
    @js.native
    def CallExpression: typingsSlinky.esprima.esprimaStrings.CallExpression = js.native
    @scala.inline
    def CallExpression_=(x: CallExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CallExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.CatchClause")
    @js.native
    def CatchClause: typingsSlinky.esprima.esprimaStrings.CatchClause = js.native
    @scala.inline
    def CatchClause_=(x: CatchClause): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CatchClause")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ClassBody")
    @js.native
    def ClassBody: typingsSlinky.esprima.esprimaStrings.ClassBody = js.native
    @scala.inline
    def ClassBody_=(x: ClassBody): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ClassBody")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ClassDeclaration")
    @js.native
    def ClassDeclaration: typingsSlinky.esprima.esprimaStrings.ClassDeclaration = js.native
    @scala.inline
    def ClassDeclaration_=(x: ClassDeclaration): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ClassDeclaration")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ClassExpression")
    @js.native
    def ClassExpression: typingsSlinky.esprima.esprimaStrings.ClassExpression = js.native
    @scala.inline
    def ClassExpression_=(x: ClassExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ClassExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ConditionalExpression")
    @js.native
    def ConditionalExpression: typingsSlinky.esprima.esprimaStrings.ConditionalExpression = js.native
    @scala.inline
    def ConditionalExpression_=(x: ConditionalExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ConditionalExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ContinueStatement")
    @js.native
    def ContinueStatement: typingsSlinky.esprima.esprimaStrings.ContinueStatement = js.native
    @scala.inline
    def ContinueStatement_=(x: ContinueStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ContinueStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.DebuggerStatement")
    @js.native
    def DebuggerStatement: typingsSlinky.esprima.esprimaStrings.DebuggerStatement = js.native
    @scala.inline
    def DebuggerStatement_=(x: DebuggerStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DebuggerStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.DoWhileStatement")
    @js.native
    def DoWhileStatement: typingsSlinky.esprima.esprimaStrings.DoWhileStatement = js.native
    @scala.inline
    def DoWhileStatement_=(x: DoWhileStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DoWhileStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.EmptyStatement")
    @js.native
    def EmptyStatement: typingsSlinky.esprima.esprimaStrings.EmptyStatement = js.native
    @scala.inline
    def EmptyStatement_=(x: EmptyStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("EmptyStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ExportAllDeclaration")
    @js.native
    def ExportAllDeclaration: typingsSlinky.esprima.esprimaStrings.ExportAllDeclaration = js.native
    @scala.inline
    def ExportAllDeclaration_=(x: ExportAllDeclaration): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ExportAllDeclaration")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ExportDefaultDeclaration")
    @js.native
    def ExportDefaultDeclaration: typingsSlinky.esprima.esprimaStrings.ExportDefaultDeclaration = js.native
    @scala.inline
    def ExportDefaultDeclaration_=(x: ExportDefaultDeclaration): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ExportDefaultDeclaration")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ExportNamedDeclaration")
    @js.native
    def ExportNamedDeclaration: typingsSlinky.esprima.esprimaStrings.ExportNamedDeclaration = js.native
    @scala.inline
    def ExportNamedDeclaration_=(x: ExportNamedDeclaration): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ExportNamedDeclaration")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ExportSpecifier")
    @js.native
    def ExportSpecifier: typingsSlinky.esprima.esprimaStrings.ExportSpecifier = js.native
    @scala.inline
    def ExportSpecifier_=(x: ExportSpecifier): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ExportSpecifier")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ExpressionStatement")
    @js.native
    def ExpressionStatement: typingsSlinky.esprima.esprimaStrings.ExpressionStatement = js.native
    @scala.inline
    def ExpressionStatement_=(x: ExpressionStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ExpressionStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ForInStatement")
    @js.native
    def ForInStatement: typingsSlinky.esprima.esprimaStrings.ForInStatement = js.native
    @scala.inline
    def ForInStatement_=(x: ForInStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ForInStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ForOfStatement")
    @js.native
    def ForOfStatement: typingsSlinky.esprima.esprimaStrings.ForOfStatement = js.native
    @scala.inline
    def ForOfStatement_=(x: ForOfStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ForOfStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ForStatement")
    @js.native
    def ForStatement: typingsSlinky.esprima.esprimaStrings.ForStatement = js.native
    @scala.inline
    def ForStatement_=(x: ForStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ForStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.FunctionDeclaration")
    @js.native
    def FunctionDeclaration: typingsSlinky.esprima.esprimaStrings.FunctionDeclaration = js.native
    @scala.inline
    def FunctionDeclaration_=(x: FunctionDeclaration): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FunctionDeclaration")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.FunctionExpression")
    @js.native
    def FunctionExpression: typingsSlinky.esprima.esprimaStrings.FunctionExpression = js.native
    @scala.inline
    def FunctionExpression_=(x: FunctionExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FunctionExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.Identifier")
    @js.native
    def Identifier: typingsSlinky.esprima.esprimaStrings.Identifier = js.native
    @scala.inline
    def Identifier_=(x: Identifier): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("Identifier")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.IfStatement")
    @js.native
    def IfStatement: typingsSlinky.esprima.esprimaStrings.IfStatement = js.native
    @scala.inline
    def IfStatement_=(x: IfStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("IfStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.Import")
    @js.native
    def Import: typingsSlinky.esprima.esprimaStrings.Import = js.native
    
    @JSImport("esprima", "Syntax.ImportDeclaration")
    @js.native
    def ImportDeclaration: typingsSlinky.esprima.esprimaStrings.ImportDeclaration = js.native
    @scala.inline
    def ImportDeclaration_=(x: ImportDeclaration): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ImportDeclaration")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ImportDefaultSpecifier")
    @js.native
    def ImportDefaultSpecifier: typingsSlinky.esprima.esprimaStrings.ImportDefaultSpecifier = js.native
    @scala.inline
    def ImportDefaultSpecifier_=(x: ImportDefaultSpecifier): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ImportDefaultSpecifier")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ImportNamespaceSpecifier")
    @js.native
    def ImportNamespaceSpecifier: typingsSlinky.esprima.esprimaStrings.ImportNamespaceSpecifier = js.native
    @scala.inline
    def ImportNamespaceSpecifier_=(x: ImportNamespaceSpecifier): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ImportNamespaceSpecifier")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ImportSpecifier")
    @js.native
    def ImportSpecifier: typingsSlinky.esprima.esprimaStrings.ImportSpecifier = js.native
    @scala.inline
    def ImportSpecifier_=(x: ImportSpecifier): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ImportSpecifier")(x.asInstanceOf[js.Any])
    
    @scala.inline
    def Import_=(x: Import): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("Import")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.LabeledStatement")
    @js.native
    def LabeledStatement: typingsSlinky.esprima.esprimaStrings.LabeledStatement = js.native
    @scala.inline
    def LabeledStatement_=(x: LabeledStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("LabeledStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.Literal")
    @js.native
    def Literal: typingsSlinky.esprima.esprimaStrings.Literal = js.native
    @scala.inline
    def Literal_=(x: Literal): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("Literal")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.LogicalExpression")
    @js.native
    def LogicalExpression: typingsSlinky.esprima.esprimaStrings.LogicalExpression = js.native
    @scala.inline
    def LogicalExpression_=(x: LogicalExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("LogicalExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.MemberExpression")
    @js.native
    def MemberExpression: typingsSlinky.esprima.esprimaStrings.MemberExpression = js.native
    @scala.inline
    def MemberExpression_=(x: MemberExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MemberExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.MetaProperty")
    @js.native
    def MetaProperty: typingsSlinky.esprima.esprimaStrings.MetaProperty = js.native
    @scala.inline
    def MetaProperty_=(x: MetaProperty): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MetaProperty")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.MethodDefinition")
    @js.native
    def MethodDefinition: typingsSlinky.esprima.esprimaStrings.MethodDefinition = js.native
    @scala.inline
    def MethodDefinition_=(x: MethodDefinition): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MethodDefinition")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.NewExpression")
    @js.native
    def NewExpression: typingsSlinky.esprima.esprimaStrings.NewExpression = js.native
    @scala.inline
    def NewExpression_=(x: NewExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NewExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ObjectExpression")
    @js.native
    def ObjectExpression: typingsSlinky.esprima.esprimaStrings.ObjectExpression = js.native
    @scala.inline
    def ObjectExpression_=(x: ObjectExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ObjectExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ObjectPattern")
    @js.native
    def ObjectPattern: typingsSlinky.esprima.esprimaStrings.ObjectPattern = js.native
    @scala.inline
    def ObjectPattern_=(x: ObjectPattern): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ObjectPattern")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.Program")
    @js.native
    def Program: typingsSlinky.esprima.esprimaStrings.Program = js.native
    @scala.inline
    def Program_=(x: typingsSlinky.esprima.esprimaStrings.Program): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("Program")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.Property")
    @js.native
    def Property: typingsSlinky.esprima.esprimaStrings.Property = js.native
    @scala.inline
    def Property_=(x: Property): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("Property")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.RestElement")
    @js.native
    def RestElement: typingsSlinky.esprima.esprimaStrings.RestElement = js.native
    @scala.inline
    def RestElement_=(x: RestElement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RestElement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ReturnStatement")
    @js.native
    def ReturnStatement: typingsSlinky.esprima.esprimaStrings.ReturnStatement = js.native
    @scala.inline
    def ReturnStatement_=(x: ReturnStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ReturnStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.SequenceExpression")
    @js.native
    def SequenceExpression: typingsSlinky.esprima.esprimaStrings.SequenceExpression = js.native
    @scala.inline
    def SequenceExpression_=(x: SequenceExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SequenceExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.SpreadElement")
    @js.native
    def SpreadElement: typingsSlinky.esprima.esprimaStrings.SpreadElement = js.native
    @scala.inline
    def SpreadElement_=(x: SpreadElement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SpreadElement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.Super")
    @js.native
    def Super: typingsSlinky.esprima.esprimaStrings.Super = js.native
    @scala.inline
    def Super_=(x: Super): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("Super")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.SwitchCase")
    @js.native
    def SwitchCase: typingsSlinky.esprima.esprimaStrings.SwitchCase = js.native
    @scala.inline
    def SwitchCase_=(x: SwitchCase): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SwitchCase")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.SwitchStatement")
    @js.native
    def SwitchStatement: typingsSlinky.esprima.esprimaStrings.SwitchStatement = js.native
    @scala.inline
    def SwitchStatement_=(x: SwitchStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SwitchStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.TaggedTemplateExpression")
    @js.native
    def TaggedTemplateExpression: typingsSlinky.esprima.esprimaStrings.TaggedTemplateExpression = js.native
    @scala.inline
    def TaggedTemplateExpression_=(x: TaggedTemplateExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TaggedTemplateExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.TemplateElement")
    @js.native
    def TemplateElement: typingsSlinky.esprima.esprimaStrings.TemplateElement = js.native
    @scala.inline
    def TemplateElement_=(x: TemplateElement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TemplateElement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.TemplateLiteral")
    @js.native
    def TemplateLiteral: typingsSlinky.esprima.esprimaStrings.TemplateLiteral = js.native
    @scala.inline
    def TemplateLiteral_=(x: TemplateLiteral): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TemplateLiteral")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ThisExpression")
    @js.native
    def ThisExpression: typingsSlinky.esprima.esprimaStrings.ThisExpression = js.native
    @scala.inline
    def ThisExpression_=(x: ThisExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ThisExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.ThrowStatement")
    @js.native
    def ThrowStatement: typingsSlinky.esprima.esprimaStrings.ThrowStatement = js.native
    @scala.inline
    def ThrowStatement_=(x: ThrowStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ThrowStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.TryStatement")
    @js.native
    def TryStatement: typingsSlinky.esprima.esprimaStrings.TryStatement = js.native
    @scala.inline
    def TryStatement_=(x: TryStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TryStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.UnaryExpression")
    @js.native
    def UnaryExpression: typingsSlinky.esprima.esprimaStrings.UnaryExpression = js.native
    @scala.inline
    def UnaryExpression_=(x: UnaryExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("UnaryExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.UpdateExpression")
    @js.native
    def UpdateExpression: typingsSlinky.esprima.esprimaStrings.UpdateExpression = js.native
    @scala.inline
    def UpdateExpression_=(x: UpdateExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("UpdateExpression")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.VariableDeclaration")
    @js.native
    def VariableDeclaration: typingsSlinky.esprima.esprimaStrings.VariableDeclaration = js.native
    @scala.inline
    def VariableDeclaration_=(x: VariableDeclaration): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("VariableDeclaration")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.VariableDeclarator")
    @js.native
    def VariableDeclarator: typingsSlinky.esprima.esprimaStrings.VariableDeclarator = js.native
    @scala.inline
    def VariableDeclarator_=(x: VariableDeclarator): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("VariableDeclarator")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.WhileStatement")
    @js.native
    def WhileStatement: typingsSlinky.esprima.esprimaStrings.WhileStatement = js.native
    @scala.inline
    def WhileStatement_=(x: WhileStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("WhileStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.WithStatement")
    @js.native
    def WithStatement: typingsSlinky.esprima.esprimaStrings.WithStatement = js.native
    @scala.inline
    def WithStatement_=(x: WithStatement): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("WithStatement")(x.asInstanceOf[js.Any])
    
    @JSImport("esprima", "Syntax.YieldExpression")
    @js.native
    def YieldExpression: typingsSlinky.esprima.esprimaStrings.YieldExpression = js.native
    @scala.inline
    def YieldExpression_=(x: YieldExpression): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("YieldExpression")(x.asInstanceOf[js.Any])
  }
  
  @JSImport("esprima", "parseModule")
  @js.native
  def parseModule(input: String): Program = js.native
  @JSImport("esprima", "parseModule")
  @js.native
  def parseModule(
    input: String,
    config: js.UndefOr[scala.Nothing],
    delegate: js.Function2[/* node */ Node, /* meta */ js.Any, Unit]
  ): Program = js.native
  @JSImport("esprima", "parseModule")
  @js.native
  def parseModule(input: String, config: ParseOptions): Program = js.native
  @JSImport("esprima", "parseModule")
  @js.native
  def parseModule(
    input: String,
    config: ParseOptions,
    delegate: js.Function2[/* node */ Node, /* meta */ js.Any, Unit]
  ): Program = js.native
  
  @JSImport("esprima", "parseScript")
  @js.native
  def parseScript(input: String): Program = js.native
  @JSImport("esprima", "parseScript")
  @js.native
  def parseScript(
    input: String,
    config: js.UndefOr[scala.Nothing],
    delegate: js.Function2[/* node */ Node, /* meta */ js.Any, Unit]
  ): Program = js.native
  @JSImport("esprima", "parseScript")
  @js.native
  def parseScript(input: String, config: ParseOptions): Program = js.native
  @JSImport("esprima", "parseScript")
  @js.native
  def parseScript(
    input: String,
    config: ParseOptions,
    delegate: js.Function2[/* node */ Node, /* meta */ js.Any, Unit]
  ): Program = js.native
  
  @JSImport("esprima", "tokenize")
  @js.native
  def tokenize(input: String): js.Array[Token] = js.native
  @JSImport("esprima", "tokenize")
  @js.native
  def tokenize(input: String, config: TokenizeOptions): js.Array[Token] = js.native
  
  @JSImport("esprima", "version")
  @js.native
  val version: String = js.native
  
  @js.native
  trait ParseOptions extends StObject {
    
    var comment: js.UndefOr[Boolean] = js.native
    
    var jsx: js.UndefOr[Boolean] = js.native
    
    var loc: js.UndefOr[Boolean] = js.native
    
    var range: js.UndefOr[Boolean] = js.native
    
    var tokens: js.UndefOr[Boolean] = js.native
    
    var tolerant: js.UndefOr[Boolean] = js.native
  }
  object ParseOptions {
    
    @scala.inline
    def apply(): ParseOptions = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[ParseOptions]
    }
    
    @scala.inline
    implicit class ParseOptionsMutableBuilder[Self <: ParseOptions] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setComment(value: Boolean): Self = StObject.set(x, "comment", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCommentUndefined: Self = StObject.set(x, "comment", js.undefined)
      
      @scala.inline
      def setJsx(value: Boolean): Self = StObject.set(x, "jsx", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJsxUndefined: Self = StObject.set(x, "jsx", js.undefined)
      
      @scala.inline
      def setLoc(value: Boolean): Self = StObject.set(x, "loc", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLocUndefined: Self = StObject.set(x, "loc", js.undefined)
      
      @scala.inline
      def setRange(value: Boolean): Self = StObject.set(x, "range", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setRangeUndefined: Self = StObject.set(x, "range", js.undefined)
      
      @scala.inline
      def setTokens(value: Boolean): Self = StObject.set(x, "tokens", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTokensUndefined: Self = StObject.set(x, "tokens", js.undefined)
      
      @scala.inline
      def setTolerant(value: Boolean): Self = StObject.set(x, "tolerant", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTolerantUndefined: Self = StObject.set(x, "tolerant", js.undefined)
    }
  }
  
  @js.native
  trait Program
    extends typingsSlinky.estree.mod.Program {
    
    var tokens: js.UndefOr[js.Array[Token]] = js.native
  }
  object Program {
    
    @scala.inline
    def apply(
      body: js.Array[Directive | Statement | ModuleDeclaration],
      sourceType: script | module,
      `type`: typingsSlinky.estree.estreeStrings.Program
    ): Program = {
      val __obj = js.Dynamic.literal(body = body.asInstanceOf[js.Any], sourceType = sourceType.asInstanceOf[js.Any])
      __obj.updateDynamic("type")(`type`.asInstanceOf[js.Any])
      __obj.asInstanceOf[Program]
    }
    
    @scala.inline
    implicit class ProgramMutableBuilder[Self <: Program] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setTokens(value: js.Array[Token]): Self = StObject.set(x, "tokens", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTokensUndefined: Self = StObject.set(x, "tokens", js.undefined)
      
      @scala.inline
      def setTokensVarargs(value: Token*): Self = StObject.set(x, "tokens", js.Array(value :_*))
    }
  }
  
  @js.native
  trait Token extends StObject {
    
    var `type`: String = js.native
    
    var value: String = js.native
  }
  object Token {
    
    @scala.inline
    def apply(`type`: String, value: String): Token = {
      val __obj = js.Dynamic.literal(value = value.asInstanceOf[js.Any])
      __obj.updateDynamic("type")(`type`.asInstanceOf[js.Any])
      __obj.asInstanceOf[Token]
    }
    
    @scala.inline
    implicit class TokenMutableBuilder[Self <: Token] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setType(value: String): Self = StObject.set(x, "type", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setValue(value: String): Self = StObject.set(x, "value", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait TokenizeOptions extends StObject {
    
    var comment: js.UndefOr[Boolean] = js.native
    
    var loc: js.UndefOr[Boolean] = js.native
    
    var range: js.UndefOr[Boolean] = js.native
    
    var tolerant: js.UndefOr[Boolean] = js.native
  }
  object TokenizeOptions {
    
    @scala.inline
    def apply(): TokenizeOptions = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[TokenizeOptions]
    }
    
    @scala.inline
    implicit class TokenizeOptionsMutableBuilder[Self <: TokenizeOptions] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setComment(value: Boolean): Self = StObject.set(x, "comment", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCommentUndefined: Self = StObject.set(x, "comment", js.undefined)
      
      @scala.inline
      def setLoc(value: Boolean): Self = StObject.set(x, "loc", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLocUndefined: Self = StObject.set(x, "loc", js.undefined)
      
      @scala.inline
      def setRange(value: Boolean): Self = StObject.set(x, "range", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setRangeUndefined: Self = StObject.set(x, "range", js.undefined)
      
      @scala.inline
      def setTolerant(value: Boolean): Self = StObject.set(x, "tolerant", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTolerantUndefined: Self = StObject.set(x, "tolerant", js.undefined)
    }
  }
}
