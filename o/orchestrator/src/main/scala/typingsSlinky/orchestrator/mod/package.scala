package typingsSlinky.orchestrator

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

package object mod {
  
  /** The method export generated by orchestrator/lib/runTask.js */
  type RunTask = js.Function2[
    /* task */ typingsSlinky.orchestrator.mod.TaskFunc, 
    /* done */ js.Function2[/* err */ js.Any, /* meta */ typingsSlinky.orchestrator.mod.Meta, scala.Unit], 
    scala.Unit
  ]
  
  /** The module export of the sequencify package: https://www.npmjs.com/package/sequencify */
  type Sequencify = js.Function2[
    /* tasks */ js.Array[typingsSlinky.orchestrator.anon.Dep], 
    /* names */ js.Array[java.lang.String], 
    typingsSlinky.orchestrator.anon.MissingTasks
  ]
  
  type Strings = java.lang.String | js.Array[java.lang.String]
  
  /** A task, can either call a callback to indicate task completion or return a promise or a stream: (task is marked complete when promise.then() resolves/fails or stream ends)
    */
  type TaskFunc = js.Function1[
    /* callback */ js.Function1[/* err */ js.UndefOr[js.Any], scala.Unit], 
    typingsSlinky.q.mod.Promise[js.Any] | typingsSlinky.node.streamMod.Stream | js.Any
  ]
}
