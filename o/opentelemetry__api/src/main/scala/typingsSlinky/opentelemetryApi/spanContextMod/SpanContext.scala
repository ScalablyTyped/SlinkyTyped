package typingsSlinky.opentelemetryApi.spanContextMod

import typingsSlinky.opentelemetryApi.traceFlagsMod.TraceFlags
import typingsSlinky.opentelemetryApi.traceStateMod.TraceState
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

@js.native
trait SpanContext extends js.Object {
  
  /**
    * Only true if the SpanContext was propagated from a remote parent.
    */
  var isRemote: js.UndefOr[Boolean] = js.native
  
  /**
    * The ID of the Span. It is globally unique with practically sufficient
    * probability by being made as 8 randomly generated bytes, encoded as a 16
    * lowercase hex characters corresponding to 64 bits.
    */
  var spanId: String = js.native
  
  /**
    * Trace flags to propagate.
    *
    * It is represented as 1 byte (bitmap). Bit to represent whether trace is
    * sampled or not. When set, the least significant bit documents that the
    * caller may have recorded trace data. A caller who does not record trace
    * data out-of-band leaves this flag unset.
    *
    * SAMPLED = 0x1 and NONE = 0x0;
    */
  var traceFlags: TraceFlags = js.native
  
  /**
    * The ID of the trace that this span belongs to. It is worldwide unique
    * with practically sufficient probability by being made as 16 randomly
    * generated bytes, encoded as a 32 lowercase hex characters corresponding to
    * 128 bits.
    */
  var traceId: String = js.native
  
  /**
    * Tracing-system-specific info to propagate.
    *
    * The tracestate field value is a `list` as defined below. The `list` is a
    * series of `list-members` separated by commas `,`, and a list-member is a
    * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs
    * surrounding `list-members` are ignored. There can be a maximum of 32
    * `list-members` in a `list`.
    * More Info: https://www.w3.org/TR/trace-context/#tracestate-field
    *
    * Examples:
    *     Single tracing system (generic format):
    *         tracestate: rojo=00f067aa0ba902b7
    *     Multiple tracing systems (with different formatting):
    *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE
    */
  var traceState: js.UndefOr[TraceState] = js.native
}
object SpanContext {
  
  @scala.inline
  def apply(spanId: String, traceFlags: TraceFlags, traceId: String): SpanContext = {
    val __obj = js.Dynamic.literal(spanId = spanId.asInstanceOf[js.Any], traceFlags = traceFlags.asInstanceOf[js.Any], traceId = traceId.asInstanceOf[js.Any])
    __obj.asInstanceOf[SpanContext]
  }
  
  @scala.inline
  implicit class SpanContextOps[Self <: SpanContext] (val x: Self) extends AnyVal {
    
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    
    @scala.inline
    def set(key: String, value: js.Any): Self = {
      x.asInstanceOf[js.Dynamic].updateDynamic(key)(value)
      x
    }
    
    @scala.inline
    def setSpanId(value: String): Self = this.set("spanId", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setTraceFlags(value: TraceFlags): Self = this.set("traceFlags", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setTraceId(value: String): Self = this.set("traceId", value.asInstanceOf[js.Any])
    
    @scala.inline
    def setIsRemote(value: Boolean): Self = this.set("isRemote", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteIsRemote: Self = this.set("isRemote", js.undefined)
    
    @scala.inline
    def setTraceState(value: TraceState): Self = this.set("traceState", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteTraceState: Self = this.set("traceState", js.undefined)
  }
}
