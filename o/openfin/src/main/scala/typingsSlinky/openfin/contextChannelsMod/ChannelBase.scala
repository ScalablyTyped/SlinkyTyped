package typingsSlinky.openfin.contextChannelsMod

import typingsSlinky.openfin.contextMod.Context
import typingsSlinky.openfin.identityMod.Identity
import typingsSlinky.openfin.openfinStrings.`window-added`
import typingsSlinky.openfin.openfinStrings.`window-removed`
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

@JSImport("openfin/_v2/fdc3/contextChannels", "ChannelBase")
@js.native
abstract class ChannelBase protected () extends js.Object {
  protected def this(id: String, `type`: String) = this()
  
  /**
    * Event that is fired whenever a window broadcasts on this channel.
    *
    * This can be triggered by a window belonging to the channel calling the top-level FDC3 `broadcast` function, or by
    * any window calling this channel's {@link broadcast} method.
    *
    * @param handler Function that should be called whenever a context is broadcast on this channel.
    */
  def addContextListener(handler: js.Function1[/* context */ Context, Unit]): ChannelContextListener = js.native
  
  /**
    * Event that is fired whenever a window joins this channel. This includes switching to/from the default
    * channel.
    *
    * The event also includes which channel the window was in previously. The `channel` property within the
    * event will always be this channel instance.
    */
  @JSName("addEventListener")
  def addEventListener_windowadded(eventType: `window-added`, handler: js.Function1[/* event */ ChannelWindowAddedEvent, Unit]): Unit = js.native
  /**
    * Event that is fired whenever a window leaves this channel. This includes switching to/from the default
    * channel.
    *
    * The event also includes which channel the window is being added to. The `previousChannel` property within the
    * event will always be this channel instance.
    */
  @JSName("addEventListener")
  def addEventListener_windowremoved(eventType: `window-removed`, handler: js.Function1[/* event */ ChannelWindowRemovedEvent, Unit]): Unit = js.native
  
  /**
    * Broadcasts the given context on this channel.
    *
    * Note that this function can be used without first joining the channel, allowing applications to broadcast on
    * channels that they aren't a member of.
    *
    * This broadcast will be received by all windows that are members of this channel, *except* for the window that
    * makes the broadcast. This matches the behavior of the top-level FDC3 `broadcast` function.
    *
    * @param context The context to broadcast to all windows on this channel.
    * @throws `TypeError` if `context` is not a valid [[Context]].
    */
  def broadcast(context: Context): js.Promise[Unit] = js.native
  
  /**
    * Returns the last context that was broadcast on this channel. All channels initially have no context, until a
    * window is added to the channel and then broadcasts. If there is not yet any context on the channel, this method
    * will return `null`. The context is also reset back into its initial context-less state whenever a channel is
    * cleared of all windows.
    *
    * The context of a channel will be captured regardless of how the context is broadcasted on this channel - whether
    * using the top-level FDC3 `broadcast` function, or using the channel-level {@link broadcast} function on this
    * object.
    *
    * NOTE: Only non-default channels are stateful, for the default channel this method will always return `null`.
    */
  def getCurrentContext(): js.Promise[Context | Null] = js.native
  
  /**
    * Returns a list of all windows belonging to the specified channel.
    *
    * If the window making the call is a member of this channel, it will be included in the results. If there are no
    * windows on this channel, an empty array is returned.
    */
  def getMembers(): js.Promise[js.Array[Identity]] = js.native
  
  /**
    * Constant that uniquely identifies this channel. Will be generated by the service, and guaranteed to be unique
    * within the set of channels registered with the service.
    *
    * In the case of `system` channels (see {@link SystemChannel}), these IDs _should_ persist across sessions. The
    * channel list is defined by the service, but can be overridden by a desktop owner. If the desktop owner keeps
    * this list static (which is recommended), then IDs will also persist across sessions.
    */
  val id: ChannelId = js.native
  
  /**
    * Adds the given window to this channel. If no identity is provided, the window making the call will be the window
    * added to the channel.
    *
    * If the channel has a current context (see {@link getCurrentContext}) then that context will be immediately passed to
    * the given window upon joining the channel, via its context listener(s).
    *
    * Note that all windows will always belong to exactly one channel at all times. If you wish to leave a channel,
    * the only way to do so is to join another channel. A window may rejoin the default channel by calling `channels.defaultChannel.join()`.
    *
    * @param identity The window that should be added to this channel. If omitted, will use the window that calls this method.
    * @throws If `identity` is passed, [[FDC3Error]] with an [[ConnectionError]] code.
    * @throws If `identity` is passed, `TypeError` if `identity` is not a valid
    * {@link https://developer.openfin.co/docs/javascript/stable/global.html#Identity | Identity}.
    */
  def join(): js.Promise[Unit] = js.native
  def join(identity: Identity): js.Promise[Unit] = js.native
  
  @JSName("removeEventListener")
  def removeEventListener_windowadded(eventType: `window-added`, handler: js.Function1[/* event */ ChannelWindowAddedEvent, Unit]): Unit = js.native
  @JSName("removeEventListener")
  def removeEventListener_windowremoved(eventType: `window-removed`, handler: js.Function1[/* event */ ChannelWindowRemovedEvent, Unit]): Unit = js.native
  
  /**
    * Uniquely defines each channel type.
    *
    * See overrides of this class for list of allowed values.
    */
  val `type`: String = js.native
}
