package typingsSlinky.oracledb

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

package object mod {
  
  /** Constant for the AqDeqOptions Class 'mode' */
  @scala.inline
  def AQ_DEQ_MODE_BROWSE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_MODE_BROWSE").asInstanceOf[scala.Double]
  
  /** Constant for the AqDeqOptions Class 'mode' */
  @scala.inline
  def AQ_DEQ_MODE_LOCKED: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_MODE_LOCKED").asInstanceOf[scala.Double]
  
  /** Constant for the AqDeqOptions Class 'mode' */
  @scala.inline
  def AQ_DEQ_MODE_REMOVE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_MODE_REMOVE").asInstanceOf[scala.Double]
  
  /** Constant for the AqDeqOptions Class 'mode' */
  @scala.inline
  def AQ_DEQ_MODE_REMOVE_NO_DAT: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_MODE_REMOVE_NO_DAT").asInstanceOf[scala.Double]
  
  /** Constant for the AqDeqOptions Class 'navigation' */
  @scala.inline
  def AQ_DEQ_NAV_FIRST_MSG: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_NAV_FIRST_MSG").asInstanceOf[scala.Double]
  
  /** Constant for the AqDeqOptions Class 'navigation' */
  @scala.inline
  def AQ_DEQ_NAV_NEXT_MS: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_NAV_NEXT_MS").asInstanceOf[scala.Double]
  
  /** Constant for the AqDeqOptions Class 'navigation' */
  @scala.inline
  def AQ_DEQ_NAV_NEXT_TRANSACTION: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_NAV_NEXT_TRANSACTION").asInstanceOf[scala.Double]
  
  /** Constant for the AqDeqOptions Class 'wait' */
  @scala.inline
  def AQ_DEQ_NO_WAIT: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_NO_WAIT").asInstanceOf[scala.Double]
  
  /** Constant for the AqEnqOptions Class 'deliveryMode' */
  @scala.inline
  def AQ_DEQ_WAAQ_MSG_DELIV_MODE_PERSISTENTIT_FOREVER: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_WAAQ_MSG_DELIV_MODE_PERSISTENTIT_FOREVER").asInstanceOf[scala.Double]
  
  /** Constant for the AqDeqOptions Class 'wait' */
  @scala.inline
  def AQ_DEQ_WAIT_FOREVER: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_WAIT_FOREVER").asInstanceOf[scala.Double]
  
  /** Constant for the AqEnqOptions Class 'deliveryMode' */
  @scala.inline
  def AQ_MSG_DELIV_MODE_BUFFERED: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_MSG_DELIV_MODE_BUFFERED").asInstanceOf[scala.Double]
  
  /** Constant for the AqEnqOptions Class 'deliveryMode' */
  @scala.inline
  def AQ_MSG_DELIV_MODE_PERSISTENT_OR_BUFFERED: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_MSG_DELIV_MODE_PERSISTENT_OR_BUFFERED").asInstanceOf[scala.Double]
  
  /** Constant for the AqMessage Class 'state' */
  @scala.inline
  def AQ_MSG_STATE_EXPIRED: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_MSG_STATE_EXPIRED").asInstanceOf[scala.Double]
  
  /** Constant for the AqMessage Class 'state' */
  @scala.inline
  def AQ_MSG_STATE_PROCESSED: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_MSG_STATE_PROCESSED").asInstanceOf[scala.Double]
  
  /** Constant for the AqMessage Class 'state' */
  @scala.inline
  def AQ_MSG_STATE_READY: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_MSG_STATE_READY").asInstanceOf[scala.Double]
  
  /** Constant for the AqMessage Class 'state' */
  @scala.inline
  def AQ_MSG_STATE_WAITING: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_MSG_STATE_WAITING").asInstanceOf[scala.Double]
  
  /** Constant for the AqEnqOptions Class and AqDeqOptions 'visibility' */
  @scala.inline
  def AQ_VISIBILITY_IMMEDIATE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_VISIBILITY_IMMEDIATE").asInstanceOf[scala.Double]
  
  /** Constant for the AqEnqOptions Class and AqDeqOptions 'visibility' */
  @scala.inline
  def AQ_VISIBILITY_ON_COMMIT: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_VISIBILITY_ON_COMMIT").asInstanceOf[scala.Double]
  
  /** Constant for the dir property of execute() bindParams, queryStream() and executeMany() bindDefs. */
  @scala.inline
  def BIND_IN: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("BIND_IN").asInstanceOf[scala.Double]
  
  /** Constant for the dir property of execute() bindParams, queryStream() and executeMany() bindDefs. */
  @scala.inline
  def BIND_INOUT: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("BIND_INOUT").asInstanceOf[scala.Double]
  
  /** Constant for the dir property of execute() bindParams, queryStream() and executeMany() bindDefs. */
  @scala.inline
  def BIND_OUT: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("BIND_OUT").asInstanceOf[scala.Double]
  
  /** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
  @scala.inline
  def BLOB: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("BLOB").asInstanceOf[scala.Double]
  
  /** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
  @scala.inline
  def BUFFER: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("BUFFER").asInstanceOf[scala.Double]
  
  /**
    * Used with connection.execute() to associate values or JavaScript variables to a statement’s bind variables by name.
    *
    * @see https://oracle.github.io/node-oracledb/doc/api.html#executebindParams
    */
  type BindParameters = (typingsSlinky.std.Record[
    java.lang.String, 
    js.UndefOr[
      typingsSlinky.oracledb.mod.BindParameter | java.lang.String | scala.Double | js.Date | typingsSlinky.oracledb.mod.DBObjectIN[js.Any] | typingsSlinky.node.Buffer | scala.Null
    ]
  ]) | (js.Array[js.Any | typingsSlinky.oracledb.mod.BindParameter])
  
  /** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
  @scala.inline
  def CLOB: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CLOB").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
  @scala.inline
  def CQN_OPCODE_ALL_OPS: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_ALL_OPS").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
  @scala.inline
  def CQN_OPCODE_ALL_ROWS: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_ALL_ROWS").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
  @scala.inline
  def CQN_OPCODE_ALTER: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_ALTER").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
  @scala.inline
  def CQN_OPCODE_DELETE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_DELETE").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
  @scala.inline
  def CQN_OPCODE_DROP: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_DROP").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
  @scala.inline
  def CQN_OPCODE_INSERT: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_INSERT").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
  @scala.inline
  def CQN_OPCODE_UPDATE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_UPDATE").asInstanceOf[scala.Double]
  
  /** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
  @scala.inline
  def CURSOR: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CURSOR").asInstanceOf[scala.Double]
  
  /** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
  @scala.inline
  def DATE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DATE").asInstanceOf[scala.Double]
  
  /**
    * @see https://oracle.github.io/node-oracledb/doc/api.html#objects
    * @since 4.0
    */
  type DBObjectIN[T] = typingsSlinky.oracledb.oracledbStrings.DBObject_IN with org.scalablytyped.runtime.TopLevel[T] with typingsSlinky.oracledb.mod.BaseDBObject[T]
  
  /**
    * @see https://oracle.github.io/node-oracledb/doc/api.html#objects
    * @since 4.0
    */
  type DBObjectOUT[T] = typingsSlinky.oracledb.oracledbStrings.DBObject_OUT with org.scalablytyped.runtime.TopLevel[js.Any] with typingsSlinky.oracledb.mod.BaseDBObject[T]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_BFILE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_BFILE").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_BINARY_DOUBLE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_BINARY_DOUBLE").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_BINARY_FLOAT: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_BINARY_FLOAT").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_BINARY_INTEGER: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_BINARY_INTEGER").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_BLOB: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_BLOB").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_BOOLEAN: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_BOOLEAN").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_CHAR: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_CHAR").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_CLOB: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_CLOB").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_CURSOR: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_CURSOR").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_DATE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_DATE").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_INTERVAL_DS: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_INTERVAL_DS").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_INTERVAL_YM: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_INTERVAL_YM").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_LONG: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_LONG").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_LONG_RAW: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_LONG_RAW").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_NCHAR: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_NCHAR").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_NCLOB: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_NCLOB").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_NUMBER: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_NUMBER").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_NVARCHAR: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_NVARCHAR").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_OBJECT: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_OBJECT").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_RAW: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_RAW").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_ROWID: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_ROWID").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_TIMESTAMP: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_TIMESTAMP").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_TIMESTAMP_LTZ: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_TIMESTAMP_LTZ").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_TIMESTAMP_TZ: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_TIMESTAMP_TZ").asInstanceOf[scala.Double]
  
  /** Constant which represents the Oracle Database type. */
  @scala.inline
  def DB_TYPE_VARCHAR: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_VARCHAR").asInstanceOf[scala.Double]
  
  /** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
  @scala.inline
  def DEFAULT: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DEFAULT").asInstanceOf[scala.Double]
  
  type EnqueueMessage[T] = java.lang.String | typingsSlinky.node.Buffer | typingsSlinky.oracledb.mod.DBObjectIN[T] | typingsSlinky.oracledb.anon.Correlation[T]
  
  /** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
  @scala.inline
  def NCLOB: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("NCLOB").asInstanceOf[scala.Double]
  
  /** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
  @scala.inline
  def NUMBER: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("NUMBER").asInstanceOf[scala.Double]
  
  /** Deprecated */
  // const ARRAY: number;
  // const OBJECT: number;
  /** Constant for the query result outFormat option. */
  @scala.inline
  def OUT_FORMAT_ARRAY: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("OUT_FORMAT_ARRAY").asInstanceOf[scala.Double]
  
  /** Constant for the query result outFormat option. */
  @scala.inline
  def OUT_FORMAT_OBJECT: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("OUT_FORMAT_OBJECT").asInstanceOf[scala.Double]
  
  /** Constant for the connection pool.status readonly attribute. */
  @scala.inline
  def POOL_STATUS_CLOSED: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("POOL_STATUS_CLOSED").asInstanceOf[scala.Double]
  
  /** Constant for the connection pool.status readonly attribute. */
  @scala.inline
  def POOL_STATUS_DRAINING: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("POOL_STATUS_DRAINING").asInstanceOf[scala.Double]
  
  /** Constant for the connection pool.status readonly attribute. */
  @scala.inline
  def POOL_STATUS_OPEN: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("POOL_STATUS_OPEN").asInstanceOf[scala.Double]
  
  /**
    * The oracledb.Promise property is no longer used in node-oracledb 5 and has no effect.
    * 
    * Node-oracledb supports Promises on all methods. The native Promise library is used.
    * 
    * @deprecated 5.0
    */
  @scala.inline
  def Promise: js.Promise[js.Any] = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("Promise").asInstanceOf[js.Promise[js.Any]]
  @scala.inline
  def Promise_=(x: js.Promise[js.Any]): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("Promise")(x.asInstanceOf[js.Any])
  
  /** Constant for shutting down the Oracle database with oracledb.shutdown() and connection.shutdown() */
  @scala.inline
  def SHUTDOWN_MODE_ABORT: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SHUTDOWN_MODE_ABORT").asInstanceOf[scala.Double]
  
  /** Constant for shutting down the Oracle database with oracledb.shutdown() and connection.shutdown() */
  @scala.inline
  def SHUTDOWN_MODE_DEFAULT: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SHUTDOWN_MODE_DEFAULT").asInstanceOf[scala.Double]
  
  /** Constant for shutting down the Oracle database with oracledb.shutdown() and connection.shutdown() */
  @scala.inline
  def SHUTDOWN_MODE_FINAL: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SHUTDOWN_MODE_FINAL").asInstanceOf[scala.Double]
  
  /** Constant for shutting down the Oracle database with oracledb.shutdown() and connection.shutdown() */
  @scala.inline
  def SHUTDOWN_MODE_IMMEDIATE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SHUTDOWN_MODE_IMMEDIATE").asInstanceOf[scala.Double]
  
  /** Constant for shutting down the Oracle database with oracledb.shutdown() and connection.shutdown() */
  @scala.inline
  def SHUTDOWN_MODE_TRANSACTIONAL: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SHUTDOWN_MODE_TRANSACTIONAL").asInstanceOf[scala.Double]
  
  /** Constant for shutting down the Oracle database with oracledb.shutdown() and connection.shutdown() */
  @scala.inline
  def SHUTDOWN_MODE_TRANSACTIONAL_LOCAL: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SHUTDOWN_MODE_TRANSACTIONAL_LOCAL").asInstanceOf[scala.Double]
  
  /** Constant for the sodaDatabase.createCollection() mode property. */
  @scala.inline
  def SODA_COLL_MAP_MODE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SODA_COLL_MAP_MODE").asInstanceOf[scala.Double]
  
  /** Constant for connection.getStatementInfo() properties. */
  @scala.inline
  def STMT_TYPE_ALTER: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_ALTER").asInstanceOf[scala.Double]
  
  /** Constant for connection.getStatementInfo() properties. */
  @scala.inline
  def STMT_TYPE_BEGIN: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_BEGIN").asInstanceOf[scala.Double]
  
  /** Constant for connection.getStatementInfo() properties. */
  @scala.inline
  def STMT_TYPE_CALL: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_CALL").asInstanceOf[scala.Double]
  
  /** Constant for connection.getStatementInfo() properties. */
  @scala.inline
  def STMT_TYPE_COMMIT: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_COMMIT").asInstanceOf[scala.Double]
  
  /** Constant for connection.getStatementInfo() properties. */
  @scala.inline
  def STMT_TYPE_CREATE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_CREATE").asInstanceOf[scala.Double]
  
  /** Constant for connection.getStatementInfo() properties. */
  @scala.inline
  def STMT_TYPE_DECLARE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_DECLARE").asInstanceOf[scala.Double]
  
  /** Constant for connection.getStatementInfo() properties. */
  @scala.inline
  def STMT_TYPE_DELETE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_DELETE").asInstanceOf[scala.Double]
  
  /** Constant for connection.getStatementInfo() properties. */
  @scala.inline
  def STMT_TYPE_DROP: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_DROP").asInstanceOf[scala.Double]
  
  /** Constant for connection.getStatementInfo() properties. */
  @scala.inline
  def STMT_TYPE_EXPLAIN_PLAN: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_EXPLAIN_PLAN").asInstanceOf[scala.Double]
  
  /** Constant for connection.getStatementInfo() properties. */
  @scala.inline
  def STMT_TYPE_INSERT: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_INSERT").asInstanceOf[scala.Double]
  
  /** Constant for connection.getStatementInfo() properties. */
  @scala.inline
  def STMT_TYPE_MERGE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_MERGE").asInstanceOf[scala.Double]
  
  /** Constant for connection.getStatementInfo() properties. */
  @scala.inline
  def STMT_TYPE_ROLLBACK: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_ROLLBACK").asInstanceOf[scala.Double]
  
  /** Constant for connection.getStatementInfo() properties. */
  @scala.inline
  def STMT_TYPE_SELECT: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_SELECT").asInstanceOf[scala.Double]
  
  /** Constant for connection.getStatementInfo() properties. */
  @scala.inline
  def STMT_TYPE_UNKNOWN: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_UNKNOWN").asInstanceOf[scala.Double]
  
  /** Constant for connection.getStatementInfo() properties. */
  @scala.inline
  def STMT_TYPE_UPDATE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_UPDATE").asInstanceOf[scala.Double]
  
  /** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
  @scala.inline
  def STRING: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STRING").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification message.type. */
  @scala.inline
  def SUBSCR_EVENT_TYPE_AQ: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_AQ").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification message.type. */
  @scala.inline
  def SUBSCR_EVENT_TYPE_DEREG: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_DEREG").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification message.type. */
  @scala.inline
  def SUBSCR_EVENT_TYPE_OBJ_CHANGE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_OBJ_CHANGE").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification message.type. */
  @scala.inline
  def SUBSCR_EVENT_TYPE_QUERY_CHANGE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_QUERY_CHANGE").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification message.type. */
  @scala.inline
  def SUBSCR_EVENT_TYPE_SHUTDOWN: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_SHUTDOWN").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification message.type. */
  @scala.inline
  def SUBSCR_EVENT_TYPE_SHUTDOWN_ANY: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_SHUTDOWN_ANY").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification message.type. */
  @scala.inline
  def SUBSCR_EVENT_TYPE_STARTUP: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_STARTUP").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification groupingClass. */
  @scala.inline
  def SUBSCR_GROUPING_CLASS_TIME: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_GROUPING_CLASS_TIME").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification groupingType. */
  @scala.inline
  def SUBSCR_GROUPING_TYPE_LAST: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_GROUPING_TYPE_LAST").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification groupingType. */
  @scala.inline
  def SUBSCR_GROUPING_TYPE_SUMMARY: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_GROUPING_TYPE_SUMMARY").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification namespace. */
  @scala.inline
  def SUBSCR_NAMESPACE_AQ: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_NAMESPACE_AQ").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification namespace. */
  @scala.inline
  def SUBSCR_NAMESPACE_DBCHANGE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_NAMESPACE_DBCHANGE").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification qos Quality of Service. */
  @scala.inline
  def SUBSCR_QOS_BEST_EFFORT: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_QOS_BEST_EFFORT").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification qos Quality of Service. */
  @scala.inline
  def SUBSCR_QOS_DEREG_NFY: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_QOS_DEREG_NFY").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification qos Quality of Service. */
  @scala.inline
  def SUBSCR_QOS_QUERY: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_QOS_QUERY").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification qos Quality of Service. */
  @scala.inline
  def SUBSCR_QOS_RELIABLE: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_QOS_RELIABLE").asInstanceOf[scala.Double]
  
  /** Constant for the Continuous Query Notification qos Quality of Service. */
  @scala.inline
  def SUBSCR_QOS_ROWIDS: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_QOS_ROWIDS").asInstanceOf[scala.Double]
  
  /** Constant for getConnection() privilege properties. */
  @scala.inline
  def SYSASM: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SYSASM").asInstanceOf[scala.Double]
  
  /** Constant for getConnection() privilege properties. */
  @scala.inline
  def SYSBACKUP: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SYSBACKUP").asInstanceOf[scala.Double]
  
  /** Constant for getConnection() privilege properties. */
  @scala.inline
  def SYSDBA: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SYSDBA").asInstanceOf[scala.Double]
  
  /** Constant for getConnection() privilege properties. */
  @scala.inline
  def SYSDG: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SYSDG").asInstanceOf[scala.Double]
  
  /** Constant for getConnection() privilege properties. */
  @scala.inline
  def SYSKM: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SYSKM").asInstanceOf[scala.Double]
  
  /** Constant for getConnection() privilege properties. */
  @scala.inline
  def SYSOPER: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SYSOPER").asInstanceOf[scala.Double]
  
  /** Constant for getConnection() privilege properties. */
  @scala.inline
  def SYSPRELIM: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SYSPRELIM").asInstanceOf[scala.Double]
  
  /** Constant for getConnection() privilege properties. */
  @scala.inline
  def SYSRAC: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SYSRAC").asInstanceOf[scala.Double]
  
  /**
    * If true, the transaction in the current connection is automatically committed at the end of statement execution.
    * This property may be overridden in an execute() call.
    *
    * @default false
    * @since 0.5
    */
  @scala.inline
  def autoCommit: scala.Boolean = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("autoCommit").asInstanceOf[scala.Boolean]
  @scala.inline
  def autoCommit_=(x: scala.Boolean): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("autoCommit")(x.asInstanceOf[js.Any])
  
  /**
    * The user-chosen Connection class value defines a logical name for connections.
    * Most single purpose applications should set connectionClass when using a connection pool or DRCP.
    *
    * When a pooled session has a connection class, Oracle ensures that the session is not shared outside of that connection class.
    *
    * The connection class value is similarly used by Database Resident Connection Pooling (DRCP) to allow or disallow sharing of sessions.
    *
    * For example, where two different kinds of users share one pool, you might set connectionClass to ‘HRPOOL’ for connections that
    * access a Human Resources system, and it might be set to ‘OEPOOL’ for users of an Order Entry system.
    * Users will only be given sessions of the appropriate class, allowing maximal reuse of resources in each case,
    * and preventing any session information leaking between the two systems.
    *
    * If connectionClass is set for a non-pooled connection, the driver name is not recorded in V$ views.
    */
  @scala.inline
  def connectionClass: java.lang.String = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("connectionClass").asInstanceOf[java.lang.String]
  @scala.inline
  def connectionClass_=(x: java.lang.String): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("connectionClass")(x.asInstanceOf[js.Any])
  
  /**
    * This method creates a pool of connections with the specified user name, password and connection string.
    * A pool is typically created once during application initialization.
    *
    * Internally, createPool() creates an Oracle Call Interface Session Pool for each Pool object.
    *
    * The default properties may be overridden by specifying new properties in the poolAttrs parameter.
    *
    * It is possible to add pools to the pool cache when calling createPool().
    * This allows pools to later be accessed by name, removing the need to pass the pool object through code.
    *
    * A pool should be terminated with the pool.close() call.
    *
    * From node-oracledb 3.1.0, the createPool() error callback will return a DPI-1047 error if node-oracledb cannot load Oracle Client libraries.
    * Previous versions threw this error from require('oracledb').
    *
    * @param poolAttributes Provides connection credentials and pool-specific configuration properties, overriding the defualt pooling properties of the Oracledb object.
    */
  @scala.inline
  def createPool(poolAttributes: typingsSlinky.oracledb.mod.PoolAttributes): js.Promise[typingsSlinky.oracledb.mod.Pool] = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createPool")(poolAttributes.asInstanceOf[js.Any]).asInstanceOf[js.Promise[typingsSlinky.oracledb.mod.Pool]]
  @scala.inline
  def createPool(
    poolAttributes: typingsSlinky.oracledb.mod.PoolAttributes,
    callback: js.Function2[
      /* error */ typingsSlinky.oracledb.mod.DBError, 
      /* pool */ typingsSlinky.oracledb.mod.Pool, 
      scala.Unit
    ]
  ): scala.Unit = (typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createPool")(poolAttributes.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  
  /**
    * Sets the name used for Edition-Based Redefinition by connections.
    *
    * @since 2.2
    */
  @scala.inline
  def edition: java.lang.String = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("edition").asInstanceOf[java.lang.String]
  @scala.inline
  def edition_=(x: java.lang.String): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("edition")(x.asInstanceOf[js.Any])
  
  /**
    * Determines whether Oracle Client events mode should be enabled.
    *
    * This property can be overridden in the oracledb.createPool() call and when getting a standalone connection from oracledb.getConnection().
    *
    * Events mode is required for Continuous Query Notification, Fast Application Notification (FAN) and Runtime Load Balancing (RLB).
    *
    * @default true
    * @since 2.2
    */
  @scala.inline
  def events: scala.Boolean = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("events").asInstanceOf[scala.Boolean]
  @scala.inline
  def events_=(x: scala.Boolean): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("events")(x.asInstanceOf[js.Any])
  
  /**
    * Determines whether additional metadata is available for queries and for REF CURSORs returned from PL/SQL blocks.
    *
    * With this value, the result.metaData result.resultSet.metaData objects only include column names.
    *
    * If extendedMetaData is true then metaData will contain additional attributes.
    *
    * This property may be overridden in an execute() call.
    *
    * @default false
    * @since 1.10
    */
  @scala.inline
  def extendedMetaData: scala.Boolean = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("extendedMetaData").asInstanceOf[scala.Boolean]
  @scala.inline
  def extendedMetaData_=(x: scala.Boolean): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("extendedMetaData")(x.asInstanceOf[js.Any])
  
  /**
    * If true, connections will be established using external authentication.
    *
    * The user and password properties should not be set when externalAuth is true.
    *
    * This property can be overridden in the oracledb.createPool() call and when getting a standalone connection from oracledb.getConnection().
    *
    * @default false
    * @since 0.5
    */
  @scala.inline
  def externalAuth: scala.Boolean = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("externalAuth").asInstanceOf[scala.Boolean]
  @scala.inline
  def externalAuth_=(x: scala.Boolean): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("externalAuth")(x.asInstanceOf[js.Any])
  
  /**
    * This property sets the size of an internal buffer used for fetching query rows from Oracle Database.
    * Changing it may affect query performance but does not affect how many rows are returned to the application.
    *
    * The property is used during the default direct fetches, during ResultSet getRow() calls, and for queryStream(). It is not used for getRows().
    *
    * Increasing this value reduces the number of round-trips to the database but increases memory usage for each data fetch.
    * For queries that return a large number of rows, higher values of fetchArraySize may give better performance.
    * For queries that only return a few rows, reduce the value of fetchArraySize to minimize the amount of memory management during data fetches.
    * JavaScript memory fragmentation may occur in some cases.
    *
    * For direct fetches (those using execute() option resultSet: false), the internal buffer size will be based on the lesser of maxRows and fetchArraySize.
    *
    * @default 100
    * @since 2.0
    */
  @scala.inline
  def fetchArraySize: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("fetchArraySize").asInstanceOf[scala.Double]
  @scala.inline
  def fetchArraySize_=(x: scala.Double): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("fetchArraySize")(x.asInstanceOf[js.Any])
  
  /**
    * Configure data types to be returned as a Buffer instead of the default representation when queried with execute() or queryStream().
    *
    * Currently the only valid type is oracledb.BLOB.
    *
    * By default in node-oracledb, all columns are returned as native types or as Lob instances, in the case of CLOB and BLOB types.
    *
    * Individual query columns in execute() or queryStream() calls can override the fetchAsBuffer global setting by using fetchInfo.
    *
    * @since 1.13
    */
  @scala.inline
  def fetchAsBuffer: js.Array[scala.Double] = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("fetchAsBuffer").asInstanceOf[js.Array[scala.Double]]
  @scala.inline
  def fetchAsBuffer_=(x: js.Array[scala.Double]): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("fetchAsBuffer")(x.asInstanceOf[js.Any])
  
  /**
    * An array of node-oracledb types. The valid types are oracledb.DATE, oracledb.NUMBER, oracledb.BUFFER, and oracledb.CLOB.
    * When any column having one of the specified types is queried with execute() or queryStream(), the column data is returned as a string instead of the default representation.
    *
    * By default in node-oracledb, all columns are returned as native types or as Lob instances, in the case of CLOB and BLOB types.
    *
    * This property helps avoid situations where using JavaScript types can lead to numeric precision loss, or where date conversion is unwanted.
    *
    * For raw data returned as a string, Oracle returns the data as a hex-encoded string.
    * For dates and numbers returned as a string, the maximum length of a string created by this mapping is 200 bytes.
    * Strings created for CLOB columns will generally be limited by Node.js and V8 memory restrictions.
    *
    * Individual query columns in execute() or queryStream() calls can override the fetchAsString global setting by using fetchInfo.
    *
    * For non-CLOB types, the conversion to string is handled by Oracle client libraries and is often referred to as defining the fetch type.
    */
  @scala.inline
  def fetchAsString: js.Array[scala.Double] = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("fetchAsString").asInstanceOf[js.Array[scala.Double]]
  @scala.inline
  def fetchAsString_=(x: js.Array[scala.Double]): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("fetchAsString")(x.asInstanceOf[js.Any])
  
  /**
    * Obtains a connection from the default pool.
    *
    * For situations where connections are used infrequently, creating a standalone connection may be more efficient than creating and managing a connection pool.
    * However, in most cases, Oracle recommends getting connections from a connection pool.
    */
  @scala.inline
  def getConnection(): js.Promise[typingsSlinky.oracledb.mod.Connection] = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getConnection")().asInstanceOf[js.Promise[typingsSlinky.oracledb.mod.Connection]]
  @scala.inline
  def getConnection(
    callback: js.Function2[
      /* error */ typingsSlinky.oracledb.mod.DBError, 
      /* connection */ typingsSlinky.oracledb.mod.Connection, 
      scala.Unit
    ]
  ): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getConnection")(callback.asInstanceOf[js.Any]).asInstanceOf[scala.Unit]
  /**
    * Creates a new, standalone, non-pooled connection.
    *
    * For situations where connections are used infrequently, creating a standalone connection may be more efficient than creating and managing a connection pool.
    * However, in most cases, Oracle recommends getting connections from a connection pool.
    *
    * @param connectionAttributes Connection credentials and connection-specific configuration properties.
    */
  @scala.inline
  def getConnection(connectionAttributes: typingsSlinky.oracledb.mod.ConnectionAttributes): js.Promise[typingsSlinky.oracledb.mod.Connection] = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getConnection")(connectionAttributes.asInstanceOf[js.Any]).asInstanceOf[js.Promise[typingsSlinky.oracledb.mod.Connection]]
  @scala.inline
  def getConnection(
    connectionAttributes: typingsSlinky.oracledb.mod.ConnectionAttributes,
    callback: js.Function2[
      /* error */ typingsSlinky.oracledb.mod.DBError, 
      /* connection */ typingsSlinky.oracledb.mod.Connection, 
      scala.Unit
    ]
  ): scala.Unit = (typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getConnection")(connectionAttributes.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  /**
    * Obtains a connection from a pool in the connection pool cache.
    *
    * For situations where connections are used infrequently, creating a standalone connection may be more efficient than creating and managing a connection pool.
    * However, in most cases, Oracle recommends getting connections from a connection pool.
    *
    * @param poolAlias Specifies which previously created pool in the connection pool cache to use to obtain the connection.
    */
  @scala.inline
  def getConnection(poolAlias: java.lang.String): js.Promise[typingsSlinky.oracledb.mod.Connection] = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getConnection")(poolAlias.asInstanceOf[js.Any]).asInstanceOf[js.Promise[typingsSlinky.oracledb.mod.Connection]]
  @scala.inline
  def getConnection(
    poolAlias: java.lang.String,
    callback: js.Function2[
      /* error */ typingsSlinky.oracledb.mod.DBError, 
      /* connection */ typingsSlinky.oracledb.mod.Connection, 
      scala.Unit
    ]
  ): scala.Unit = (typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getConnection")(poolAlias.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  
  /**
    * Retrieves a previously created pool from the connection pool cache. Note that this is a synchronous method.
    *
    * @param poolAlias
    *
    * The pool alias of the pool to retrieve from the connection pool cache.
    *
    * @default default
    */
  @scala.inline
  def getPool(): typingsSlinky.oracledb.mod.Pool = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getPool")().asInstanceOf[typingsSlinky.oracledb.mod.Pool]
  @scala.inline
  def getPool(poolAlias: java.lang.String): typingsSlinky.oracledb.mod.Pool = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getPool")(poolAlias.asInstanceOf[js.Any]).asInstanceOf[typingsSlinky.oracledb.mod.Pool]
  
  /**
    * This synchronous function loads and initializes the Oracle Client libraries that are necessary
    * for node-oracledb to communicate with Oracle Database. This function is optional. If used, it
    * should be the first node-oracledb call made by an application.
    * 
    * If initOracleClient() is not called, then the Oracle Client libraries are loaded at the time of
    * first use in the application, such as when creating a connection pool. The default values described
    * for options will be used in this case.
    * 
    * If the Oracle Client libraries cannot be loaded, or they have already been initialized, either by a
    * previous call to this function or because another function call already required the Oracle Client libraries,
    * then initOracleClient() raises an exception.
    * 
    * On Linux, ensure a libclntsh.so file exists. On macOS ensure a libclntsh.dylib file exists.
    * Node-oracledb will not directly load libclntsh.*.XX.1 files in libDir. Note other libraries used by libclntsh* are also required.
    * 
    * On Linux, using libDir is only useful for forcing initOracleClient() to immediately load the Oracle Client libraries because
    * those libraries still need to be in the operating system search path, such as from running ldconfig or set in the environment
    * variable LD_LIBRARY_PATH.
    * 
    * @see https://oracle.github.io/node-oracledb/doc/api.html#initnodeoracledb
    * @since 5.0
    */
  @scala.inline
  def initOracleClient(): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("initOracleClient")().asInstanceOf[scala.Unit]
  @scala.inline
  def initOracleClient(opts: typingsSlinky.oracledb.mod.InitialiseOptions): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("initOracleClient")(opts.asInstanceOf[js.Any]).asInstanceOf[scala.Unit]
  
  /**
    * The maximum number of rows that are fetched by a query with connection.execute() when not using a ResultSet.
    * Rows beyond this limit are not fetched from the database. A value of 0 means there is no limit.
    *
    * This property may be overridden in an execute() call.
    *
    * To improve database efficiency, SQL queries should use a row limiting clause like OFFSET / FETCH or equivalent.
    * The maxRows property can be used to stop badly coded queries from returning unexpectedly large numbers of rows.
    *
    * When the number of query rows is relatively big, or can not be predicted, it is recommended to use
    * a ResultSet or queryStream(). This allows applications to process rows in smaller chunks or individually,
    * preventing the Node.js memory limit being exceeded or query results being unexpectedly truncated by a
    * maxRows limit.
    *
    * @default 0 (unlimited)
    */
  @scala.inline
  def maxRows: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("maxRows").asInstanceOf[scala.Double]
  @scala.inline
  def maxRows_=(x: scala.Double): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("maxRows")(x.asInstanceOf[js.Any])
  
  /**
    * This readonly property gives a numeric representation of the Oracle client library version which
    * is useful in comparisons. For version a.b.c.d.e, this property
    * gives the number: (100000000 * a) + (1000000 * b) + (10000 * c) + (100 * d) + e
    *
    * @since 1.3
    */
  @scala.inline
  def oracleClientVersion: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("oracleClientVersion").asInstanceOf[scala.Double]
  
  /**
    * This readonly property gives a string representation of the Oracle client library version which is useful for display.
    *
    * @since 2.2
    */
  @scala.inline
  def oracleClientVersionString: java.lang.String = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("oracleClientVersionString").asInstanceOf[java.lang.String]
  
  /**
    * The format of query rows fetched when using connection.execute() or connection.queryStream().
    * It affects both ResultSet and non-ResultSet queries. It can be used for top level queries and REF CURSOR output.
    *
    * This can be either of the Oracledb constants oracledb.ARRAY or oracledb.OBJECT.
    *
    * If specified as oracledb.ARRAY, each row is fetched as an array of column values.
    *
    * If specified as oracledb.OBJECT, each row is fetched as a JavaScript object.
    * The object has a property for each column name, with the property value set to the respective column value.
    * The property name follows Oracle’s standard name-casing rules. It will commonly be uppercase,
    * since most applications create tables using unquoted, case-insensitive names.
    *
    * This property may be overridden in an execute() or queryStream() call.
    *
    * @default ARRAY
    */
  @scala.inline
  def outFormat: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("outFormat").asInstanceOf[scala.Double]
  @scala.inline
  def outFormat_=(x: scala.Double): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("outFormat")(x.asInstanceOf[js.Any])
  
  /**
    * The number of connections that are opened whenever a connection request exceeds the number of currently open connections.
    *
    * This property may be overridden when creating a connection pool.
    *
    * @default 1
    */
  @scala.inline
  def poolIncrement: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("poolIncrement").asInstanceOf[scala.Double]
  @scala.inline
  def poolIncrement_=(x: scala.Double): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("poolIncrement")(x.asInstanceOf[js.Any])
  
  /**
    * The maximum number of connections to which a connection pool can grow.
    *
    * This property may be overridden when creating a connection pool.
    *
    * Importantly, if you increase poolMax you should also increase the number of threads available to node-oracledb.
    *
    * @default 4
    */
  @scala.inline
  def poolMax: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("poolMax").asInstanceOf[scala.Double]
  
  /**
    * The maximum number of connections per shard for connection pools. This ensures that the pool is balanced towards each shard.
    * 
    * This property may be overridden when creating a connection pool.
    * 
    * When this property is set, and a new connection request would cause the number of connections to the target shard to exceed the limit,
    * then that new connection request will block until a suitable connection has been released back to the pool.
    * Importantly, when blocked, the queueTimeout value will be ignored and the pending connection request will consume one worker thread.
    * 
    * @since 4.1
    */
  @scala.inline
  def poolMaxPerShard: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("poolMaxPerShard").asInstanceOf[scala.Double]
  @scala.inline
  def poolMaxPerShard_=(x: scala.Double): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("poolMaxPerShard")(x.asInstanceOf[js.Any])
  
  @scala.inline
  def poolMax_=(x: scala.Double): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("poolMax")(x.asInstanceOf[js.Any])
  
  /**
    * The minimum number of connections a connection pool maintains, even when there is no activity to the target database.
    *
    * This property may be overridden when creating a connection pool.
    *
    * For pools created with External Authentication or with homogeneous set to false, the number of
    * connections initially created is zero even if a larger value is specified for poolMin.
    * The pool increment is always 1, regardless of the value of poolIncrement.
    * Once the number of open connections exceeds poolMin and connections are idle for more than
    * the poolTimeout seconds, then the number of open connections does not fall below poolMin.
    *
    * @default 0
    */
  @scala.inline
  def poolMin: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("poolMin").asInstanceOf[scala.Double]
  @scala.inline
  def poolMin_=(x: scala.Double): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("poolMin")(x.asInstanceOf[js.Any])
  
  /**
    * When a pool getConnection() is called and the connection has been idle in the pool for at least
    * poolPingInterval seconds, node-oracledb internally “pings” the database to check the connection is alive.
    * After a ping, an unusable connection is destroyed and a usable one is returned by getConnection().
    * Connection pinging improves the chance a pooled connection is valid when it is first used because
    * identified unusable connections will not be returned to the application.
    *
    * This property may be overridden when creating a connection pool.
    *
    * @default 60
    * @since 1.12
    */
  @scala.inline
  def poolPingInterval: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("poolPingInterval").asInstanceOf[scala.Double]
  @scala.inline
  def poolPingInterval_=(x: scala.Double): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("poolPingInterval")(x.asInstanceOf[js.Any])
  
  /**
    * The number of seconds after which idle connections (unused in the pool) are terminated.
    * Idle connections are terminated only when the pool is accessed. If the poolTimeout is set to 0,
    * then idle connections are never terminated.
    *
    * This property may be overridden when creating a connection pool.
    *
    * @default 60
    */
  @scala.inline
  def poolTimeout: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("poolTimeout").asInstanceOf[scala.Double]
  @scala.inline
  def poolTimeout_=(x: scala.Double): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("poolTimeout")(x.asInstanceOf[js.Any])
  
  /**
    * This is a query tuning option to set the number of additional rows the underlying Oracle Client library
    * fetches during the internal initial statement execution phase of a query. The prefetch size does not affect when, or how many,
    * rows are returned by node-oracledb to the application.
    * 
    * The prefetchRows attribute can be used in conjunction with oracledb.fetchArraySize to tune query performance, memory use,
    * and to reduce the number of round-trip calls needed to return query results.
    * 
    * The prefetchRows value is ignored in some cases, such as when the query involves a LOB.
    * 
    * This property may be overridden in an connection.execute() call, which is preferred usage if you need to change the value.
    * 
    * This attribute is not used in node-oracledb version 2, 3 or 4. In those versions use only oracledb.fetchArraySize instead.
    * 
    * @default 2
    * @see https://oracle.github.io/node-oracledb/doc/api.html#rowfetching
    */
  @scala.inline
  def prefetchRows: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("prefetchRows").asInstanceOf[scala.Double]
  @scala.inline
  def prefetchRows_=(x: scala.Double): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("prefetchRows")(x.asInstanceOf[js.Any])
  
  /**
    * The maximum number of pending pool.getConnection() calls that can be queued.
    * 
    * When the number of pool.getConnection() calls that have been queued waiting for an available connection reaches queueMax,
    * then any future pool.getConnection() calls will immediately return an error and will not be queued.
    * 
    * If queueMax is -1, then the queue length is not limited.
    * 
    * This property may be overridden when creating a connection pool.
    * 
    * @default 500
    */
  @scala.inline
  def queueMax: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("queueMax").asInstanceOf[scala.Double]
  @scala.inline
  def queueMax_=(x: scala.Double): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("queueMax")(x.asInstanceOf[js.Any])
  
  /**
    * This property was removed in node-oracledb 3.0 and queuing was always enabled.
    * In node-oracledb 5.0, set queueMax to 0 to disable queuing.
    * 
    * @see https://oracle.github.io/node-oracledb/doc/api.html#connpoolqueue
    */
  @scala.inline
  def queueRequests: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("queueRequests").asInstanceOf[scala.Double]
  @scala.inline
  def queueRequests_=(x: scala.Double): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("queueRequests")(x.asInstanceOf[js.Any])
  
  /**
    * The number of milliseconds after which connection requests waiting in the connection request queue are terminated.
    * If queueTimeout is 0, then queued connection requests are never terminated.
    *
    * This property may be overridden when creating a connection pool.
    *
    * @default 60000
    * @since 1.7
    */
  @scala.inline
  def queueTimeout: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("queueTimeout").asInstanceOf[scala.Double]
  @scala.inline
  def queueTimeout_=(x: scala.Double): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("queueTimeout")(x.asInstanceOf[js.Any])
  
  /**
    * This is the simplified form of connection.shutdown() used for shutting down a database instance. It accepts connection
    * credentials and shuts the database instance completely down.
    * 
    * Internally it creates, and closes, a standalone connection using the oracledb.SYSOPER privilege.
    * 
    * @see https://oracle.github.io/node-oracledb/doc/api.html#startupshutdown
    * @since 5.0
    */
  @scala.inline
  def shutdown(creds: typingsSlinky.oracledb.mod.DBCredentials): js.Promise[scala.Unit] = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("shutdown")(creds.asInstanceOf[js.Any]).asInstanceOf[js.Promise[scala.Unit]]
  @scala.inline
  def shutdown(creds: typingsSlinky.oracledb.mod.DBCredentials, cb: js.Function1[/* err */ js.Error, scala.Unit]): scala.Unit = (typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("shutdown")(creds.asInstanceOf[js.Any], cb.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def shutdown(creds: typingsSlinky.oracledb.mod.DBCredentials, mode: scala.Double): js.Promise[scala.Unit] = (typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("shutdown")(creds.asInstanceOf[js.Any], mode.asInstanceOf[js.Any])).asInstanceOf[js.Promise[scala.Unit]]
  @scala.inline
  def shutdown(
    creds: typingsSlinky.oracledb.mod.DBCredentials,
    mode: scala.Double,
    cb: js.Function1[/* err */ js.Error, scala.Unit]
  ): scala.Unit = (typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("shutdown")(creds.asInstanceOf[js.Any], mode.asInstanceOf[js.Any], cb.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  
  /**
    * This is the simplified form of connection.startup() used for starting a database instance up.
    * It accepts connection credentials and starts the database instance completely.
    * 
    * As part of the start up process, a standalone connection using the oracledb.SYSOPER privilege is internally created and closed.
    * 
    * @see https://oracle.github.io/node-oracledb/doc/api.html#startupshutdown
    * @since 5.0
    */
  @scala.inline
  def startup(creds: typingsSlinky.oracledb.mod.DBCredentials): js.Promise[scala.Unit] = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("startup")(creds.asInstanceOf[js.Any]).asInstanceOf[js.Promise[scala.Unit]]
  @scala.inline
  def startup(creds: typingsSlinky.oracledb.mod.DBCredentials, cb: js.Function1[/* err */ js.Error, scala.Unit]): scala.Unit = (typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("startup")(creds.asInstanceOf[js.Any], cb.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  @scala.inline
  def startup(creds: typingsSlinky.oracledb.mod.DBCredentials, opts: typingsSlinky.oracledb.mod.StartupOptions): js.Promise[scala.Unit] = (typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("startup")(creds.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[js.Promise[scala.Unit]]
  @scala.inline
  def startup(
    creds: typingsSlinky.oracledb.mod.DBCredentials,
    opts: typingsSlinky.oracledb.mod.StartupOptions,
    cb: js.Function1[/* err */ js.Error, scala.Unit]
  ): scala.Unit = (typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("startup")(creds.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], cb.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
  
  /**
    * The number of statements that are cached in the statement cache of each connection.
    *
    * This property may be overridden for specific Pool or Connection objects.
    *
    * In general, set the statement cache to the size of the working set of statements being
    * executed by the application. Statement caching can be disabled by setting the size to 0.
    *
    * @default 30
    */
  @scala.inline
  def stmtCacheSize: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("stmtCacheSize").asInstanceOf[scala.Double]
  @scala.inline
  def stmtCacheSize_=(x: scala.Double): scala.Unit = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("stmtCacheSize")(x.asInstanceOf[js.Any])
  
  /**
    * This readonly property gives a numeric representation of the node-oracledb version.
    * For version x.y.z, this property gives the number: (10000 * x) + (100 * y) + z
    */
  @scala.inline
  def version: scala.Double = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("version").asInstanceOf[scala.Double]
  
  /**
    * This readonly property gives a string representation of the node-oracledb version, including the version suffix if one is present.
    *
    * @since 2.1
    */
  @scala.inline
  def versionString: java.lang.String = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("versionString").asInstanceOf[java.lang.String]
  
  /**
    * This readonly property gives a string representing the version suffix (e.g. “-dev” or “-beta”) or an empty string if no version suffix is present.
    *
    * @since 2.1
    */
  @scala.inline
  def versionSuffix: java.lang.String = typingsSlinky.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("versionSuffix").asInstanceOf[java.lang.String]
}
