package typingsSlinky.squareConnect.mod

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

@JSImport("square-connect", "CatalogPricingRule")
@js.native
class CatalogPricingRule () extends js.Object {
  
  /**
    * @deprecated Please use the `exclude_products_id` field to apply an exclude set instead.
    * Exclude sets allow better control over quantity ranges and offer more flexibility for which matched items receive a discount.
    * `CatalogProductSet` to apply the pricing to. An apply rule matches within the subset of the cart that fits the match
    * rules (the match set). An apply rule can only match once in the match set. If not supplied, the pricing will be
    * applied to all products in the match set. Other products retain their base price, or a price generated by other rules.
    */
  var apply_products_id: js.UndefOr[String] = js.native
  
  /**
    * Unique ID for the `CatalogDiscount` to take off the price of all matched items.
    */
  var discount_id: js.UndefOr[String] = js.native
  
  /**
    * `CatalogProductSet` to exclude from the pricing rule. An exclude rule matches within the subset of the cart that
    * fits the match rules (the match set). An exclude rule can only match once in the match set. If not supplied,
    * the pricing will be applied to all products in the match set. Other products retain their base price, or
    * a price generated by other rules.
    */
  var exclude_products_id: js.UndefOr[String] = js.native
  
  /**
    * If an `exclude_products_id` was given, controls which subset of matched products is excluded from any discounts.
    * Default value: `LEAST_EXPENSIVE` See [ExcludeStrategy](#type-excludestrategy) for possible values.
    */
  var exclude_strategy: js.UndefOr[String] = js.native
  
  /**
    * Unique ID for the `CatalogProductSet` that will be matched by this rule.
    * A match rule matches within the entire cart, and can match multiple times. This field will always be set.
    */
  var match_products_id: js.UndefOr[String] = js.native
  
  /**
    * User-defined name for the pricing rule. For example, "Buy one get one free" or "10% off".
    */
  var name: js.UndefOr[String] = js.native
  
  /**
    * A list of unique IDs for the catalog time periods when this pricing rule is in effect.
    * If left unset, the pricing rule is always in effect.
    */
  var time_period_ids: js.UndefOr[js.Array[String]] = js.native
  
  /**
    * Represents the date the Pricing Rule is valid from. Represented in RFC3339 full-date format (YYYY-MM-DD).
    */
  var valid_from_date: js.UndefOr[String] = js.native
  
  /**
    * Represents the local time the pricing rule should be valid from. Represented in RFC3339 partial-time format (HH:MM:SS).
    * Partial seconds will be truncated.
    */
  var valid_from_local_time: js.UndefOr[String] = js.native
  
  /**
    * Represents the date the Pricing Rule is valid until. Represented in RFC3339 full-date format (YYYY-MM-DD).
    */
  var valid_until_date: js.UndefOr[String] = js.native
  
  /**
    * Represents the local time the pricing rule should be valid until.
    * Represented in RFC3339 partial-time format (HH:MM:SS). Partial seconds will be truncated.
    */
  var valid_until_local_time: js.UndefOr[String] = js.native
}
