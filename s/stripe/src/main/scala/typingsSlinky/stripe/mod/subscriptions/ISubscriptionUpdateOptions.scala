package typingsSlinky.stripe.mod.subscriptions

import typingsSlinky.stripe.mod.IDataOptionsWithMetadata
import typingsSlinky.stripe.mod.cards.ICardSourceCreationOptions
import typingsSlinky.stripe.stripeStrings.always_invoice
import typingsSlinky.stripe.stripeStrings.create_prorations
import typingsSlinky.stripe.stripeStrings.none
import typingsSlinky.stripe.stripeStrings.now
import typingsSlinky.stripe.stripeStrings.unchanged
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

@js.native
trait ISubscriptionUpdateOptions extends IDataOptionsWithMetadata {
  /**
    * A positive decimal (with at most two decimal places) between 1 and 100. This represents the percentage of the subscription invoice
    * subtotal that will be transferred to the application owner’s Stripe account. The request must be made with an OAuth key in order
    * to set an application fee percentage. For more information, see the application fees documentation.
    */
  var application_fee_percent: js.UndefOr[Double] = js.native
  /**
    * Either "charge_automatically", or "send_invoice". When charging automatically, Stripe will attempt to pay this subscription at the end of the
    * cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment
    * instructions.
    */
  var billing: js.UndefOr[SubscriptionBilling] = js.native
  /**
    * String, unchanged (default) or now. This allows you to reset the billing cycle of a subscription.
    */
  var billing_cycle_anchor: js.UndefOr[unchanged | now] = js.native
  /**
    * Boolean indicating whether this subscription should cancel at the end of the current period.
    */
  var cancel_at_period_end: js.UndefOr[Boolean] = js.native
  /**
    * The code of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that
    * particular subscription.  Passing null will remove any coupon previously applied to a subscription.
    */
  var coupon: js.UndefOr[String | Null] = js.native
  /**
    * Number of days a customer has to pay invoices generated by this subscription. Only valid for subscriptions where billing=send_invoice.
    */
  var days_until_due: js.UndefOr[Double] = js.native
  /**
    * ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. If not set, invoices will use the default payment method in the customer’s invoice settings.
    */
  var default_payment_method: js.UndefOr[String] = js.native
  var default_source: js.UndefOr[String | ICardSourceCreationOptions] = js.native
  /**
    * List of subscription items, each with an attached plan.
    */
  var items: js.UndefOr[js.Array[ISubscriptionUpdateItem]] = js.native
  /**
    * Indicates if a customer is on or off-session while an invoice payment is attempted.
    */
  var off_session: js.UndefOr[Boolean] = js.native
  /**
    * Boolean (default true). Used to prevent Stripe Invoicing from automatically paying the subscription when the term changes.
    * This can be set to false when used with services like Avalara that need to augment an invoice before the subscription is paid.
    *
    * Using this flag requires contacting Stripe support in order to have the account whitelisted.
    */
  var pay_immediately: js.UndefOr[Boolean] = js.native
  /**
    * @deprecated Use items property instead.
    */
  var plan: js.UndefOr[String] = js.native
  /**
    * Flag telling us whether to prorate switching plans during a billing cycle.
    */
  var prorate: js.UndefOr[Boolean] = js.native
  /**
    * Determines how to handle prorations when the billing cycle changes or if an item’s quantity changes.
    * Prorations can be disabled by passing none.
    */
  var proration_behavior: js.UndefOr[create_prorations | always_invoice | none] = js.native
  /**
    * If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply exactly the
    * same proration that was previewed with upcoming invoice endpoint. It can also be used to implement custom proration logic, such as
    * prorating by day instead of by second, by providing the time that you wish to use for proration calculations.
    */
  var proration_date: js.UndefOr[Double] = js.native
  /**
    * The quantity you'd like to apply to the subscription you're creating. For example, if your plan is £10/user/month, and your customer
    * has 5 users, you could pass 5 as the quantity to have the customer charged £50 (5 x £10) monthly. If you update a subscription but
    * don't change the plan ID (e.g. changing only the trial_end), the subscription will inherit the old subscription's quantity attribute
    * unless you pass a new quantity parameter. If you update a subscription and change the plan ID, the new subscription will not inherit
    * the quantity attribute and will default to 1 unless you pass a quantity parameter.
    */
  var quantity: js.UndefOr[Double] = js.native
  /**
    * A positive decimal (with at most two decimal places) between 1 and 100. This represents the percentage of the subscription invoice
    * subtotal that will be calculated and added as tax to the final amount each billing period. For example, a plan which charges $10/month
    * with a tax_percent of 20.0 will charge $12 per invoice.
    */
  var tax_percent: js.UndefOr[Double] = js.native
  /**
    * Unix timestamp representing the end of the trial period the customer will get before being charged for the first time. If set, trial_end
    * will override the default trial period of the plan the customer is being subscribed to. The special value now can be provided to end the
    * customer's trial immediately.
    */
  var trial_end: js.UndefOr[Double | now] = js.native
}

object ISubscriptionUpdateOptions {
  @scala.inline
  def apply(): ISubscriptionUpdateOptions = {
    val __obj = js.Dynamic.literal()
    __obj.asInstanceOf[ISubscriptionUpdateOptions]
  }
  @scala.inline
  implicit class ISubscriptionUpdateOptionsOps[Self <: ISubscriptionUpdateOptions] (val x: Self) extends AnyVal {
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    @scala.inline
    def withApplication_fee_percent(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("application_fee_percent")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutApplication_fee_percent: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("application_fee_percent")(js.undefined)
        ret
    }
    @scala.inline
    def withBilling(value: SubscriptionBilling): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("billing")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutBilling: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("billing")(js.undefined)
        ret
    }
    @scala.inline
    def withBilling_cycle_anchor(value: unchanged | now): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("billing_cycle_anchor")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutBilling_cycle_anchor: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("billing_cycle_anchor")(js.undefined)
        ret
    }
    @scala.inline
    def withCancel_at_period_end(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("cancel_at_period_end")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCancel_at_period_end: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("cancel_at_period_end")(js.undefined)
        ret
    }
    @scala.inline
    def withCoupon(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("coupon")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCoupon: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("coupon")(js.undefined)
        ret
    }
    @scala.inline
    def withCouponNull: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("coupon")(null)
        ret
    }
    @scala.inline
    def withDays_until_due(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("days_until_due")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutDays_until_due: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("days_until_due")(js.undefined)
        ret
    }
    @scala.inline
    def withDefault_payment_method(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("default_payment_method")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutDefault_payment_method: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("default_payment_method")(js.undefined)
        ret
    }
    @scala.inline
    def withDefault_source(value: String | ICardSourceCreationOptions): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("default_source")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutDefault_source: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("default_source")(js.undefined)
        ret
    }
    @scala.inline
    def withItems(value: js.Array[ISubscriptionUpdateItem]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("items")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutItems: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("items")(js.undefined)
        ret
    }
    @scala.inline
    def withOff_session(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("off_session")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutOff_session: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("off_session")(js.undefined)
        ret
    }
    @scala.inline
    def withPay_immediately(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("pay_immediately")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutPay_immediately: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("pay_immediately")(js.undefined)
        ret
    }
    @scala.inline
    def withPlan(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("plan")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutPlan: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("plan")(js.undefined)
        ret
    }
    @scala.inline
    def withProrate(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("prorate")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutProrate: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("prorate")(js.undefined)
        ret
    }
    @scala.inline
    def withProration_behavior(value: create_prorations | always_invoice | none): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("proration_behavior")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutProration_behavior: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("proration_behavior")(js.undefined)
        ret
    }
    @scala.inline
    def withProration_date(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("proration_date")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutProration_date: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("proration_date")(js.undefined)
        ret
    }
    @scala.inline
    def withQuantity(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("quantity")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutQuantity: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("quantity")(js.undefined)
        ret
    }
    @scala.inline
    def withTax_percent(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("tax_percent")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTax_percent: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("tax_percent")(js.undefined)
        ret
    }
    @scala.inline
    def withTrial_end(value: Double | now): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("trial_end")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTrial_end: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("trial_end")(js.undefined)
        ret
    }
  }
  
}

