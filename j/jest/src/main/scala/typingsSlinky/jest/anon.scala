package typingsSlinky.jest

import typingsSlinky.jest.jestStrings.get
import typingsSlinky.jest.jestStrings.legacy
import typingsSlinky.jest.jestStrings.modern
import typingsSlinky.jest.jestStrings.set
import typingsSlinky.jest.mod.jasmine.CustomMatcherFactories
import typingsSlinky.jest.mod.jest.ArgsType
import typingsSlinky.jest.mod.jest.ConstructorArgsType
import typingsSlinky.jest.mod.jest.ConstructorPropertyNames
import typingsSlinky.jest.mod.jest.EqualityTester
import typingsSlinky.jest.mod.jest.FunctionPropertyNames
import typingsSlinky.jest.mod.jest.MatcherColorFn
import typingsSlinky.jest.mod.jest.MatcherHintOptions
import typingsSlinky.jest.mod.jest.MockOptions
import typingsSlinky.jest.mod.jest.Mock_
import typingsSlinky.jest.mod.jest.NonFunctionPropertyNames
import typingsSlinky.jest.mod.jest.PrintLabel
import typingsSlinky.jest.mod.jest.SpyInstance
import typingsSlinky.jestDiff.typesMod.DiffOptions
import typingsSlinky.std.InstanceType
import typingsSlinky.std.Required
import typingsSlinky.std.ReturnType
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object anon {
  
  @js.native
  trait `1`[T /* <: js.Array[_] */] extends StObject {
    
    var `1`: js.Array[
        /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any
      ] = js.native
    
    var `10`: js.Tuple10[
        /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[4] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[5] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[6] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[7] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[8] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[9] */ js.Any
      ] = js.native
    
    var `2`: js.Tuple2[
        /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any
      ] = js.native
    
    var `3`: js.Tuple3[
        /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any
      ] = js.native
    
    var `4`: js.Tuple4[
        /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any
      ] = js.native
    
    var `5`: js.Tuple5[
        /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[4] */ js.Any
      ] = js.native
    
    var `6`: js.Tuple6[
        /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[4] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[5] */ js.Any
      ] = js.native
    
    var `7`: js.Tuple7[
        /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[4] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[5] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[6] */ js.Any
      ] = js.native
    
    var `8`: js.Tuple8[
        /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[4] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[5] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[6] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[7] */ js.Any
      ] = js.native
    
    var `9`: js.Tuple9[
        /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[4] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[5] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[6] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[7] */ js.Any, 
        /* import warning: importer.ImportType#apply Failed type conversion: T[8] */ js.Any
      ] = js.native
    
    var fallback: js.Array[_] = js.native
  }
  object `1` {
    
    @scala.inline
    def apply[T /* <: js.Array[_] */](
      `1`: js.Array[
          /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any
        ],
      `10`: js.Tuple10[
          /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[4] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[5] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[6] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[7] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[8] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[9] */ js.Any
        ],
      `2`: js.Tuple2[
          /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any
        ],
      `3`: js.Tuple3[
          /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any
        ],
      `4`: js.Tuple4[
          /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any
        ],
      `5`: js.Tuple5[
          /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[4] */ js.Any
        ],
      `6`: js.Tuple6[
          /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[4] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[5] */ js.Any
        ],
      `7`: js.Tuple7[
          /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[4] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[5] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[6] */ js.Any
        ],
      `8`: js.Tuple8[
          /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[4] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[5] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[6] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[7] */ js.Any
        ],
      `9`: js.Tuple9[
          /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[4] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[5] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[6] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[7] */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: T[8] */ js.Any
        ],
      fallback: js.Array[_]
    ): `1`[T] = {
      val __obj = js.Dynamic.literal(fallback = fallback.asInstanceOf[js.Any])
      __obj.updateDynamic("1")(`1`.asInstanceOf[js.Any])
      __obj.updateDynamic("10")(`10`.asInstanceOf[js.Any])
      __obj.updateDynamic("2")(`2`.asInstanceOf[js.Any])
      __obj.updateDynamic("3")(`3`.asInstanceOf[js.Any])
      __obj.updateDynamic("4")(`4`.asInstanceOf[js.Any])
      __obj.updateDynamic("5")(`5`.asInstanceOf[js.Any])
      __obj.updateDynamic("6")(`6`.asInstanceOf[js.Any])
      __obj.updateDynamic("7")(`7`.asInstanceOf[js.Any])
      __obj.updateDynamic("8")(`8`.asInstanceOf[js.Any])
      __obj.updateDynamic("9")(`9`.asInstanceOf[js.Any])
      __obj.asInstanceOf[`1`[T]]
    }
    
    @scala.inline
    implicit class `1MutableBuilder`[Self <: `1`[_], T /* <: js.Array[_] */] (val x: Self with `1`[T]) extends AnyVal {
      
      @scala.inline
      def set1(
        value: js.Array[
              /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any
            ]
      ): Self = StObject.set(x, "1", value.asInstanceOf[js.Any])
      
      @scala.inline
      def set10(
        value: js.Tuple10[
              /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[4] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[5] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[6] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[7] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[8] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[9] */ js.Any
            ]
      ): Self = StObject.set(x, "10", value.asInstanceOf[js.Any])
      
      @scala.inline
      def set1Varargs(value: (/* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any)*): Self = StObject.set(x, "1", js.Array(value :_*))
      
      @scala.inline
      def set2(
        value: js.Tuple2[
              /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any
            ]
      ): Self = StObject.set(x, "2", value.asInstanceOf[js.Any])
      
      @scala.inline
      def set3(
        value: js.Tuple3[
              /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any
            ]
      ): Self = StObject.set(x, "3", value.asInstanceOf[js.Any])
      
      @scala.inline
      def set4(
        value: js.Tuple4[
              /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any
            ]
      ): Self = StObject.set(x, "4", value.asInstanceOf[js.Any])
      
      @scala.inline
      def set5(
        value: js.Tuple5[
              /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[4] */ js.Any
            ]
      ): Self = StObject.set(x, "5", value.asInstanceOf[js.Any])
      
      @scala.inline
      def set6(
        value: js.Tuple6[
              /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[4] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[5] */ js.Any
            ]
      ): Self = StObject.set(x, "6", value.asInstanceOf[js.Any])
      
      @scala.inline
      def set7(
        value: js.Tuple7[
              /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[4] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[5] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[6] */ js.Any
            ]
      ): Self = StObject.set(x, "7", value.asInstanceOf[js.Any])
      
      @scala.inline
      def set8(
        value: js.Tuple8[
              /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[4] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[5] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[6] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[7] */ js.Any
            ]
      ): Self = StObject.set(x, "8", value.asInstanceOf[js.Any])
      
      @scala.inline
      def set9(
        value: js.Tuple9[
              /* import warning: importer.ImportType#apply Failed type conversion: T[0] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[1] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[2] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[3] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[4] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[5] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[6] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[7] */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: T[8] */ js.Any
            ]
      ): Self = StObject.set(x, "9", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFallback(value: js.Array[_]): Self = StObject.set(x, "fallback", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFallbackVarargs(value: js.Any*): Self = StObject.set(x, "fallback", js.Array(value :_*))
    }
  }
  
  /* Inlined jest.jest.jest.AndNot<{}> */
  @js.native
  trait AndNot extends StObject
  
  @js.native
  trait Args extends StObject {
    
    var args: js.Array[_] = js.native
  }
  object Args {
    
    @scala.inline
    def apply(args: js.Array[_]): Args = {
      val __obj = js.Dynamic.literal(args = args.asInstanceOf[js.Any])
      __obj.asInstanceOf[Args]
    }
    
    @scala.inline
    implicit class ArgsMutableBuilder[Self <: Args] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setArgs(value: js.Array[_]): Self = StObject.set(x, "args", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setArgsVarargs(value: js.Any*): Self = StObject.set(x, "args", js.Array(value :_*))
    }
  }
  
  @js.native
  trait BOLDWEIGHT extends StObject {
    
    val BOLD_WEIGHT: MatcherColorFn = js.native
    
    val DIM_COLOR: MatcherColorFn = js.native
    
    val EXPECTED_COLOR: MatcherColorFn = js.native
    
    val INVERTED_COLOR: MatcherColorFn = js.native
    
    val RECEIVED_COLOR: MatcherColorFn = js.native
    
    val SUGGEST_TO_CONTAIN_EQUAL: String = js.native
    
    def diff(a: js.Any, b: js.Any): String | Null = js.native
    def diff(a: js.Any, b: js.Any, options: DiffOptions): String | Null = js.native
    
    def ensureActualIsNumber(actual: js.Any, matcherName: String): Unit = js.native
    def ensureActualIsNumber(actual: js.Any, matcherName: String, options: MatcherHintOptions): Unit = js.native
    
    def ensureExpectedIsNonNegativeInteger(expected: js.Any, matcherName: String): Unit = js.native
    def ensureExpectedIsNonNegativeInteger(expected: js.Any, matcherName: String, options: MatcherHintOptions): Unit = js.native
    
    def ensureExpectedIsNumber(actual: js.Any, matcherName: String): Unit = js.native
    def ensureExpectedIsNumber(actual: js.Any, matcherName: String, options: MatcherHintOptions): Unit = js.native
    
    def ensureNoExpected(actual: js.Any, matcherName: String): Unit = js.native
    def ensureNoExpected(actual: js.Any, matcherName: String, options: MatcherHintOptions): Unit = js.native
    
    def ensureNumbers(actual: js.Any, expected: js.Any, matcherName: String): Unit = js.native
    def ensureNumbers(actual: js.Any, expected: js.Any, matcherName: String, options: MatcherHintOptions): Unit = js.native
    
    def getLabelPrinter(strings: String*): PrintLabel = js.native
    
    def highlightTrailingWhitespace(text: String): String = js.native
    
    var iterableEquality: EqualityTester = js.native
    
    def matcherErrorMessage(hint: String, generic: String, specific: String): String = js.native
    
    def matcherHint(matcherName: String): String = js.native
    def matcherHint(
      matcherName: String,
      received: js.UndefOr[scala.Nothing],
      expected: js.UndefOr[scala.Nothing],
      options: MatcherHintOptions
    ): String = js.native
    def matcherHint(matcherName: String, received: js.UndefOr[scala.Nothing], expected: String): String = js.native
    def matcherHint(
      matcherName: String,
      received: js.UndefOr[scala.Nothing],
      expected: String,
      options: MatcherHintOptions
    ): String = js.native
    def matcherHint(matcherName: String, received: String): String = js.native
    def matcherHint(
      matcherName: String,
      received: String,
      expected: js.UndefOr[scala.Nothing],
      options: MatcherHintOptions
    ): String = js.native
    def matcherHint(matcherName: String, received: String, expected: String): String = js.native
    def matcherHint(matcherName: String, received: String, expected: String, options: MatcherHintOptions): String = js.native
    
    def pluralize(word: String, count: Double): String = js.native
    
    def printDiffOrStringify(expected: js.Any, received: js.Any, expectedLabel: String, receivedLabel: String, expand: Boolean): String = js.native
    
    def printExpected(value: js.Any): String = js.native
    
    def printReceived(`object`: js.Any): String = js.native
    
    def printWithType(name: String, value: js.Any, print: js.Function1[/* value */ js.Any, String]): String = js.native
    
    def stringify(`object`: js.Object): String = js.native
    def stringify(`object`: js.Object, maxDepth: Double): String = js.native
    
    var subsetEquality: EqualityTester = js.native
  }
  
  /* Inlined jest.jest.jest.JestMatchersShape<{}, {}> */
  @js.native
  trait JestMatchersShape extends StObject {
    
    /**
      * Unwraps the reason of a rejected promise so any other matcher can be chained.
      * If the promise is fulfilled the assertion fails.
      */
    var rejects: AndNot = js.native
    
    /**
      * Use resolves to unwrap the value of a fulfilled promise so any other
      * matcher can be chained. If the promise is rejected the assertion fails.
      */
    var resolves: AndNot = js.native
  }
  object JestMatchersShape {
    
    @scala.inline
    def apply(rejects: AndNot, resolves: AndNot): JestMatchersShape = {
      val __obj = js.Dynamic.literal(rejects = rejects.asInstanceOf[js.Any], resolves = resolves.asInstanceOf[js.Any])
      __obj.asInstanceOf[JestMatchersShape]
    }
    
    @scala.inline
    implicit class JestMatchersShapeMutableBuilder[Self <: JestMatchersShape] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setRejects(value: AndNot): Self = StObject.set(x, "rejects", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setResolves(value: AndNot): Self = StObject.set(x, "resolves", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait Message extends StObject {
    
    var message: String = js.native
  }
  object Message {
    
    @scala.inline
    def apply(message: String): Message = {
      val __obj = js.Dynamic.literal(message = message.asInstanceOf[js.Any])
      __obj.asInstanceOf[Message]
    }
    
    @scala.inline
    implicit class MessageMutableBuilder[Self <: Message] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setMessage(value: String): Self = StObject.set(x, "message", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait Not[T] extends StObject {
    
    var not: T = js.native
  }
  object Not {
    
    @scala.inline
    def apply[T](not: T): Not[T] = {
      val __obj = js.Dynamic.literal(not = not.asInstanceOf[js.Any])
      __obj.asInstanceOf[Not[T]]
    }
    
    @scala.inline
    implicit class NotMutableBuilder[Self <: Not[_], T] (val x: Self with Not[T]) extends AnyVal {
      
      @scala.inline
      def setNot(value: T): Self = StObject.set(x, "not", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait Rejects[TPromise /* <: js.Object */] extends StObject {
    
    /**
      * Unwraps the reason of a rejected promise so any other matcher can be chained.
      * If the promise is fulfilled the assertion fails.
      */
    var rejects: typingsSlinky.jest.mod.jest.AndNot[TPromise] = js.native
    
    /**
      * Use resolves to unwrap the value of a fulfilled promise so any other
      * matcher can be chained. If the promise is rejected the assertion fails.
      */
    var resolves: typingsSlinky.jest.mod.jest.AndNot[TPromise] = js.native
  }
  object Rejects {
    
    @scala.inline
    def apply[TPromise /* <: js.Object */](
      rejects: typingsSlinky.jest.mod.jest.AndNot[TPromise],
      resolves: typingsSlinky.jest.mod.jest.AndNot[TPromise]
    ): Rejects[TPromise] = {
      val __obj = js.Dynamic.literal(rejects = rejects.asInstanceOf[js.Any], resolves = resolves.asInstanceOf[js.Any])
      __obj.asInstanceOf[Rejects[TPromise]]
    }
    
    @scala.inline
    implicit class RejectsMutableBuilder[Self <: Rejects[_], TPromise /* <: js.Object */] (val x: Self with Rejects[TPromise]) extends AnyVal {
      
      @scala.inline
      def setRejects(value: typingsSlinky.jest.mod.jest.AndNot[TPromise]): Self = StObject.set(x, "rejects", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setResolves(value: typingsSlinky.jest.mod.jest.AndNot[TPromise]): Self = StObject.set(x, "resolves", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait Typeofjest extends StObject {
    
    /**
      * Provides a way to add Jasmine-compatible matchers into your Jest context.
      */
    def addMatchers(matchers: CustomMatcherFactories): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Advances all timers by msToRun milliseconds. All pending "macro-tasks" that have been
      * queued via setTimeout() or setInterval(), and would be executed within this timeframe
      * will be executed.
      */
    def advanceTimersByTime(msToRun: Double): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Advances all timers by the needed milliseconds so that only the next
      * timeouts/intervals will run. Optionally, you can provide steps, so it
      * will run steps amount of next timeouts/intervals.
      */
    def advanceTimersToNextTimer(): Unit = js.native
    def advanceTimersToNextTimer(step: Double): Unit = js.native
    
    /**
      * Disables automatic mocking in the module loader.
      */
    def autoMockOff(): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Enables automatic mocking in the module loader.
      */
    def autoMockOn(): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Clears the mock.calls and mock.instances properties of all mocks.
      * Equivalent to calling .mockClear() on every mocked function.
      */
    def clearAllMocks(): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Removes any pending timers from the timer system. If any timers have
      * been scheduled, they will be cleared and will never have the opportunity
      * to execute in the future.
      */
    def clearAllTimers(): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Use the automatic mocking system to generate a mocked version of the given module.
      */
    // tslint:disable-next-line: no-unnecessary-generics
    def createMockFromModule[T](moduleName: String): T = js.native
    
    /**
      * Indicates that the module system should never return a mocked version
      * of the specified module, including all of the specificied module's dependencies.
      */
    def deepUnmock(moduleName: String): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Disables automatic mocking in the module loader.
      */
    def disableAutomock(): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Mocks a module with an auto-mocked version when it is being required.
      */
    def doMock(moduleName: String): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    def doMock(moduleName: String, factory: js.UndefOr[scala.Nothing], options: MockOptions): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    def doMock(moduleName: String, factory: js.Function0[_]): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    def doMock(moduleName: String, factory: js.Function0[_], options: MockOptions): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Indicates that the module system should never return a mocked version
      * of the specified module from require() (e.g. that it should always return the real module).
      */
    def dontMock(moduleName: String): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Enables automatic mocking in the module loader.
      */
    def enableAutomock(): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Creates a mock function. Optionally takes a mock implementation.
      */
    def fn(): Mock_[_, _] = js.native
    def fn[T, Y /* <: js.Array[_] */](implementation: js.Function1[/* args */ Y, T]): Mock_[T, Y] = js.native
    /**
      * Creates a mock function. Optionally takes a mock implementation.
      */
    @JSName("fn")
    def fn_TY_ArrayWildcard[T, Y /* <: js.Array[_] */](): Mock_[T, Y] = js.native
    
    /**
      * (renamed to `createMockFromModule` in Jest 26.0.0+)
      * Use the automatic mocking system to generate a mocked version of the given module.
      */
    // tslint:disable-next-line: no-unnecessary-generics
    def genMockFromModule[T](moduleName: String): T = js.native
    
    /**
      * When mocking time, Date.now() will also be mocked. If you for some
      * reason need access to the real current time, you can invoke this
      * function.
      *
      * > Note: This function is only available when using modern fake timers
      * > implementation
      */
    def getRealSystemTime(): Double = js.native
    
    /**
      * Returns the number of fake timers still left to run.
      */
    def getTimerCount(): Double = js.native
    
    /**
      * Returns whether the given function is a mock function.
      */
    def isMockFunction(fn: js.Any): /* is jest.jest.jest.Mock<any, any> */ Boolean = js.native
    
    /**
      * Creates a sandbox registry for the modules that are loaded inside the callback function..
      * This is useful to isolate specific modules for every test so that local module state doesn't conflict between tests.
      */
    def isolateModules(fn: js.Function0[Unit]): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Mocks a module with an auto-mocked version when it is being required.
      */
    def mock(moduleName: String): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    def mock(moduleName: String, factory: js.UndefOr[scala.Nothing], options: MockOptions): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    def mock(moduleName: String, factory: js.Function0[_]): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    def mock(moduleName: String, factory: js.Function0[_], options: MockOptions): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Returns the actual module instead of a mock, bypassing all checks on
      * whether the module should receive a mock implementation or not.
      */
    // tslint:disable-next-line: no-unnecessary-generics
    def requireActual[TModule](moduleName: String): TModule = js.native
    
    /**
      * Returns a mock module instead of the actual module, bypassing all checks
      * on whether the module should be required normally or not.
      */
    // tslint:disable-next-line: no-unnecessary-generics
    def requireMock[TModule](moduleName: String): TModule = js.native
    
    /**
      * Resets the state of all mocks.
      * Equivalent to calling .mockReset() on every mocked function.
      */
    def resetAllMocks(): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Resets the module registry - the cache of all required modules. This is
      * useful to isolate modules where local state might conflict between tests.
      */
    def resetModuleRegistry(): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Resets the module registry - the cache of all required modules. This is
      * useful to isolate modules where local state might conflict between tests.
      */
    def resetModules(): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * available since Jest 21.1.0
      * Restores all mocks back to their original value.
      * Equivalent to calling .mockRestore on every mocked function.
      * Beware that jest.restoreAllMocks() only works when mock was created with
      * jest.spyOn; other mocks will require you to manually restore them.
      */
    def restoreAllMocks(): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Runs failed tests n-times until they pass or until the max number of retries is exhausted.
      * This only works with jest-circus!
      */
    def retryTimes(numRetries: Double): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Exhausts tasks queued by setImmediate().
      */
    def runAllImmediates(): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Exhausts the micro-task queue (usually interfaced in node via process.nextTick).
      */
    def runAllTicks(): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Exhausts the macro-task queue (i.e., all tasks queued by setTimeout() and setInterval()).
      */
    def runAllTimers(): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Executes only the macro-tasks that are currently pending (i.e., only the
      * tasks that have been queued by setTimeout() or setInterval() up to this point).
      * If any of the currently pending macro-tasks schedule new macro-tasks,
      * those new tasks will not be executed by this call.
      */
    def runOnlyPendingTimers(): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * (renamed to `advanceTimersByTime` in Jest 21.3.0+) Executes only the macro
      * task queue (i.e. all tasks queued by setTimeout() or setInterval() and setImmediate()).
      */
    def runTimersToTime(msToRun: Double): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Explicitly supplies the mock object that the module system should return
      * for the specified module.
      */
    // tslint:disable-next-line: no-unnecessary-generics
    def setMock[T](moduleName: String, moduleExports: T): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Set the current system time used by fake timers. Simulates a user
      * changing the system clock while your program is running. It affects the
      * current time but it does not in itself cause e.g. timers to fire; they
      * will fire exactly as they would have done without the call to
      * jest.setSystemTime().
      *
      * > Note: This function is only available when using modern fake timers
      * > implementation
      */
    def setSystemTime(): Unit = js.native
    def setSystemTime(now: js.Date): Unit = js.native
    def setSystemTime(now: Double): Unit = js.native
    
    /**
      * Set the default timeout interval for tests and before/after hooks in milliseconds.
      * Note: The default timeout interval is 5 seconds if this method is not called.
      */
    def setTimeout(timeout: Double): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    def spyOn[T /* <: js.Object */, M /* <: FunctionPropertyNames[Required[T]] */](`object`: T, method: M): SpyInstance[
        ReturnType[
          /* import warning: importer.ImportType#apply Failed type conversion: std.Required<T>[M] */ js.Any
        ], 
        ArgsType[
          /* import warning: importer.ImportType#apply Failed type conversion: std.Required<T>[M] */ js.Any
        ]
      ] = js.native
    @JSName("spyOn")
    def spyOn_T_ObjectM_ConstructorPropertyNamesRequiredT[T /* <: js.Object */, M /* <: ConstructorPropertyNames[Required[T]] */](`object`: T, method: M): SpyInstance[
        InstanceType[
          /* import warning: importer.ImportType#apply Failed type conversion: std.Required<T>[M] */ js.Any
        ], 
        ConstructorArgsType[
          /* import warning: importer.ImportType#apply Failed type conversion: std.Required<T>[M] */ js.Any
        ]
      ] = js.native
    /**
      * Creates a mock function similar to jest.fn but also tracks calls to `object[methodName]`
      *
      * Note: By default, jest.spyOn also calls the spied method. This is different behavior from most
      * other test libraries.
      *
      * @example
      *
      * const video = require('./video');
      *
      * test('plays video', () => {
      *   const spy = jest.spyOn(video, 'play');
      *   const isPlaying = video.play();
      *
      *   expect(spy).toHaveBeenCalled();
      *   expect(isPlaying).toBe(true);
      *
      *   spy.mockReset();
      *   spy.mockRestore();
      * });
      */
    @JSName("spyOn")
    def spyOn_get[T /* <: js.Object */, M /* <: NonFunctionPropertyNames[Required[T]] */](`object`: T, method: M, accessType: get): SpyInstance[
        /* import warning: importer.ImportType#apply Failed type conversion: std.Required<T>[M] */ js.Any, 
        js.Array[js.Any]
      ] = js.native
    @JSName("spyOn")
    def spyOn_set[T /* <: js.Object */, M /* <: NonFunctionPropertyNames[Required[T]] */](`object`: T, method: M, accessType: set): SpyInstance[
        Unit, 
        js.Array[
          /* import warning: importer.ImportType#apply Failed type conversion: std.Required<T>[M] */ js.Any
        ]
      ] = js.native
    
    /**
      * Indicates that the module system should never return a mocked version of
      * the specified module from require() (e.g. that it should always return the real module).
      */
    def unmock(moduleName: String): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Instructs Jest to use fake versions of the standard timer functions.
      */
    def useFakeTimers(): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    @JSName("useFakeTimers")
    def useFakeTimers_legacy(implementation: legacy): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    @JSName("useFakeTimers")
    def useFakeTimers_modern(implementation: modern): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
    
    /**
      * Instructs Jest to use the real versions of the standard timer functions.
      */
    def useRealTimers(): /* import warning: importer.ImportType#apply Failed type conversion: typeof jest */ js.Any = js.native
  }
}
