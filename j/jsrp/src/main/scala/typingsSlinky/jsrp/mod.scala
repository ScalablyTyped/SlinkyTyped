package typingsSlinky.jsrp

import typingsSlinky.jsrp.jsrpNumbers.`2048`
import typingsSlinky.jsrp.jsrpNumbers.`4096`
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  @JSImport("jsrp", "client")
  @js.native
  /** Client SRP constructor */
  class client () extends StObject {
    
    /**
      * Verifies the server's M2 proof against the client's. Only call after using {@link getProof}.
      * @param hexM2 - hex representation of M2
      * @returns true if it matches the client's proof, false if it doesn't
      */
    def checkServerProof(hexM2: String): Boolean = js.native
    
    /**
      * Generate the v and salt values from values passed into init().
      * @param callback - callback has an error as the first argument, or an object containing the verifier and salt as the second.
      */
    def createVerifier(callback: js.Function2[/* error */ js.Any, /* result */ Verifier, _]): Unit = js.native
    
    /**
      * Returns the hex representation of the client's M1 proof
      * @returns hex representation of M1
      */
    def getProof(): String = js.native
    
    /**
      * Returns the hex representation of the client's A value
      * @returns hex representation of A
      */
    def getPublicKey(): String = js.native
    
    /**
      * Returns the hex representation of the salt
      * @returns hex representation of the salt
      */
    def getSalt(): String = js.native
    
    /**
      * Returns the hex representation of the shared secret key, K
      * @returns hex representation of K
      */
    def getSharedKey(): String = js.native
    
    /**
      * Initialise the client SRP and calculate needed SRP values
      * @param options - the client options including the username and password
      * @param callback - called when the client instance is ready to use
      */
    def init(options: ClientOptions, callback: js.Function0[_]): Unit = js.native
    
    /**
      * Set the salt generated by the server for later computations
      * @param hexSalt - hex value of the salt
      */
    def setSalt(hexSalt: String): Unit = js.native
    
    /**
      * Sets the server's B value on the client and compute values to complete authentication
      * @param hexB - hex representation of B
      * @throws Will throw an error if the server provides an incorrect value
      */
    def setServerPublicKey(hexB: String): Unit = js.native
  }
  
  @JSImport("jsrp", "server")
  @js.native
  /** Client SRP constructor */
  class server () extends StObject {
    
    /**
      * Verifies the clients's M1 proof against the server's.
      * @param M1hex - hex representation of M1
      * @returns true if it matches the server's proof, false if it doesn't
      */
    def checkClientProof(M1hex: String): Boolean = js.native
    
    /**
      * Returns the hex representation of the server's M2 proof
      * @returns hex representation of M2
      */
    def getProof(): String = js.native
    
    /**
      * Returns the hex representation of the server's B value
      * @returns hex representation of B
      */
    def getPublicKey(): String = js.native
    
    /**
      * Returns the hex representation of the salt, as was passed into {@link init}
      * @returns hex representation of the salt
      */
    def getSalt(): String = js.native
    
    /**
      * Returns the hex representation of the shared secret key, K
      * @returns hex representation of K
      */
    def getSharedKey(): String = js.native
    
    /**
      * Initialise the server SRP and calculate needed SRP values
      * @param options - the server options including the verifier and salt
      * @param callback - called when the server instance is ready to use
      */
    def init(options: ServerOptions, callback: js.Function0[_]): Unit = js.native
    
    /**
      * Sets the client's A value on the server, and compute values to complete authentication
      * @param hexA - hex representation of A
      * @throws Will throw an error if the client provides an incorrect value
      */
    def setClientPublicKey(hexA: String): Unit = js.native
  }
  
  @js.native
  trait ClientOptions extends StObject {
    
    var length: js.UndefOr[`2048` | `4096`] = js.native
    
    var password: String = js.native
    
    var username: String = js.native
  }
  object ClientOptions {
    
    @scala.inline
    def apply(password: String, username: String): ClientOptions = {
      val __obj = js.Dynamic.literal(password = password.asInstanceOf[js.Any], username = username.asInstanceOf[js.Any])
      __obj.asInstanceOf[ClientOptions]
    }
    
    @scala.inline
    implicit class ClientOptionsMutableBuilder[Self <: ClientOptions] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setLength(value: `2048` | `4096`): Self = StObject.set(x, "length", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLengthUndefined: Self = StObject.set(x, "length", js.undefined)
      
      @scala.inline
      def setPassword(value: String): Self = StObject.set(x, "password", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUsername(value: String): Self = StObject.set(x, "username", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait ServerOptions extends StObject {
    
    var length: js.UndefOr[`2048` | `4096`] = js.native
    
    var salt: String = js.native
    
    var verifier: String = js.native
  }
  object ServerOptions {
    
    @scala.inline
    def apply(salt: String, verifier: String): ServerOptions = {
      val __obj = js.Dynamic.literal(salt = salt.asInstanceOf[js.Any], verifier = verifier.asInstanceOf[js.Any])
      __obj.asInstanceOf[ServerOptions]
    }
    
    @scala.inline
    implicit class ServerOptionsMutableBuilder[Self <: ServerOptions] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setLength(value: `2048` | `4096`): Self = StObject.set(x, "length", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLengthUndefined: Self = StObject.set(x, "length", js.undefined)
      
      @scala.inline
      def setSalt(value: String): Self = StObject.set(x, "salt", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setVerifier(value: String): Self = StObject.set(x, "verifier", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait Verifier extends StObject {
    
    var salt: String = js.native
    
    var verifier: String = js.native
  }
  object Verifier {
    
    @scala.inline
    def apply(salt: String, verifier: String): Verifier = {
      val __obj = js.Dynamic.literal(salt = salt.asInstanceOf[js.Any], verifier = verifier.asInstanceOf[js.Any])
      __obj.asInstanceOf[Verifier]
    }
    
    @scala.inline
    implicit class VerifierMutableBuilder[Self <: Verifier] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setSalt(value: String): Self = StObject.set(x, "salt", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setVerifier(value: String): Self = StObject.set(x, "verifier", value.asInstanceOf[js.Any])
    }
  }
}
