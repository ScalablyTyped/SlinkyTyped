package typingsSlinky.babylonWalk

import typingsSlinky.babelTypes.ts36Mod.AnyTypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.ArrayExpression_
import typingsSlinky.babelTypes.ts36Mod.ArrayPattern_
import typingsSlinky.babelTypes.ts36Mod.ArrayTypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.ArrowFunctionExpression_
import typingsSlinky.babelTypes.ts36Mod.AssignmentExpression_
import typingsSlinky.babelTypes.ts36Mod.AssignmentPattern_
import typingsSlinky.babelTypes.ts36Mod.AwaitExpression_
import typingsSlinky.babelTypes.ts36Mod.BinaryExpression_
import typingsSlinky.babelTypes.ts36Mod.BindExpression_
import typingsSlinky.babelTypes.ts36Mod.BlockStatement_
import typingsSlinky.babelTypes.ts36Mod.BooleanLiteralTypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.BooleanLiteral_
import typingsSlinky.babelTypes.ts36Mod.BooleanTypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.BreakStatement_
import typingsSlinky.babelTypes.ts36Mod.CallExpression_
import typingsSlinky.babelTypes.ts36Mod.CatchClause_
import typingsSlinky.babelTypes.ts36Mod.ClassBody_
import typingsSlinky.babelTypes.ts36Mod.ClassDeclaration_
import typingsSlinky.babelTypes.ts36Mod.ClassExpression_
import typingsSlinky.babelTypes.ts36Mod.ClassImplements_
import typingsSlinky.babelTypes.ts36Mod.ClassMethod_
import typingsSlinky.babelTypes.ts36Mod.ClassProperty_
import typingsSlinky.babelTypes.ts36Mod.ConditionalExpression_
import typingsSlinky.babelTypes.ts36Mod.ContinueStatement_
import typingsSlinky.babelTypes.ts36Mod.DebuggerStatement_
import typingsSlinky.babelTypes.ts36Mod.DeclareClass_
import typingsSlinky.babelTypes.ts36Mod.DeclareFunction_
import typingsSlinky.babelTypes.ts36Mod.DeclareInterface_
import typingsSlinky.babelTypes.ts36Mod.DeclareModule_
import typingsSlinky.babelTypes.ts36Mod.DeclareTypeAlias_
import typingsSlinky.babelTypes.ts36Mod.DeclareVariable_
import typingsSlinky.babelTypes.ts36Mod.Decorator_
import typingsSlinky.babelTypes.ts36Mod.DirectiveLiteral_
import typingsSlinky.babelTypes.ts36Mod.Directive_
import typingsSlinky.babelTypes.ts36Mod.DoExpression_
import typingsSlinky.babelTypes.ts36Mod.DoWhileStatement_
import typingsSlinky.babelTypes.ts36Mod.EmptyStatement_
import typingsSlinky.babelTypes.ts36Mod.ExportAllDeclaration_
import typingsSlinky.babelTypes.ts36Mod.ExportDefaultDeclaration_
import typingsSlinky.babelTypes.ts36Mod.ExportDefaultSpecifier_
import typingsSlinky.babelTypes.ts36Mod.ExportNamedDeclaration_
import typingsSlinky.babelTypes.ts36Mod.ExportNamespaceSpecifier_
import typingsSlinky.babelTypes.ts36Mod.ExportSpecifier_
import typingsSlinky.babelTypes.ts36Mod.ExpressionStatement_
import typingsSlinky.babelTypes.ts36Mod.File_
import typingsSlinky.babelTypes.ts36Mod.ForInStatement_
import typingsSlinky.babelTypes.ts36Mod.ForOfStatement_
import typingsSlinky.babelTypes.ts36Mod.ForStatement_
import typingsSlinky.babelTypes.ts36Mod.FunctionDeclaration_
import typingsSlinky.babelTypes.ts36Mod.FunctionExpression_
import typingsSlinky.babelTypes.ts36Mod.FunctionTypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.FunctionTypeParam_
import typingsSlinky.babelTypes.ts36Mod.GenericTypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.Identifier_
import typingsSlinky.babelTypes.ts36Mod.IfStatement_
import typingsSlinky.babelTypes.ts36Mod.ImportDeclaration_
import typingsSlinky.babelTypes.ts36Mod.ImportDefaultSpecifier_
import typingsSlinky.babelTypes.ts36Mod.ImportNamespaceSpecifier_
import typingsSlinky.babelTypes.ts36Mod.ImportSpecifier_
import typingsSlinky.babelTypes.ts36Mod.InterfaceDeclaration_
import typingsSlinky.babelTypes.ts36Mod.InterfaceExtends_
import typingsSlinky.babelTypes.ts36Mod.IntersectionTypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.JSXAttribute_
import typingsSlinky.babelTypes.ts36Mod.JSXClosingElement_
import typingsSlinky.babelTypes.ts36Mod.JSXElement_
import typingsSlinky.babelTypes.ts36Mod.JSXEmptyExpression_
import typingsSlinky.babelTypes.ts36Mod.JSXExpressionContainer_
import typingsSlinky.babelTypes.ts36Mod.JSXIdentifier_
import typingsSlinky.babelTypes.ts36Mod.JSXMemberExpression_
import typingsSlinky.babelTypes.ts36Mod.JSXNamespacedName_
import typingsSlinky.babelTypes.ts36Mod.JSXOpeningElement_
import typingsSlinky.babelTypes.ts36Mod.JSXSpreadAttribute_
import typingsSlinky.babelTypes.ts36Mod.JSXText_
import typingsSlinky.babelTypes.ts36Mod.LabeledStatement_
import typingsSlinky.babelTypes.ts36Mod.LogicalExpression_
import typingsSlinky.babelTypes.ts36Mod.MemberExpression_
import typingsSlinky.babelTypes.ts36Mod.MetaProperty_
import typingsSlinky.babelTypes.ts36Mod.MixedTypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.NewExpression_
import typingsSlinky.babelTypes.ts36Mod.Node
import typingsSlinky.babelTypes.ts36Mod.Noop_
import typingsSlinky.babelTypes.ts36Mod.NullLiteralTypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.NullLiteral_
import typingsSlinky.babelTypes.ts36Mod.NullableTypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.NumberTypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.NumericLiteral_
import typingsSlinky.babelTypes.ts36Mod.ObjectExpression_
import typingsSlinky.babelTypes.ts36Mod.ObjectMethod_
import typingsSlinky.babelTypes.ts36Mod.ObjectPattern_
import typingsSlinky.babelTypes.ts36Mod.ObjectProperty_
import typingsSlinky.babelTypes.ts36Mod.ObjectTypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.ObjectTypeCallProperty_
import typingsSlinky.babelTypes.ts36Mod.ObjectTypeIndexer_
import typingsSlinky.babelTypes.ts36Mod.ObjectTypeProperty_
import typingsSlinky.babelTypes.ts36Mod.ParenthesizedExpression_
import typingsSlinky.babelTypes.ts36Mod.Program_
import typingsSlinky.babelTypes.ts36Mod.QualifiedTypeIdentifier_
import typingsSlinky.babelTypes.ts36Mod.RegExpLiteral_
import typingsSlinky.babelTypes.ts36Mod.RestElement_
import typingsSlinky.babelTypes.ts36Mod.ReturnStatement_
import typingsSlinky.babelTypes.ts36Mod.SequenceExpression_
import typingsSlinky.babelTypes.ts36Mod.SpreadElement_
import typingsSlinky.babelTypes.ts36Mod.StringLiteralTypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.StringLiteral_
import typingsSlinky.babelTypes.ts36Mod.StringTypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.Super
import typingsSlinky.babelTypes.ts36Mod.SwitchCase_
import typingsSlinky.babelTypes.ts36Mod.SwitchStatement_
import typingsSlinky.babelTypes.ts36Mod.TaggedTemplateExpression_
import typingsSlinky.babelTypes.ts36Mod.TemplateElement_
import typingsSlinky.babelTypes.ts36Mod.TemplateLiteral_
import typingsSlinky.babelTypes.ts36Mod.ThisExpression_
import typingsSlinky.babelTypes.ts36Mod.ThisTypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.ThrowStatement_
import typingsSlinky.babelTypes.ts36Mod.TryStatement_
import typingsSlinky.babelTypes.ts36Mod.TupleTypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.TypeAlias_
import typingsSlinky.babelTypes.ts36Mod.TypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.TypeCastExpression_
import typingsSlinky.babelTypes.ts36Mod.TypeParameterDeclaration_
import typingsSlinky.babelTypes.ts36Mod.TypeParameterInstantiation_
import typingsSlinky.babelTypes.ts36Mod.TypeofTypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.UnaryExpression_
import typingsSlinky.babelTypes.ts36Mod.UnionTypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.UpdateExpression_
import typingsSlinky.babelTypes.ts36Mod.VariableDeclaration_
import typingsSlinky.babelTypes.ts36Mod.VariableDeclarator_
import typingsSlinky.babelTypes.ts36Mod.VoidTypeAnnotation_
import typingsSlinky.babelTypes.ts36Mod.WhileStatement_
import typingsSlinky.babelTypes.ts36Mod.WithStatement_
import typingsSlinky.babelTypes.ts36Mod.YieldExpression_
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  @JSImport("babylon-walk", "ancestor")
  @js.native
  def ancestor(node: NodeTypes, visitors: visitors[AncestorVisitor], state: js.Any): Unit = js.native
  
  @JSImport("babylon-walk", "recursive")
  @js.native
  def recursive(node: NodeTypes, visitors: visitors[RecursiveVisitor], state: js.Any): Unit = js.native
  
  @JSImport("babylon-walk", "simple")
  @js.native
  def simple(node: NodeTypes, visitors: visitors[SimpleVisitor], state: js.Any): Unit = js.native
  
  type AncestorStatelessVisitor = js.Function3[/* node */ NodeTypes, /* state */ js.Any, /* ancestors */ js.Array[Node], Unit]
  
  type AncestorVisitor = js.Function3[/* node */ NodeTypes, /* state */ js.Any, /* ancestors */ js.Array[Node], Unit]
  
  type NodeTypes = coreTypes | es2015Types | flowTypes | jsxTypes | miscTypes
  
  type RecursiveVisitor = js.Function3[
    /* node */ NodeTypes, 
    /* state */ js.Any, 
    /* next */ js.Function1[/* node */ Node, Unit], 
    Unit
  ]
  
  type SimpleVisitor = js.Function2[/* node */ NodeTypes, /* state */ js.Any, Unit]
  
  type Visitor = js.Function2[/* commentBlock */ NodeTypes, /* state */ js.Any, Unit]
  
  type coreTypes = ArrayExpression_ | AssignmentExpression_ | BinaryExpression_ | Directive_ | DirectiveLiteral_ | BlockStatement_ | BreakStatement_ | CallExpression_ | CatchClause_ | ConditionalExpression_ | ContinueStatement_ | DebuggerStatement_ | DoWhileStatement_ | EmptyStatement_ | ExpressionStatement_ | File_ | ForInStatement_ | ForStatement_ | FunctionDeclaration_ | FunctionExpression_ | Identifier_ | IfStatement_ | LabeledStatement_ | StringLiteral_ | NumericLiteral_ | NullLiteral_ | BooleanLiteral_ | RegExpLiteral_ | LogicalExpression_ | MemberExpression_ | NewExpression_ | Program_ | ObjectExpression_ | ObjectMethod_ | ObjectProperty_ | RestElement_ | ReturnStatement_ | SequenceExpression_ | SwitchCase_ | SwitchStatement_ | ThisExpression_ | ThrowStatement_ | TryStatement_ | UnaryExpression_ | UpdateExpression_ | VariableDeclaration_ | VariableDeclarator_ | WhileStatement_ | WithStatement_
  
  @js.native
  trait coreVisitors[V] extends StObject {
    
    var ArrayExpression: js.UndefOr[V] = js.native
    
    var AssignmentExpression: js.UndefOr[V] = js.native
    
    var BinaryExpression: js.UndefOr[V] = js.native
    
    var BlockStatement: js.UndefOr[V] = js.native
    
    var BooleanLiteral: js.UndefOr[V] = js.native
    
    var BreakStatement: js.UndefOr[V] = js.native
    
    var CallExpression: js.UndefOr[V] = js.native
    
    var CatchClause: js.UndefOr[V] = js.native
    
    var ConditionalExpression: js.UndefOr[V] = js.native
    
    var ContinueStatement: js.UndefOr[V] = js.native
    
    var DebuggerStatement: js.UndefOr[V] = js.native
    
    var Directive: js.UndefOr[V] = js.native
    
    var DirectiveLiteral: js.UndefOr[V] = js.native
    
    var DoWhileStatement: js.UndefOr[V] = js.native
    
    var EmptyStatement: js.UndefOr[V] = js.native
    
    var ExpressionStatement: js.UndefOr[V] = js.native
    
    var File: js.UndefOr[V] = js.native
    
    var ForInStatement: js.UndefOr[V] = js.native
    
    var ForStatement: js.UndefOr[V] = js.native
    
    var FunctionDeclaration: js.UndefOr[V] = js.native
    
    var FunctionExpression: js.UndefOr[V] = js.native
    
    var Identifier: js.UndefOr[V] = js.native
    
    var IfStatement: js.UndefOr[V] = js.native
    
    var LabeledStatement: js.UndefOr[V] = js.native
    
    var LogicalExpression: js.UndefOr[V] = js.native
    
    var MemberExpression: js.UndefOr[V] = js.native
    
    var NewExpression: js.UndefOr[V] = js.native
    
    var NullLiteral: js.UndefOr[V] = js.native
    
    var NumericLiteral: js.UndefOr[V] = js.native
    
    var ObjectExpression: js.UndefOr[V] = js.native
    
    var ObjectMethod: js.UndefOr[V] = js.native
    
    var ObjectProperty: js.UndefOr[V] = js.native
    
    var Program: js.UndefOr[V] = js.native
    
    var RegExpLiteral: js.UndefOr[V] = js.native
    
    var RestElement: js.UndefOr[V] = js.native
    
    var ReturnStatement: js.UndefOr[V] = js.native
    
    var SequenceExpression: js.UndefOr[V] = js.native
    
    var StringLiteral: js.UndefOr[V] = js.native
    
    var SwitchCase: js.UndefOr[V] = js.native
    
    var SwitchStatement: js.UndefOr[V] = js.native
    
    var ThisExpression: js.UndefOr[V] = js.native
    
    var ThrowStatement: js.UndefOr[V] = js.native
    
    var TryStatement: js.UndefOr[V] = js.native
    
    var UnaryExpression: js.UndefOr[V] = js.native
    
    var UpdateExpression: js.UndefOr[V] = js.native
    
    var VariableDeclaration: js.UndefOr[V] = js.native
    
    var VariableDeclarator: js.UndefOr[V] = js.native
    
    var WhileStatement: js.UndefOr[V] = js.native
    
    var WithStatement: js.UndefOr[V] = js.native
  }
  object coreVisitors {
    
    @scala.inline
    def apply[V](): coreVisitors[V] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[coreVisitors[V]]
    }
    
    @scala.inline
    implicit class coreVisitorsMutableBuilder[Self <: coreVisitors[_], V] (val x: Self with coreVisitors[V]) extends AnyVal {
      
      @scala.inline
      def setArrayExpression(value: V): Self = StObject.set(x, "ArrayExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setArrayExpressionUndefined: Self = StObject.set(x, "ArrayExpression", js.undefined)
      
      @scala.inline
      def setAssignmentExpression(value: V): Self = StObject.set(x, "AssignmentExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAssignmentExpressionUndefined: Self = StObject.set(x, "AssignmentExpression", js.undefined)
      
      @scala.inline
      def setBinaryExpression(value: V): Self = StObject.set(x, "BinaryExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBinaryExpressionUndefined: Self = StObject.set(x, "BinaryExpression", js.undefined)
      
      @scala.inline
      def setBlockStatement(value: V): Self = StObject.set(x, "BlockStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBlockStatementUndefined: Self = StObject.set(x, "BlockStatement", js.undefined)
      
      @scala.inline
      def setBooleanLiteral(value: V): Self = StObject.set(x, "BooleanLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBooleanLiteralUndefined: Self = StObject.set(x, "BooleanLiteral", js.undefined)
      
      @scala.inline
      def setBreakStatement(value: V): Self = StObject.set(x, "BreakStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBreakStatementUndefined: Self = StObject.set(x, "BreakStatement", js.undefined)
      
      @scala.inline
      def setCallExpression(value: V): Self = StObject.set(x, "CallExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCallExpressionUndefined: Self = StObject.set(x, "CallExpression", js.undefined)
      
      @scala.inline
      def setCatchClause(value: V): Self = StObject.set(x, "CatchClause", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCatchClauseUndefined: Self = StObject.set(x, "CatchClause", js.undefined)
      
      @scala.inline
      def setConditionalExpression(value: V): Self = StObject.set(x, "ConditionalExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setConditionalExpressionUndefined: Self = StObject.set(x, "ConditionalExpression", js.undefined)
      
      @scala.inline
      def setContinueStatement(value: V): Self = StObject.set(x, "ContinueStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setContinueStatementUndefined: Self = StObject.set(x, "ContinueStatement", js.undefined)
      
      @scala.inline
      def setDebuggerStatement(value: V): Self = StObject.set(x, "DebuggerStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDebuggerStatementUndefined: Self = StObject.set(x, "DebuggerStatement", js.undefined)
      
      @scala.inline
      def setDirective(value: V): Self = StObject.set(x, "Directive", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDirectiveLiteral(value: V): Self = StObject.set(x, "DirectiveLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDirectiveLiteralUndefined: Self = StObject.set(x, "DirectiveLiteral", js.undefined)
      
      @scala.inline
      def setDirectiveUndefined: Self = StObject.set(x, "Directive", js.undefined)
      
      @scala.inline
      def setDoWhileStatement(value: V): Self = StObject.set(x, "DoWhileStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDoWhileStatementUndefined: Self = StObject.set(x, "DoWhileStatement", js.undefined)
      
      @scala.inline
      def setEmptyStatement(value: V): Self = StObject.set(x, "EmptyStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setEmptyStatementUndefined: Self = StObject.set(x, "EmptyStatement", js.undefined)
      
      @scala.inline
      def setExpressionStatement(value: V): Self = StObject.set(x, "ExpressionStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExpressionStatementUndefined: Self = StObject.set(x, "ExpressionStatement", js.undefined)
      
      @scala.inline
      def setFile(value: V): Self = StObject.set(x, "File", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFileUndefined: Self = StObject.set(x, "File", js.undefined)
      
      @scala.inline
      def setForInStatement(value: V): Self = StObject.set(x, "ForInStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setForInStatementUndefined: Self = StObject.set(x, "ForInStatement", js.undefined)
      
      @scala.inline
      def setForStatement(value: V): Self = StObject.set(x, "ForStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setForStatementUndefined: Self = StObject.set(x, "ForStatement", js.undefined)
      
      @scala.inline
      def setFunctionDeclaration(value: V): Self = StObject.set(x, "FunctionDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFunctionDeclarationUndefined: Self = StObject.set(x, "FunctionDeclaration", js.undefined)
      
      @scala.inline
      def setFunctionExpression(value: V): Self = StObject.set(x, "FunctionExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFunctionExpressionUndefined: Self = StObject.set(x, "FunctionExpression", js.undefined)
      
      @scala.inline
      def setIdentifier(value: V): Self = StObject.set(x, "Identifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setIdentifierUndefined: Self = StObject.set(x, "Identifier", js.undefined)
      
      @scala.inline
      def setIfStatement(value: V): Self = StObject.set(x, "IfStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setIfStatementUndefined: Self = StObject.set(x, "IfStatement", js.undefined)
      
      @scala.inline
      def setLabeledStatement(value: V): Self = StObject.set(x, "LabeledStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLabeledStatementUndefined: Self = StObject.set(x, "LabeledStatement", js.undefined)
      
      @scala.inline
      def setLogicalExpression(value: V): Self = StObject.set(x, "LogicalExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLogicalExpressionUndefined: Self = StObject.set(x, "LogicalExpression", js.undefined)
      
      @scala.inline
      def setMemberExpression(value: V): Self = StObject.set(x, "MemberExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMemberExpressionUndefined: Self = StObject.set(x, "MemberExpression", js.undefined)
      
      @scala.inline
      def setNewExpression(value: V): Self = StObject.set(x, "NewExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNewExpressionUndefined: Self = StObject.set(x, "NewExpression", js.undefined)
      
      @scala.inline
      def setNullLiteral(value: V): Self = StObject.set(x, "NullLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNullLiteralUndefined: Self = StObject.set(x, "NullLiteral", js.undefined)
      
      @scala.inline
      def setNumericLiteral(value: V): Self = StObject.set(x, "NumericLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNumericLiteralUndefined: Self = StObject.set(x, "NumericLiteral", js.undefined)
      
      @scala.inline
      def setObjectExpression(value: V): Self = StObject.set(x, "ObjectExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectExpressionUndefined: Self = StObject.set(x, "ObjectExpression", js.undefined)
      
      @scala.inline
      def setObjectMethod(value: V): Self = StObject.set(x, "ObjectMethod", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectMethodUndefined: Self = StObject.set(x, "ObjectMethod", js.undefined)
      
      @scala.inline
      def setObjectProperty(value: V): Self = StObject.set(x, "ObjectProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectPropertyUndefined: Self = StObject.set(x, "ObjectProperty", js.undefined)
      
      @scala.inline
      def setProgram(value: V): Self = StObject.set(x, "Program", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setProgramUndefined: Self = StObject.set(x, "Program", js.undefined)
      
      @scala.inline
      def setRegExpLiteral(value: V): Self = StObject.set(x, "RegExpLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setRegExpLiteralUndefined: Self = StObject.set(x, "RegExpLiteral", js.undefined)
      
      @scala.inline
      def setRestElement(value: V): Self = StObject.set(x, "RestElement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setRestElementUndefined: Self = StObject.set(x, "RestElement", js.undefined)
      
      @scala.inline
      def setReturnStatement(value: V): Self = StObject.set(x, "ReturnStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setReturnStatementUndefined: Self = StObject.set(x, "ReturnStatement", js.undefined)
      
      @scala.inline
      def setSequenceExpression(value: V): Self = StObject.set(x, "SequenceExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSequenceExpressionUndefined: Self = StObject.set(x, "SequenceExpression", js.undefined)
      
      @scala.inline
      def setStringLiteral(value: V): Self = StObject.set(x, "StringLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setStringLiteralUndefined: Self = StObject.set(x, "StringLiteral", js.undefined)
      
      @scala.inline
      def setSwitchCase(value: V): Self = StObject.set(x, "SwitchCase", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSwitchCaseUndefined: Self = StObject.set(x, "SwitchCase", js.undefined)
      
      @scala.inline
      def setSwitchStatement(value: V): Self = StObject.set(x, "SwitchStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSwitchStatementUndefined: Self = StObject.set(x, "SwitchStatement", js.undefined)
      
      @scala.inline
      def setThisExpression(value: V): Self = StObject.set(x, "ThisExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setThisExpressionUndefined: Self = StObject.set(x, "ThisExpression", js.undefined)
      
      @scala.inline
      def setThrowStatement(value: V): Self = StObject.set(x, "ThrowStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setThrowStatementUndefined: Self = StObject.set(x, "ThrowStatement", js.undefined)
      
      @scala.inline
      def setTryStatement(value: V): Self = StObject.set(x, "TryStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTryStatementUndefined: Self = StObject.set(x, "TryStatement", js.undefined)
      
      @scala.inline
      def setUnaryExpression(value: V): Self = StObject.set(x, "UnaryExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUnaryExpressionUndefined: Self = StObject.set(x, "UnaryExpression", js.undefined)
      
      @scala.inline
      def setUpdateExpression(value: V): Self = StObject.set(x, "UpdateExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUpdateExpressionUndefined: Self = StObject.set(x, "UpdateExpression", js.undefined)
      
      @scala.inline
      def setVariableDeclaration(value: V): Self = StObject.set(x, "VariableDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setVariableDeclarationUndefined: Self = StObject.set(x, "VariableDeclaration", js.undefined)
      
      @scala.inline
      def setVariableDeclarator(value: V): Self = StObject.set(x, "VariableDeclarator", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setVariableDeclaratorUndefined: Self = StObject.set(x, "VariableDeclarator", js.undefined)
      
      @scala.inline
      def setWhileStatement(value: V): Self = StObject.set(x, "WhileStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setWhileStatementUndefined: Self = StObject.set(x, "WhileStatement", js.undefined)
      
      @scala.inline
      def setWithStatement(value: V): Self = StObject.set(x, "WithStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setWithStatementUndefined: Self = StObject.set(x, "WithStatement", js.undefined)
    }
  }
  
  type es2015Types = AssignmentPattern_ | ArrayPattern_ | ArrowFunctionExpression_ | ClassBody_ | ClassDeclaration_ | ClassExpression_ | ExportAllDeclaration_ | ExportDefaultDeclaration_ | ExportNamedDeclaration_ | ExportSpecifier_ | ForOfStatement_ | ImportDeclaration_ | ImportDefaultSpecifier_ | ImportNamespaceSpecifier_ | ImportSpecifier_ | MetaProperty_ | ClassMethod_ | ObjectPattern_ | SpreadElement_ | Super | TaggedTemplateExpression_ | TemplateElement_ | TemplateLiteral_ | YieldExpression_ | AwaitExpression_ | BindExpression_ | ClassProperty_ | Decorator_ | DoExpression_ | ExportDefaultSpecifier_ | ExportNamespaceSpecifier_
  
  @js.native
  trait es2015Visitors[V] extends StObject {
    
    var ArrayPattern: js.UndefOr[V] = js.native
    
    var ArrowFunctionExpression: js.UndefOr[V] = js.native
    
    var AssignmentPattern: js.UndefOr[V] = js.native
    
    var AwaitExpression: js.UndefOr[V] = js.native
    
    var BindExpression: js.UndefOr[V] = js.native
    
    var ClassBody: js.UndefOr[V] = js.native
    
    var ClassDeclaration: js.UndefOr[V] = js.native
    
    var ClassExpression: js.UndefOr[V] = js.native
    
    var ClassMethod: js.UndefOr[V] = js.native
    
    var ClassProperty: js.UndefOr[V] = js.native
    
    var Decorator: js.UndefOr[V] = js.native
    
    var DoExpression: js.UndefOr[V] = js.native
    
    var ExportAllDeclaration: js.UndefOr[V] = js.native
    
    var ExportDefaultDeclaration: js.UndefOr[V] = js.native
    
    var ExportDefaultSpecifier: js.UndefOr[V] = js.native
    
    var ExportNamedDeclaration: js.UndefOr[V] = js.native
    
    var ExportNamespaceSpecifier: js.UndefOr[V] = js.native
    
    var ExportSpecifier: js.UndefOr[V] = js.native
    
    var ForOfStatement: js.UndefOr[V] = js.native
    
    var ImportDeclaration: js.UndefOr[V] = js.native
    
    var ImportDefaultSpecifier: js.UndefOr[V] = js.native
    
    var ImportNamespaceSpecifier: js.UndefOr[V] = js.native
    
    var ImportSpecifier: js.UndefOr[V] = js.native
    
    var MetaProperty: js.UndefOr[V] = js.native
    
    var ObjectPattern: js.UndefOr[V] = js.native
    
    var SpreadElement: js.UndefOr[V] = js.native
    
    var Super: js.UndefOr[V] = js.native
    
    var TaggedTemplateExpression: js.UndefOr[V] = js.native
    
    var TemplateElement: js.UndefOr[V] = js.native
    
    var TemplateLiteral: js.UndefOr[V] = js.native
    
    var YieldExpression: js.UndefOr[V] = js.native
  }
  object es2015Visitors {
    
    @scala.inline
    def apply[V](): es2015Visitors[V] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[es2015Visitors[V]]
    }
    
    @scala.inline
    implicit class es2015VisitorsMutableBuilder[Self <: es2015Visitors[_], V] (val x: Self with es2015Visitors[V]) extends AnyVal {
      
      @scala.inline
      def setArrayPattern(value: V): Self = StObject.set(x, "ArrayPattern", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setArrayPatternUndefined: Self = StObject.set(x, "ArrayPattern", js.undefined)
      
      @scala.inline
      def setArrowFunctionExpression(value: V): Self = StObject.set(x, "ArrowFunctionExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setArrowFunctionExpressionUndefined: Self = StObject.set(x, "ArrowFunctionExpression", js.undefined)
      
      @scala.inline
      def setAssignmentPattern(value: V): Self = StObject.set(x, "AssignmentPattern", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAssignmentPatternUndefined: Self = StObject.set(x, "AssignmentPattern", js.undefined)
      
      @scala.inline
      def setAwaitExpression(value: V): Self = StObject.set(x, "AwaitExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAwaitExpressionUndefined: Self = StObject.set(x, "AwaitExpression", js.undefined)
      
      @scala.inline
      def setBindExpression(value: V): Self = StObject.set(x, "BindExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBindExpressionUndefined: Self = StObject.set(x, "BindExpression", js.undefined)
      
      @scala.inline
      def setClassBody(value: V): Self = StObject.set(x, "ClassBody", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassBodyUndefined: Self = StObject.set(x, "ClassBody", js.undefined)
      
      @scala.inline
      def setClassDeclaration(value: V): Self = StObject.set(x, "ClassDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassDeclarationUndefined: Self = StObject.set(x, "ClassDeclaration", js.undefined)
      
      @scala.inline
      def setClassExpression(value: V): Self = StObject.set(x, "ClassExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassExpressionUndefined: Self = StObject.set(x, "ClassExpression", js.undefined)
      
      @scala.inline
      def setClassMethod(value: V): Self = StObject.set(x, "ClassMethod", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassMethodUndefined: Self = StObject.set(x, "ClassMethod", js.undefined)
      
      @scala.inline
      def setClassProperty(value: V): Self = StObject.set(x, "ClassProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassPropertyUndefined: Self = StObject.set(x, "ClassProperty", js.undefined)
      
      @scala.inline
      def setDecorator(value: V): Self = StObject.set(x, "Decorator", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDecoratorUndefined: Self = StObject.set(x, "Decorator", js.undefined)
      
      @scala.inline
      def setDoExpression(value: V): Self = StObject.set(x, "DoExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDoExpressionUndefined: Self = StObject.set(x, "DoExpression", js.undefined)
      
      @scala.inline
      def setExportAllDeclaration(value: V): Self = StObject.set(x, "ExportAllDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportAllDeclarationUndefined: Self = StObject.set(x, "ExportAllDeclaration", js.undefined)
      
      @scala.inline
      def setExportDefaultDeclaration(value: V): Self = StObject.set(x, "ExportDefaultDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportDefaultDeclarationUndefined: Self = StObject.set(x, "ExportDefaultDeclaration", js.undefined)
      
      @scala.inline
      def setExportDefaultSpecifier(value: V): Self = StObject.set(x, "ExportDefaultSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportDefaultSpecifierUndefined: Self = StObject.set(x, "ExportDefaultSpecifier", js.undefined)
      
      @scala.inline
      def setExportNamedDeclaration(value: V): Self = StObject.set(x, "ExportNamedDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportNamedDeclarationUndefined: Self = StObject.set(x, "ExportNamedDeclaration", js.undefined)
      
      @scala.inline
      def setExportNamespaceSpecifier(value: V): Self = StObject.set(x, "ExportNamespaceSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportNamespaceSpecifierUndefined: Self = StObject.set(x, "ExportNamespaceSpecifier", js.undefined)
      
      @scala.inline
      def setExportSpecifier(value: V): Self = StObject.set(x, "ExportSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportSpecifierUndefined: Self = StObject.set(x, "ExportSpecifier", js.undefined)
      
      @scala.inline
      def setForOfStatement(value: V): Self = StObject.set(x, "ForOfStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setForOfStatementUndefined: Self = StObject.set(x, "ForOfStatement", js.undefined)
      
      @scala.inline
      def setImportDeclaration(value: V): Self = StObject.set(x, "ImportDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImportDeclarationUndefined: Self = StObject.set(x, "ImportDeclaration", js.undefined)
      
      @scala.inline
      def setImportDefaultSpecifier(value: V): Self = StObject.set(x, "ImportDefaultSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImportDefaultSpecifierUndefined: Self = StObject.set(x, "ImportDefaultSpecifier", js.undefined)
      
      @scala.inline
      def setImportNamespaceSpecifier(value: V): Self = StObject.set(x, "ImportNamespaceSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImportNamespaceSpecifierUndefined: Self = StObject.set(x, "ImportNamespaceSpecifier", js.undefined)
      
      @scala.inline
      def setImportSpecifier(value: V): Self = StObject.set(x, "ImportSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImportSpecifierUndefined: Self = StObject.set(x, "ImportSpecifier", js.undefined)
      
      @scala.inline
      def setMetaProperty(value: V): Self = StObject.set(x, "MetaProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMetaPropertyUndefined: Self = StObject.set(x, "MetaProperty", js.undefined)
      
      @scala.inline
      def setObjectPattern(value: V): Self = StObject.set(x, "ObjectPattern", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectPatternUndefined: Self = StObject.set(x, "ObjectPattern", js.undefined)
      
      @scala.inline
      def setSpreadElement(value: V): Self = StObject.set(x, "SpreadElement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSpreadElementUndefined: Self = StObject.set(x, "SpreadElement", js.undefined)
      
      @scala.inline
      def setSuper(value: V): Self = StObject.set(x, "Super", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSuperUndefined: Self = StObject.set(x, "Super", js.undefined)
      
      @scala.inline
      def setTaggedTemplateExpression(value: V): Self = StObject.set(x, "TaggedTemplateExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTaggedTemplateExpressionUndefined: Self = StObject.set(x, "TaggedTemplateExpression", js.undefined)
      
      @scala.inline
      def setTemplateElement(value: V): Self = StObject.set(x, "TemplateElement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTemplateElementUndefined: Self = StObject.set(x, "TemplateElement", js.undefined)
      
      @scala.inline
      def setTemplateLiteral(value: V): Self = StObject.set(x, "TemplateLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTemplateLiteralUndefined: Self = StObject.set(x, "TemplateLiteral", js.undefined)
      
      @scala.inline
      def setYieldExpression(value: V): Self = StObject.set(x, "YieldExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setYieldExpressionUndefined: Self = StObject.set(x, "YieldExpression", js.undefined)
    }
  }
  
  type flowTypes = AnyTypeAnnotation_ | ArrayTypeAnnotation_ | BooleanTypeAnnotation_ | BooleanLiteralTypeAnnotation_ | NullLiteralTypeAnnotation_ | ClassImplements_ | DeclareClass_ | DeclareFunction_ | DeclareInterface_ | DeclareModule_ | DeclareTypeAlias_ | DeclareVariable_ | FunctionTypeAnnotation_ | FunctionTypeParam_ | GenericTypeAnnotation_ | InterfaceExtends_ | InterfaceDeclaration_ | IntersectionTypeAnnotation_ | MixedTypeAnnotation_ | NullableTypeAnnotation_ | NumberTypeAnnotation_ | ObjectTypeAnnotation_ | ObjectTypeCallProperty_ | ObjectTypeIndexer_ | ObjectTypeProperty_ | QualifiedTypeIdentifier_ | StringLiteralTypeAnnotation_ | StringTypeAnnotation_ | ThisTypeAnnotation_ | TupleTypeAnnotation_ | TypeofTypeAnnotation_ | TypeAlias_ | TypeAnnotation_ | TypeCastExpression_ | TypeParameterDeclaration_ | TypeParameterInstantiation_ | UnionTypeAnnotation_ | VoidTypeAnnotation_
  
  @js.native
  trait flowVisitors[V] extends StObject {
    
    var AnyTypeAnnotation: js.UndefOr[V] = js.native
    
    var ArrayTypeAnnotation: js.UndefOr[V] = js.native
    
    var BooleanLiteralTypeAnnotation: js.UndefOr[V] = js.native
    
    var BooleanTypeAnnotation: js.UndefOr[V] = js.native
    
    var ClassImplements: js.UndefOr[V] = js.native
    
    var DeclareClass: js.UndefOr[V] = js.native
    
    var DeclareFunction: js.UndefOr[V] = js.native
    
    var DeclareInterface: js.UndefOr[V] = js.native
    
    var DeclareModule: js.UndefOr[V] = js.native
    
    var DeclareTypeAlias: js.UndefOr[V] = js.native
    
    var DeclareVariable: js.UndefOr[V] = js.native
    
    var FunctionTypeAnnotation: js.UndefOr[V] = js.native
    
    var FunctionTypeParam: js.UndefOr[V] = js.native
    
    var GenericTypeAnnotation: js.UndefOr[V] = js.native
    
    var InterfaceDeclaration: js.UndefOr[V] = js.native
    
    var InterfaceExtends: js.UndefOr[V] = js.native
    
    var IntersectionTypeAnnotation: js.UndefOr[V] = js.native
    
    var MixedTypeAnnotation: js.UndefOr[V] = js.native
    
    var NullLiteralTypeAnnotation: js.UndefOr[V] = js.native
    
    var NullableTypeAnnotation: js.UndefOr[V] = js.native
    
    var NumberTypeAnnotation: js.UndefOr[V] = js.native
    
    var ObjectTypeAnnotation: js.UndefOr[V] = js.native
    
    var ObjectTypeCallProperty: js.UndefOr[V] = js.native
    
    var ObjectTypeIndexer: js.UndefOr[V] = js.native
    
    var ObjectTypeProperty: js.UndefOr[V] = js.native
    
    var QualifiedTypeIdentifier: js.UndefOr[V] = js.native
    
    var StringLiteralTypeAnnotation: js.UndefOr[V] = js.native
    
    var StringTypeAnnotation: js.UndefOr[V] = js.native
    
    var ThisTypeAnnotation: js.UndefOr[V] = js.native
    
    var TupleTypeAnnotation: js.UndefOr[V] = js.native
    
    var TypeAlias: js.UndefOr[V] = js.native
    
    var TypeAnnotation: js.UndefOr[V] = js.native
    
    var TypeCastExpression: js.UndefOr[V] = js.native
    
    var TypeParameterDeclaration: js.UndefOr[V] = js.native
    
    var TypeParameterInstantiation: js.UndefOr[V] = js.native
    
    var TypeofTypeAnnotation: js.UndefOr[V] = js.native
    
    var UnionTypeAnnotation: js.UndefOr[V] = js.native
    
    var VoidTypeAnnotation: js.UndefOr[V] = js.native
  }
  object flowVisitors {
    
    @scala.inline
    def apply[V](): flowVisitors[V] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[flowVisitors[V]]
    }
    
    @scala.inline
    implicit class flowVisitorsMutableBuilder[Self <: flowVisitors[_], V] (val x: Self with flowVisitors[V]) extends AnyVal {
      
      @scala.inline
      def setAnyTypeAnnotation(value: V): Self = StObject.set(x, "AnyTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAnyTypeAnnotationUndefined: Self = StObject.set(x, "AnyTypeAnnotation", js.undefined)
      
      @scala.inline
      def setArrayTypeAnnotation(value: V): Self = StObject.set(x, "ArrayTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setArrayTypeAnnotationUndefined: Self = StObject.set(x, "ArrayTypeAnnotation", js.undefined)
      
      @scala.inline
      def setBooleanLiteralTypeAnnotation(value: V): Self = StObject.set(x, "BooleanLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBooleanLiteralTypeAnnotationUndefined: Self = StObject.set(x, "BooleanLiteralTypeAnnotation", js.undefined)
      
      @scala.inline
      def setBooleanTypeAnnotation(value: V): Self = StObject.set(x, "BooleanTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBooleanTypeAnnotationUndefined: Self = StObject.set(x, "BooleanTypeAnnotation", js.undefined)
      
      @scala.inline
      def setClassImplements(value: V): Self = StObject.set(x, "ClassImplements", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassImplementsUndefined: Self = StObject.set(x, "ClassImplements", js.undefined)
      
      @scala.inline
      def setDeclareClass(value: V): Self = StObject.set(x, "DeclareClass", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareClassUndefined: Self = StObject.set(x, "DeclareClass", js.undefined)
      
      @scala.inline
      def setDeclareFunction(value: V): Self = StObject.set(x, "DeclareFunction", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareFunctionUndefined: Self = StObject.set(x, "DeclareFunction", js.undefined)
      
      @scala.inline
      def setDeclareInterface(value: V): Self = StObject.set(x, "DeclareInterface", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareInterfaceUndefined: Self = StObject.set(x, "DeclareInterface", js.undefined)
      
      @scala.inline
      def setDeclareModule(value: V): Self = StObject.set(x, "DeclareModule", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareModuleUndefined: Self = StObject.set(x, "DeclareModule", js.undefined)
      
      @scala.inline
      def setDeclareTypeAlias(value: V): Self = StObject.set(x, "DeclareTypeAlias", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareTypeAliasUndefined: Self = StObject.set(x, "DeclareTypeAlias", js.undefined)
      
      @scala.inline
      def setDeclareVariable(value: V): Self = StObject.set(x, "DeclareVariable", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareVariableUndefined: Self = StObject.set(x, "DeclareVariable", js.undefined)
      
      @scala.inline
      def setFunctionTypeAnnotation(value: V): Self = StObject.set(x, "FunctionTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFunctionTypeAnnotationUndefined: Self = StObject.set(x, "FunctionTypeAnnotation", js.undefined)
      
      @scala.inline
      def setFunctionTypeParam(value: V): Self = StObject.set(x, "FunctionTypeParam", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFunctionTypeParamUndefined: Self = StObject.set(x, "FunctionTypeParam", js.undefined)
      
      @scala.inline
      def setGenericTypeAnnotation(value: V): Self = StObject.set(x, "GenericTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setGenericTypeAnnotationUndefined: Self = StObject.set(x, "GenericTypeAnnotation", js.undefined)
      
      @scala.inline
      def setInterfaceDeclaration(value: V): Self = StObject.set(x, "InterfaceDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setInterfaceDeclarationUndefined: Self = StObject.set(x, "InterfaceDeclaration", js.undefined)
      
      @scala.inline
      def setInterfaceExtends(value: V): Self = StObject.set(x, "InterfaceExtends", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setInterfaceExtendsUndefined: Self = StObject.set(x, "InterfaceExtends", js.undefined)
      
      @scala.inline
      def setIntersectionTypeAnnotation(value: V): Self = StObject.set(x, "IntersectionTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setIntersectionTypeAnnotationUndefined: Self = StObject.set(x, "IntersectionTypeAnnotation", js.undefined)
      
      @scala.inline
      def setMixedTypeAnnotation(value: V): Self = StObject.set(x, "MixedTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMixedTypeAnnotationUndefined: Self = StObject.set(x, "MixedTypeAnnotation", js.undefined)
      
      @scala.inline
      def setNullLiteralTypeAnnotation(value: V): Self = StObject.set(x, "NullLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNullLiteralTypeAnnotationUndefined: Self = StObject.set(x, "NullLiteralTypeAnnotation", js.undefined)
      
      @scala.inline
      def setNullableTypeAnnotation(value: V): Self = StObject.set(x, "NullableTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNullableTypeAnnotationUndefined: Self = StObject.set(x, "NullableTypeAnnotation", js.undefined)
      
      @scala.inline
      def setNumberTypeAnnotation(value: V): Self = StObject.set(x, "NumberTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNumberTypeAnnotationUndefined: Self = StObject.set(x, "NumberTypeAnnotation", js.undefined)
      
      @scala.inline
      def setObjectTypeAnnotation(value: V): Self = StObject.set(x, "ObjectTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectTypeAnnotationUndefined: Self = StObject.set(x, "ObjectTypeAnnotation", js.undefined)
      
      @scala.inline
      def setObjectTypeCallProperty(value: V): Self = StObject.set(x, "ObjectTypeCallProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectTypeCallPropertyUndefined: Self = StObject.set(x, "ObjectTypeCallProperty", js.undefined)
      
      @scala.inline
      def setObjectTypeIndexer(value: V): Self = StObject.set(x, "ObjectTypeIndexer", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectTypeIndexerUndefined: Self = StObject.set(x, "ObjectTypeIndexer", js.undefined)
      
      @scala.inline
      def setObjectTypeProperty(value: V): Self = StObject.set(x, "ObjectTypeProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectTypePropertyUndefined: Self = StObject.set(x, "ObjectTypeProperty", js.undefined)
      
      @scala.inline
      def setQualifiedTypeIdentifier(value: V): Self = StObject.set(x, "QualifiedTypeIdentifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setQualifiedTypeIdentifierUndefined: Self = StObject.set(x, "QualifiedTypeIdentifier", js.undefined)
      
      @scala.inline
      def setStringLiteralTypeAnnotation(value: V): Self = StObject.set(x, "StringLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setStringLiteralTypeAnnotationUndefined: Self = StObject.set(x, "StringLiteralTypeAnnotation", js.undefined)
      
      @scala.inline
      def setStringTypeAnnotation(value: V): Self = StObject.set(x, "StringTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setStringTypeAnnotationUndefined: Self = StObject.set(x, "StringTypeAnnotation", js.undefined)
      
      @scala.inline
      def setThisTypeAnnotation(value: V): Self = StObject.set(x, "ThisTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setThisTypeAnnotationUndefined: Self = StObject.set(x, "ThisTypeAnnotation", js.undefined)
      
      @scala.inline
      def setTupleTypeAnnotation(value: V): Self = StObject.set(x, "TupleTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTupleTypeAnnotationUndefined: Self = StObject.set(x, "TupleTypeAnnotation", js.undefined)
      
      @scala.inline
      def setTypeAlias(value: V): Self = StObject.set(x, "TypeAlias", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypeAliasUndefined: Self = StObject.set(x, "TypeAlias", js.undefined)
      
      @scala.inline
      def setTypeAnnotation(value: V): Self = StObject.set(x, "TypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypeAnnotationUndefined: Self = StObject.set(x, "TypeAnnotation", js.undefined)
      
      @scala.inline
      def setTypeCastExpression(value: V): Self = StObject.set(x, "TypeCastExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypeCastExpressionUndefined: Self = StObject.set(x, "TypeCastExpression", js.undefined)
      
      @scala.inline
      def setTypeParameterDeclaration(value: V): Self = StObject.set(x, "TypeParameterDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypeParameterDeclarationUndefined: Self = StObject.set(x, "TypeParameterDeclaration", js.undefined)
      
      @scala.inline
      def setTypeParameterInstantiation(value: V): Self = StObject.set(x, "TypeParameterInstantiation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypeParameterInstantiationUndefined: Self = StObject.set(x, "TypeParameterInstantiation", js.undefined)
      
      @scala.inline
      def setTypeofTypeAnnotation(value: V): Self = StObject.set(x, "TypeofTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypeofTypeAnnotationUndefined: Self = StObject.set(x, "TypeofTypeAnnotation", js.undefined)
      
      @scala.inline
      def setUnionTypeAnnotation(value: V): Self = StObject.set(x, "UnionTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUnionTypeAnnotationUndefined: Self = StObject.set(x, "UnionTypeAnnotation", js.undefined)
      
      @scala.inline
      def setVoidTypeAnnotation(value: V): Self = StObject.set(x, "VoidTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setVoidTypeAnnotationUndefined: Self = StObject.set(x, "VoidTypeAnnotation", js.undefined)
    }
  }
  
  type jsxTypes = JSXAttribute_ | JSXClosingElement_ | JSXElement_ | JSXEmptyExpression_ | JSXExpressionContainer_ | JSXIdentifier_ | JSXMemberExpression_ | JSXNamespacedName_ | JSXOpeningElement_ | JSXSpreadAttribute_ | JSXText_
  
  @js.native
  trait jsxVisitors[V] extends StObject {
    
    var JSXAttribute: js.UndefOr[V] = js.native
    
    var JSXClosingElement: js.UndefOr[V] = js.native
    
    var JSXElement: js.UndefOr[V] = js.native
    
    var JSXEmptyExpression: js.UndefOr[V] = js.native
    
    var JSXExpressionContainer: js.UndefOr[V] = js.native
    
    var JSXIdentifier: js.UndefOr[V] = js.native
    
    var JSXMemberExpression: js.UndefOr[V] = js.native
    
    var JSXNamespacedName: js.UndefOr[V] = js.native
    
    var JSXOpeningElement: js.UndefOr[V] = js.native
    
    var JSXSpreadAttribute: js.UndefOr[V] = js.native
    
    var JSXText: js.UndefOr[V] = js.native
  }
  object jsxVisitors {
    
    @scala.inline
    def apply[V](): jsxVisitors[V] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[jsxVisitors[V]]
    }
    
    @scala.inline
    implicit class jsxVisitorsMutableBuilder[Self <: jsxVisitors[_], V] (val x: Self with jsxVisitors[V]) extends AnyVal {
      
      @scala.inline
      def setJSXAttribute(value: V): Self = StObject.set(x, "JSXAttribute", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXAttributeUndefined: Self = StObject.set(x, "JSXAttribute", js.undefined)
      
      @scala.inline
      def setJSXClosingElement(value: V): Self = StObject.set(x, "JSXClosingElement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXClosingElementUndefined: Self = StObject.set(x, "JSXClosingElement", js.undefined)
      
      @scala.inline
      def setJSXElement(value: V): Self = StObject.set(x, "JSXElement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXElementUndefined: Self = StObject.set(x, "JSXElement", js.undefined)
      
      @scala.inline
      def setJSXEmptyExpression(value: V): Self = StObject.set(x, "JSXEmptyExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXEmptyExpressionUndefined: Self = StObject.set(x, "JSXEmptyExpression", js.undefined)
      
      @scala.inline
      def setJSXExpressionContainer(value: V): Self = StObject.set(x, "JSXExpressionContainer", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXExpressionContainerUndefined: Self = StObject.set(x, "JSXExpressionContainer", js.undefined)
      
      @scala.inline
      def setJSXIdentifier(value: V): Self = StObject.set(x, "JSXIdentifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXIdentifierUndefined: Self = StObject.set(x, "JSXIdentifier", js.undefined)
      
      @scala.inline
      def setJSXMemberExpression(value: V): Self = StObject.set(x, "JSXMemberExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXMemberExpressionUndefined: Self = StObject.set(x, "JSXMemberExpression", js.undefined)
      
      @scala.inline
      def setJSXNamespacedName(value: V): Self = StObject.set(x, "JSXNamespacedName", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXNamespacedNameUndefined: Self = StObject.set(x, "JSXNamespacedName", js.undefined)
      
      @scala.inline
      def setJSXOpeningElement(value: V): Self = StObject.set(x, "JSXOpeningElement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXOpeningElementUndefined: Self = StObject.set(x, "JSXOpeningElement", js.undefined)
      
      @scala.inline
      def setJSXSpreadAttribute(value: V): Self = StObject.set(x, "JSXSpreadAttribute", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXSpreadAttributeUndefined: Self = StObject.set(x, "JSXSpreadAttribute", js.undefined)
      
      @scala.inline
      def setJSXText(value: V): Self = StObject.set(x, "JSXText", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXTextUndefined: Self = StObject.set(x, "JSXText", js.undefined)
    }
  }
  
  type miscTypes = Noop_ | ParenthesizedExpression_
  
  @js.native
  trait miscVisitors[V] extends StObject {
    
    var Noop: js.UndefOr[V] = js.native
    
    var ParenthesizedExpression: js.UndefOr[V] = js.native
  }
  object miscVisitors {
    
    @scala.inline
    def apply[V](): miscVisitors[V] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[miscVisitors[V]]
    }
    
    @scala.inline
    implicit class miscVisitorsMutableBuilder[Self <: miscVisitors[_], V] (val x: Self with miscVisitors[V]) extends AnyVal {
      
      @scala.inline
      def setNoop(value: V): Self = StObject.set(x, "Noop", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNoopUndefined: Self = StObject.set(x, "Noop", js.undefined)
      
      @scala.inline
      def setParenthesizedExpression(value: V): Self = StObject.set(x, "ParenthesizedExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setParenthesizedExpressionUndefined: Self = StObject.set(x, "ParenthesizedExpression", js.undefined)
    }
  }
  
  @js.native
  trait visitors[V]
    extends coreVisitors[V]
       with es2015Visitors[V]
       with flowVisitors[V]
       with jsxVisitors[V]
       with miscVisitors[V]
  object visitors {
    
    @scala.inline
    def apply[V](): visitors[V] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[visitors[V]]
    }
  }
}
