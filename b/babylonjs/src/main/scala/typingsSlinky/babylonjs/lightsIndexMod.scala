package typingsSlinky.babylonjs

import typingsSlinky.babylonjs.mathVectorMod.Vector3
import typingsSlinky.babylonjs.sceneMod.Scene
import typingsSlinky.babylonjs.shadowLightMod.IShadowLight
import typingsSlinky.babylonjs.typesMod.Nullable
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object lightsIndexMod {
  
  @JSImport("babylonjs/Lights/index", "CascadedShadowGenerator")
  @js.native
  class CascadedShadowGenerator protected ()
    extends typingsSlinky.babylonjs.shadowsIndexMod.CascadedShadowGenerator {
    /**
      * Creates a Cascaded Shadow Generator object.
      * A ShadowGenerator is the required tool to use the shadows.
      * Each directional light casting shadows needs to use its own ShadowGenerator.
      * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows
      * @param mapSize The size of the texture what stores the shadows. Example : 1024.
      * @param light The directional light object generating the shadows.
      * @param usefulFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.
      */
    def this(mapSize: Double, light: typingsSlinky.babylonjs.directionalLightMod.DirectionalLight) = this()
    def this(
      mapSize: Double,
      light: typingsSlinky.babylonjs.directionalLightMod.DirectionalLight,
      usefulFloatFirst: Boolean
    ) = this()
  }
  /* static members */
  object CascadedShadowGenerator {
    
    @JSImport("babylonjs/Lights/index", "CascadedShadowGenerator")
    @js.native
    val ^ : js.Any = js.native
    
    /**
      * Name of the CSM class
      */
    @JSImport("babylonjs/Lights/index", "CascadedShadowGenerator.CLASSNAME")
    @js.native
    def CLASSNAME: String = js.native
    @scala.inline
    def CLASSNAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CLASSNAME")(x.asInstanceOf[js.Any])
    
    /**
      * Defines the default number of cascades used by the CSM.
      */
    @JSImport("babylonjs/Lights/index", "CascadedShadowGenerator.DEFAULT_CASCADES_COUNT")
    @js.native
    val DEFAULT_CASCADES_COUNT: Double = js.native
    
    /**
      * Defines the maximum number of cascades used by the CSM.
      */
    @JSImport("babylonjs/Lights/index", "CascadedShadowGenerator.MAX_CASCADES_COUNT")
    @js.native
    val MAX_CASCADES_COUNT: Double = js.native
    
    /**
      * Defines the minimum number of cascades used by the CSM.
      */
    @JSImport("babylonjs/Lights/index", "CascadedShadowGenerator.MIN_CASCADES_COUNT")
    @js.native
    val MIN_CASCADES_COUNT: Double = js.native
    
    /**
      * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.
      * @param parsedShadowGenerator The JSON object to parse
      * @param scene The scene to create the shadow map for
      * @returns The parsed shadow generator
      */
    @JSImport("babylonjs/Lights/index", "CascadedShadowGenerator.Parse")
    @js.native
    def Parse(parsedShadowGenerator: js.Any, scene: Scene): typingsSlinky.babylonjs.shadowGeneratorMod.ShadowGenerator = js.native
    
    /** @hidden */
    @JSImport("babylonjs/Lights/index", "CascadedShadowGenerator._SceneComponentInitialization")
    @js.native
    def _SceneComponentInitialization(scene: Scene): Unit = js.native
    
    @JSImport("babylonjs/Lights/index", "CascadedShadowGenerator.frustumCornersNDCSpace")
    @js.native
    val frustumCornersNDCSpace: js.Any = js.native
  }
  
  @JSImport("babylonjs/Lights/index", "DirectionalLight")
  @js.native
  class DirectionalLight protected ()
    extends typingsSlinky.babylonjs.directionalLightMod.DirectionalLight {
    /**
      * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).
      * The directional light is emitted from everywhere in the given direction.
      * It can cast shadows.
      * Documentation : https://doc.babylonjs.com/babylon101/lights
      * @param name The friendly name of the light
      * @param direction The direction of the light
      * @param scene The scene the light belongs to
      */
    def this(name: String, direction: Vector3, scene: Scene) = this()
  }
  
  @JSImport("babylonjs/Lights/index", "HemisphericLight")
  @js.native
  class HemisphericLight protected ()
    extends typingsSlinky.babylonjs.hemisphericLightMod.HemisphericLight {
    /**
      * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).
      * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.
      * The HemisphericLight can't cast shadows.
      * Documentation : https://doc.babylonjs.com/babylon101/lights
      * @param name The friendly name of the light
      * @param direction The direction of the light reflection
      * @param scene The scene the light belongs to
      */
    def this(name: String, direction: Vector3, scene: Scene) = this()
  }
  
  @JSImport("babylonjs/Lights/index", "Light")
  @js.native
  abstract class Light protected ()
    extends typingsSlinky.babylonjs.lightMod.Light {
    /**
      * Creates a Light object in the scene.
      * Documentation : https://doc.babylonjs.com/babylon101/lights
      * @param name The firendly name of the light
      * @param scene The scene the light belongs too
      */
    def this(name: String, scene: Scene) = this()
  }
  /* static members */
  object Light {
    
    /**
      * Sort function to order lights for rendering.
      * @param a First Light object to compare to second.
      * @param b Second Light object to compare first.
      * @return -1 to reduce's a's index relative to be, 0 for no change, 1 to increase a's index relative to b.
      */
    @JSImport("babylonjs/Lights/index", "Light.CompareLightsPriority")
    @js.native
    def CompareLightsPriority(a: typingsSlinky.babylonjs.lightMod.Light, b: typingsSlinky.babylonjs.lightMod.Light): Double = js.native
    
    /**
      * Falloff Default: light is falling off following the material specification:
      * standard material is using standard falloff whereas pbr material can request special falloff per materials.
      */
    @JSImport("babylonjs/Lights/index", "Light.FALLOFF_DEFAULT")
    @js.native
    val FALLOFF_DEFAULT: Double = js.native
    
    /**
      * Falloff gltf: light is falling off as described in the gltf moving to PBR document
      * to enhance interoperability with other engines.
      */
    @JSImport("babylonjs/Lights/index", "Light.FALLOFF_GLTF")
    @js.native
    val FALLOFF_GLTF: Double = js.native
    
    /**
      * Falloff Physical: light is falling off following the inverse squared distance law.
      */
    @JSImport("babylonjs/Lights/index", "Light.FALLOFF_PHYSICAL")
    @js.native
    val FALLOFF_PHYSICAL: Double = js.native
    
    /**
      * Falloff Standard: light is falling off like in the standard material
      * to enhance interoperability with other materials.
      */
    @JSImport("babylonjs/Lights/index", "Light.FALLOFF_STANDARD")
    @js.native
    val FALLOFF_STANDARD: Double = js.native
    
    /**
      * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.
      * This new light is named "name" and added to the passed scene.
      * @param type Type according to the types available in Light.LIGHTTYPEID_x
      * @param name The friendly name of the light
      * @param scene The scene the new light will belong to
      * @returns the constructor function
      */
    @JSImport("babylonjs/Lights/index", "Light.GetConstructorFromName")
    @js.native
    def GetConstructorFromName(`type`: Double, name: String, scene: Scene): Nullable[js.Function0[this.type]] = js.native
    
    /**
      * Each light type uses the default quantity according to its type:
      *      point/spot lights use luminous intensity
      *      directional lights use illuminance
      */
    @JSImport("babylonjs/Lights/index", "Light.INTENSITYMODE_AUTOMATIC")
    @js.native
    val INTENSITYMODE_AUTOMATIC: Double = js.native
    
    /**
      * lux (lm/m^2)
      */
    @JSImport("babylonjs/Lights/index", "Light.INTENSITYMODE_ILLUMINANCE")
    @js.native
    val INTENSITYMODE_ILLUMINANCE: Double = js.native
    
    /**
      * nit (cd/m^2)
      */
    @JSImport("babylonjs/Lights/index", "Light.INTENSITYMODE_LUMINANCE")
    @js.native
    val INTENSITYMODE_LUMINANCE: Double = js.native
    
    /**
      * candela (lm/sr)
      */
    @JSImport("babylonjs/Lights/index", "Light.INTENSITYMODE_LUMINOUSINTENSITY")
    @js.native
    val INTENSITYMODE_LUMINOUSINTENSITY: Double = js.native
    
    /**
      * lumen (lm)
      */
    @JSImport("babylonjs/Lights/index", "Light.INTENSITYMODE_LUMINOUSPOWER")
    @js.native
    val INTENSITYMODE_LUMINOUSPOWER: Double = js.native
    
    /**
      * If every light affecting the material is in this lightmapMode,
      * material.lightmapTexture adds or multiplies
      * (depends on material.useLightmapAsShadowmap)
      * after every other light calculations.
      */
    @JSImport("babylonjs/Lights/index", "Light.LIGHTMAP_DEFAULT")
    @js.native
    val LIGHTMAP_DEFAULT: Double = js.native
    
    /**
      * material.lightmapTexture as only lighting
      * no light calculation from this light
      * only adds dynamic shadows from this light
      */
    @JSImport("babylonjs/Lights/index", "Light.LIGHTMAP_SHADOWSONLY")
    @js.native
    val LIGHTMAP_SHADOWSONLY: Double = js.native
    
    /**
      * material.lightmapTexture as only diffuse lighting from this light
      * adds only specular lighting from this light
      * adds dynamic shadows
      */
    @JSImport("babylonjs/Lights/index", "Light.LIGHTMAP_SPECULAR")
    @js.native
    val LIGHTMAP_SPECULAR: Double = js.native
    
    /**
      * Light type const id of the directional light.
      */
    @JSImport("babylonjs/Lights/index", "Light.LIGHTTYPEID_DIRECTIONALLIGHT")
    @js.native
    val LIGHTTYPEID_DIRECTIONALLIGHT: Double = js.native
    
    /**
      * Light type const id of the hemispheric light.
      */
    @JSImport("babylonjs/Lights/index", "Light.LIGHTTYPEID_HEMISPHERICLIGHT")
    @js.native
    val LIGHTTYPEID_HEMISPHERICLIGHT: Double = js.native
    
    /**
      * Light type const id of the point light.
      */
    @JSImport("babylonjs/Lights/index", "Light.LIGHTTYPEID_POINTLIGHT")
    @js.native
    val LIGHTTYPEID_POINTLIGHT: Double = js.native
    
    /**
      * Light type const id of the spot light.
      */
    @JSImport("babylonjs/Lights/index", "Light.LIGHTTYPEID_SPOTLIGHT")
    @js.native
    val LIGHTTYPEID_SPOTLIGHT: Double = js.native
    
    /**
      * Parses the passed "parsedLight" and returns a new instanced Light from this parsing.
      * @param parsedLight The JSON representation of the light
      * @param scene The scene to create the parsed light in
      * @returns the created light after parsing
      */
    @JSImport("babylonjs/Lights/index", "Light.Parse")
    @js.native
    def Parse(parsedLight: js.Any, scene: Scene): Nullable[typingsSlinky.babylonjs.lightMod.Light] = js.native
  }
  
  @JSImport("babylonjs/Lights/index", "PointLight")
  @js.native
  class PointLight protected ()
    extends typingsSlinky.babylonjs.pointLightMod.PointLight {
    /**
      * Creates a PointLight object from the passed name and position (Vector3) and adds it in the scene.
      * A PointLight emits the light in every direction.
      * It can cast shadows.
      * If the scene camera is already defined and you want to set your PointLight at the camera position, just set it :
      * ```javascript
      * var pointLight = new PointLight("pl", camera.position, scene);
      * ```
      * Documentation : https://doc.babylonjs.com/babylon101/lights
      * @param name The light friendly name
      * @param position The position of the point light in the scene
      * @param scene The scene the lights belongs to
      */
    def this(name: String, position: Vector3, scene: Scene) = this()
  }
  
  @JSImport("babylonjs/Lights/index", "ShadowGenerator")
  @js.native
  class ShadowGenerator protected ()
    extends typingsSlinky.babylonjs.shadowsIndexMod.ShadowGenerator {
    /**
      * Creates a ShadowGenerator object.
      * A ShadowGenerator is the required tool to use the shadows.
      * Each light casting shadows needs to use its own ShadowGenerator.
      * Documentation : https://doc.babylonjs.com/babylon101/shadows
      * @param mapSize The size of the texture what stores the shadows. Example : 1024.
      * @param light The light object generating the shadows.
      * @param usefulFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.
      */
    def this(mapSize: Double, light: IShadowLight) = this()
    def this(mapSize: Double, light: IShadowLight, usefulFloatFirst: Boolean) = this()
  }
  /* static members */
  object ShadowGenerator {
    
    @JSImport("babylonjs/Lights/index", "ShadowGenerator")
    @js.native
    val ^ : js.Any = js.native
    
    /**
      * Name of the shadow generator class
      */
    @JSImport("babylonjs/Lights/index", "ShadowGenerator.CLASSNAME")
    @js.native
    def CLASSNAME: String = js.native
    @scala.inline
    def CLASSNAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CLASSNAME")(x.asInstanceOf[js.Any])
    
    /**
      * Shadow generator mode ESM: Blurred Exponential Shadow Mapping using the inverse of the exponential preventing
      * edge artifacts on steep falloff.
      * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
      */
    @JSImport("babylonjs/Lights/index", "ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP")
    @js.native
    val FILTER_BLURCLOSEEXPONENTIALSHADOWMAP: Double = js.native
    
    /**
      * Shadow generator mode ESM: Blurred Exponential Shadow Mapping.
      * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
      */
    @JSImport("babylonjs/Lights/index", "ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP")
    @js.native
    val FILTER_BLUREXPONENTIALSHADOWMAP: Double = js.native
    
    /**
      * Shadow generator mode ESM: Exponential Shadow Mapping using the inverse of the exponential preventing
      * edge artifacts on steep falloff.
      * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
      */
    @JSImport("babylonjs/Lights/index", "ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP")
    @js.native
    val FILTER_CLOSEEXPONENTIALSHADOWMAP: Double = js.native
    
    /**
      * Shadow generator mode ESM: Exponential Shadow Mapping.
      * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
      */
    @JSImport("babylonjs/Lights/index", "ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP")
    @js.native
    val FILTER_EXPONENTIALSHADOWMAP: Double = js.native
    
    /**
      * Shadow generator mode None: no filtering applied.
      */
    @JSImport("babylonjs/Lights/index", "ShadowGenerator.FILTER_NONE")
    @js.native
    val FILTER_NONE: Double = js.native
    
    /**
      * Shadow generator mode PCF: Percentage Closer Filtering
      * benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
      * (https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html)
      */
    @JSImport("babylonjs/Lights/index", "ShadowGenerator.FILTER_PCF")
    @js.native
    val FILTER_PCF: Double = js.native
    
    /**
      * Shadow generator mode PCSS: Percentage Closering Soft Shadow.
      * benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
      * Contact Hardening
      */
    @JSImport("babylonjs/Lights/index", "ShadowGenerator.FILTER_PCSS")
    @js.native
    val FILTER_PCSS: Double = js.native
    
    /**
      * Shadow generator mode Poisson Sampling: Percentage Closer Filtering.
      * (Multiple Tap around evenly distributed around the pixel are used to evaluate the shadow strength)
      */
    @JSImport("babylonjs/Lights/index", "ShadowGenerator.FILTER_POISSONSAMPLING")
    @js.native
    val FILTER_POISSONSAMPLING: Double = js.native
    
    /**
      * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.
      * @param parsedShadowGenerator The JSON object to parse
      * @param scene The scene to create the shadow map for
      * @param constr A function that builds a shadow generator or undefined to create an instance of the default shadow generator
      * @returns The parsed shadow generator
      */
    @JSImport("babylonjs/Lights/index", "ShadowGenerator.Parse")
    @js.native
    def Parse(parsedShadowGenerator: js.Any, scene: Scene): typingsSlinky.babylonjs.shadowGeneratorMod.ShadowGenerator = js.native
    @JSImport("babylonjs/Lights/index", "ShadowGenerator.Parse")
    @js.native
    def Parse(
      parsedShadowGenerator: js.Any,
      scene: Scene,
      constr: js.Function2[/* mapSize */ Double, /* light */ IShadowLight, this.type]
    ): typingsSlinky.babylonjs.shadowGeneratorMod.ShadowGenerator = js.native
    
    /**
      * Reserved for PCF and PCSS
      * Highest Quality.
      *
      * Execute PCF on a 5*5 kernel improving a lot the shadow aliasing artifacts.
      *
      * Execute PCSS with 32 taps blocker search and 64 taps PCF.
      */
    @JSImport("babylonjs/Lights/index", "ShadowGenerator.QUALITY_HIGH")
    @js.native
    val QUALITY_HIGH: Double = js.native
    
    /**
      * Reserved for PCF and PCSS
      * The lowest quality but the fastest.
      *
      * Execute PCF on a 1*1 kernel.
      *
      * Execute PCSS with 16 taps blocker search and 16 taps PCF.
      */
    @JSImport("babylonjs/Lights/index", "ShadowGenerator.QUALITY_LOW")
    @js.native
    val QUALITY_LOW: Double = js.native
    
    /**
      * Reserved for PCF and PCSS
      * Good tradeoff for quality/perf cross devices
      *
      * Execute PCF on a 3*3 kernel.
      *
      * Execute PCSS with 16 taps blocker search and 32 taps PCF.
      */
    @JSImport("babylonjs/Lights/index", "ShadowGenerator.QUALITY_MEDIUM")
    @js.native
    val QUALITY_MEDIUM: Double = js.native
    
    /** @hidden */
    @JSImport("babylonjs/Lights/index", "ShadowGenerator._SceneComponentInitialization")
    @js.native
    def _SceneComponentInitialization(scene: Scene): Unit = js.native
  }
  
  @JSImport("babylonjs/Lights/index", "ShadowGeneratorSceneComponent")
  @js.native
  class ShadowGeneratorSceneComponent protected ()
    extends typingsSlinky.babylonjs.shadowsIndexMod.ShadowGeneratorSceneComponent {
    /**
      * Creates a new instance of the component for the given scene
      * @param scene Defines the scene to register the component in
      */
    def this(scene: Scene) = this()
  }
  
  @JSImport("babylonjs/Lights/index", "ShadowLight")
  @js.native
  abstract class ShadowLight protected ()
    extends typingsSlinky.babylonjs.shadowLightMod.ShadowLight {
    /**
      * Creates a Light object in the scene.
      * Documentation : https://doc.babylonjs.com/babylon101/lights
      * @param name The firendly name of the light
      * @param scene The scene the light belongs too
      */
    def this(name: String, scene: Scene) = this()
  }
  
  @JSImport("babylonjs/Lights/index", "SpotLight")
  @js.native
  class SpotLight protected ()
    extends typingsSlinky.babylonjs.spotLightMod.SpotLight {
    /**
      * Creates a SpotLight object in the scene. A spot light is a simply light oriented cone.
      * It can cast shadows.
      * Documentation : https://doc.babylonjs.com/babylon101/lights
      * @param name The light friendly name
      * @param position The position of the spot light in the scene
      * @param direction The direction of the light in the scene
      * @param angle The cone angle of the light in Radians
      * @param exponent The light decay speed with the distance from the emission spot
      * @param scene The scene the lights belongs to
      */
    def this(name: String, position: Vector3, direction: Vector3, angle: Double, exponent: Double, scene: Scene) = this()
  }
  /* static members */
  object SpotLight {
    
    @JSImport("babylonjs/Lights/index", "SpotLight")
    @js.native
    val ^ : js.Any = js.native
    
    @JSImport("babylonjs/Lights/index", "SpotLight._IsProceduralTexture")
    @js.native
    def _IsProceduralTexture: js.Any = js.native
    @scala.inline
    def _IsProceduralTexture_=(x: js.Any): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("_IsProceduralTexture")(x.asInstanceOf[js.Any])
    
    @JSImport("babylonjs/Lights/index", "SpotLight._IsTexture")
    @js.native
    def _IsTexture: js.Any = js.native
    @scala.inline
    def _IsTexture_=(x: js.Any): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("_IsTexture")(x.asInstanceOf[js.Any])
  }
}
